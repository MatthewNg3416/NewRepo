/* Generated by Together */

#include "stdafx.h"
#include "IIO.h"
#include "MLighting.h"

#include <math.h>

#include "common.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/** @stereotype constructor */
MLighting::MLighting()
{
	m_plnkIO = NULL;
	m_usOAddrStartBit = 0;
	m_usUseBit = 0;
	m_usOAddrOnOff = 0;
	m_usTrigger = 0;
	m_usValue = 0;
}

/** @stereotype constructor
*/
MLighting::MLighting(SCommonAttribute commonData, IIO *pIIO, SLightingVal sLight)
: ICommon(commonData), m_usValue(0)
{
	AssignComponents(pIIO);	
	SetData(sLight);

	/** Chanel On시키기 */
	int iError = LightOn();
	if (iError)
	{
		//SetErrorLevel(_T("LIGHTING on Channel"),3, __FILE__, __LINE__);
		//WriteErrorLog("MLighting : Channel On Error!");
	}
}

MLighting::~MLighting()
{
	LightOff();

	TRACE(_T("Lighting 소멸\n"));
}

int MLighting::Initialize()
{
	LightOff();

	if (m_usTrigger != NULL)
	{
		outputOff(m_usTrigger);
	}

	return ERR_LIGHTING_SUCCESS;
}

int MLighting::SetValue(unsigned short val)
{
	unsigned short rgusRemainder[DEF_MAX_LIGHTING_VALUE_BIT];
	unsigned short usDivideValue = val;

	memset(rgusRemainder, 0, sizeof(rgusRemainder));

	if (usDivideValue < 0 || usDivideValue > pow(2.0, m_usUseBit))
		return generateErrorCode(205000);	

	if (DEF_LIGHTING_NONE_CHANNEL != m_rgusChannel[0])
	{
		for (int i = 0; i < DEF_LIGHTING_CHANNEL_BIT; i++)
		{   
			m_rgusChannel[i] ? outputOn(m_usOAddrChChangeStartBit + i) : outputOff(m_usOAddrChChangeStartBit + i);
		}
	}

	/** 밝기값 설정 하기 */
	for (int i = 0; i < m_usUseBit && usDivideValue > 0; i++)
	{
		rgusRemainder[i] = usDivideValue % 2;
		usDivideValue = unsigned short(usDivideValue / 2);
	}

	for (int i = 0; i < m_usUseBit; i++)
	{
		if (m_usInverse)
			rgusRemainder[i] ? outputOff(m_usOAddrStartBit + i) : outputOn(m_usOAddrStartBit + i);
		else
			rgusRemainder[i] ? outputOn(m_usOAddrStartBit + i) : outputOff(m_usOAddrStartBit + i);
	}

	/** Trigger On/Off */
	if (m_usTrigger != NULL)
	{
		outputOn(m_usTrigger);
		Sleep(100);
		outputOff(m_usTrigger);
		Sleep(100);
	}

	m_usValue = val;

	return ERR_LIGHTING_SUCCESS;
}

int MLighting::GetValue()
{
	return m_usValue;
}

int MLighting::LightOn()
{
	if (m_usOAddrOnOff != NULL)	//KKY
	{
		int iError = outputOn(m_usOAddrOnOff);
		if (iError)
			// 113000 = On 실패
			return generateErrorCode(113000);
	}
	else
	{
		SetValue(m_usValue);	//KKY
	}

	return ERR_LIGHTING_SUCCESS;
}

int MLighting::LightOff()
{
	if (m_usOAddrOnOff != NULL)	//KKY
	{
		int iError = outputOff(m_usOAddrOnOff);
		if (iError)
			// 113001 = Off 실패
			return generateErrorCode(113001);
	}
	else
	{
		SetValue(0);	//KKY
	}
	return ERR_LIGHTING_SUCCESS;
}

/**
 * Assign component linkage
 * 
 * @param	pIO	: 참조할 IO Component Pointer
 */
int MLighting::AssignComponents(IIO *pIO)
{
	ASSERT(pIO != NULL);
	m_plnkIO = pIO;
	return ERR_LIGHTING_SUCCESS;
}

int MLighting::SetData(SLightingVal sLighting)
{
	m_usOAddrStartBit = sLighting.m_usOAddrStartBit;
	m_usUseBit = sLighting.m_usUseBit;
	m_usOAddrOnOff = sLighting.m_usOAddrOnOff;
	m_usTrigger = sLighting.m_usTrigger;
	m_usOAddrChChangeStartBit = sLighting.m_usOAddrChChangeStartBit;
	m_usInverse = sLighting.m_usInverse;	//KKY

	/** Chanel 설정 하기 */
	unsigned short usCh = sLighting.m_usSelectChanel;
	
	if (DEF_LIGHTING_NONE_CHANNEL != usCh)
	{
		switch (usCh)
		{
			case DEF_LIGHTING_CHANNEL1:	m_rgusChannel[0] = 1;	m_rgusChannel[1] = 1;	break;
			case DEF_LIGHTING_CHANNEL2:	m_rgusChannel[0] = 0;	m_rgusChannel[1] = 1;	break;
			case DEF_LIGHTING_CHANNEL3:	m_rgusChannel[0] = 1;	m_rgusChannel[1] = 0;	break;
			case DEF_LIGHTING_CHANNEL4:	m_rgusChannel[0] = 0;	m_rgusChannel[1] = 0;	break;
			default:
				break;
		}
	}
	else
	{
		m_rgusChannel[0] = DEF_LIGHTING_NONE_CHANNEL;
	}

	return ERR_LIGHTING_SUCCESS;
}

BOOL MLighting::IsOnLighting()
{
	BOOL bState = FALSE;
	if (m_usOAddrOnOff != NULL)	//KKY
	{
		bState = isOn(m_usOAddrOnOff);
	}
	else
	{
		bState = (GetValue() == 0) ? FALSE : TRUE;	//KKY
	}
	return bState;
}

inline int MLighting::outputOn(unsigned short usIOAddr)
{
	// Moritex NEW MLEK series 는 신호 상이 기존 조명 컨트롤러와 반대임.
	if (m_usInverse)
		return m_plnkIO->OutputOff(usIOAddr);
	else
		return m_plnkIO->OutputOn(usIOAddr);
}

inline int MLighting::outputOff(unsigned short usIOAddr)
{
	// Moritex NEW MLEK series 는 신호 상이 기존 조명 컨트롤러와 반대임.
	if (m_usInverse)
		return m_plnkIO->OutputOn(usIOAddr);
	else
		return m_plnkIO->OutputOff(usIOAddr);
}

inline BOOL MLighting::isOn(unsigned short usIOAddr)
{
	// Moritex NEW MLEK series 는 신호 상이 기존 조명 컨트롤러와 반대임.
	if (m_usInverse)
		return m_plnkIO->IsOff(usIOAddr);
	else
		return m_plnkIO->IsOn(usIOAddr);
}
