/* Generated by Together */
/* 
 * Axis Component
 *
 * Copyright 2004 by Mechatronics Center, Samsung Electronics, Inc.,
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of Smasung Electronics, Inc.("Confidential Information"). You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Samsung.
 */

#include "stdafx.h"
#include "math.h"

#include "IIO.h"
#include "MMMCLib.h"
#include "MAxis.h"
#include "MTrsAutoManager.h"
#include "DefIOAddrPreBonder.h"
#include "MPlatformOlbSystem.h"
#include "common.h"

extern	MPlatformOlbSystem	MOlbSystemPre;

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/**
 * MAxis.cpp : This file implements the class of single-axis Configuration.
 *					이 파일은 단축 구성을 위한 Class의 실행 코드를 구현한다.
 *
 * @author Yong-Seog Pahn(dragon.pahn@samsung.com)
 * @version $Revision$
 */

/**
 * Constructor : Clear data(default value), initialize inner object
 *				 Data를 초기화하고, 내부 개체들을 초기화한다.
 * @stereotype constructor
 */
MAxis::MAxis()
{
	/** 1축 구성 member variable 초기화 */
	m_SaxAxis.iAxisID = 0;
	memset(m_SaxAxis.szName, 0, sizeof(m_SaxAxis.szName));
	m_SaxAxis.iCPhaseUseType = DEF_USE_SWITCH_ONLY;
	m_SaxAxis.bOriginDir = FALSE;
	m_SaxAxis.bOriginFineDir = FALSE;
	m_SaxAxis.bSign = TRUE;
	m_SaxAxis.dScale = 1.0;
	m_SaxAxis.iOriginPriority = 0;
	m_SaxAxis.bAbsEncoder = FALSE;

	/** Motion Library 개체 초기화 */
	m_pMotionLib = NULL;

	/** IO Component */
	m_plnkIO = NULL;

	/** Interlock IO Address */
	m_usiInterlockIOAddr = 0;

	/** Interlock IO Check Value */
	m_bInterlockJudge = 0;

	/** Timer 개체 생성 */
	m_bOriginFlag = FALSE;
	m_iOriginStep = DEF_ORIGIN_START_STEP;
	m_iOriginPrevStep = DEF_ORIGIN_START_STEP;
	m_iOriginError = ERR_MOTION_SUCCESS;
	m_ttOriginTimer = MTickTimer();

	/** For Simulation */
	m_dCurrentAxisPos = 0.0;
	m_dTargetAxisPos = 0.0;
	m_dRMoveDistance = 0.0;
	m_dVelocity = 0.0;
	m_iAccelerate = 0;
	m_iDecelerate = 0;
	m_bRMoveStart = FALSE;
	m_MotionTimer.StopTimer();
}
/** 
 * Constructor
 * 
 * @param	SCommonAttribute commonData(공통적으로 사용할 Data)
 * @param	SSMotionData datComponent(참조할 Component 포인터 리스트)
 * @param	IIO* pIO(참조할 IO Compnent 포인터 리스트)
 */
MAxis::MAxis(SCommonAttribute commonData, SSMotionData datComponent, IIO* pIO)
: ICommon(commonData)
{
	int iResult;

	/** 1축 구성 member variable 초기화 */
	SetData(&datComponent);

	/** Motion Library 개체 초기화 */
	m_pMotionLib = NULL;

	/** IO Component */
	m_plnkIO = pIO;

	/** Interlock IO Address */
	m_usiInterlockIOAddr = 0;

	/** Interlock IO Check Value */
	m_bInterlockJudge = 0;

	/** Timer 개체 생성 */
	m_bOriginFlag = FALSE;
	m_iOriginStep = DEF_ORIGIN_START_STEP;
	m_iOriginPrevStep = DEF_ORIGIN_START_STEP;
	m_iOriginError = ERR_MOTION_SUCCESS;
	m_ttOriginTimer = MTickTimer();
	
	/** Component 초기화 */
	if ((iResult = Initialize(commonData, datComponent.m_iBoardType, m_SaxAxis)) != ERR_MOTION_SUCCESS)
	{
		// Error 처리
	}

	/** Timer 개체 생성 */
	m_ttOriginTimer = MTickTimer();

	/** For Simulation */
	m_dCurrentAxisPos = 0.0;
	m_dTargetAxisPos = 0.0;
	m_dRMoveDistance = 0.0;
	m_dVelocity = 0.0;
	m_iAccelerate = 0;
	m_iDecelerate = 0;
	m_bRMoveStart = FALSE;
	m_MotionTimer.StopTimer();
}

/**
 * Destructor : Delete inner opbject
 *				내부 개체를 소멸한다.
 * @stereotype destructor
 */
MAxis::~MAxis()
{
	/** Axis All Stop */
	/** Servo All Off */
	m_pMotionLib->SetStop(m_SaxAxis.iAxisID, DEF_STOP);
	m_pMotionLib->SetAmpEnable(m_SaxAxis.iAxisID, FALSE);
	m_pMotionLib->SetUseAxis(m_SaxAxis.iAxisID, FALSE);

	/** Motion Library 개체 초기화 */
	if (m_pMotionLib != NULL)
	{
		/** Motion Library 개체 소멸 */
		delete m_pMotionLib;
		m_pMotionLib = NULL;
	}
}

/** Component에 데이타를 설정한다.
 * @param   *pData       : 설정할 각 축의 설정 Data
 * @return	Error : 0 = Success, 그외=기타
 */
int MAxis::SetData(SSMotionData* pData)
{
	m_strFileName				= pData->m_strFileName;	//	데이타 파일 이름

	swprintf(m_SaxAxis.szName, _T("%s"), pData->m_sAxisVal.szName);
//	sprintf(m_SaxAxis.szName, "%s", pData->m_sAxisVal.szName);

	/** 생성자를 통해 시스템에서 받은 데이타를 SAxis1 형태로 변환한다. */
	m_SaxAxis.iAxisID			= pData->m_sAxisVal.iAxisID;			// HC-MMC B'd전체 분배
	m_SaxAxis.iOriginPriority	= pData->m_sAxisVal.iOriginPriority;
	m_SaxAxis.bSign				= pData->m_sAxisVal.bSign;
 	m_SaxAxis.bOriginDir		= pData->m_sAxisVal.bOriginDir;
	m_SaxAxis.bOriginFineDir	= pData->m_sAxisVal.bOriginFineDir;
 	m_SaxAxis.iCPhaseUseType	= pData->m_sAxisVal.iCPhaseUseType;
	m_SaxAxis.dScale			= pData->m_sAxisVal.dScale;
	m_SaxAxis.iRoleOfHome		= pData->m_sAxisVal.iRoleOfHome;
	m_SaxAxis.bAbsEncoder		= pData->m_sAxisVal.bAbsEncoder;

	return ERR_MOTION_SUCCESS;
}

/** 설정한 data를 조회한다..
 * @param   *pData       : 설정할 각 축의 설정 Data
 * @return	Error : 0 = Success, 그외=기타
 */
int MAxis::GetData(SSMotionData* pData)
{
	swprintf(pData->m_sAxisVal.szName, _T("%s"), m_SaxAxis.szName);
//	sprintf(pData->m_sAxisVal.szName, "%s", m_SaxAxis.szName);

	/** 생성자를 통해 시스템에서 받은 데이타를 SAxis1 형태로 변환한다. */
	pData->m_sAxisVal.iAxisID			= m_SaxAxis.iAxisID;				// HC-MMC B'd전체 분배
	pData->m_sAxisVal.iOriginPriority	= m_SaxAxis.iOriginPriority;	
	pData->m_sAxisVal.bSign				= m_SaxAxis.bSign;				
 	pData->m_sAxisVal.bOriginDir		= m_SaxAxis.bOriginDir;		
	pData->m_sAxisVal.bOriginFineDir	= m_SaxAxis.bOriginFineDir;	
 	pData->m_sAxisVal.iCPhaseUseType	= m_SaxAxis.iCPhaseUseType;		
	pData->m_sAxisVal.dScale			= m_SaxAxis.dScale;			
	pData->m_sAxisVal.bAbsEncoder		= m_SaxAxis.bAbsEncoder;				

	return ERR_MOTION_SUCCESS;
}

/** Parameter 데이타를 Load 한다.
 * @return	Error : 0 = Success, 그외=기타
 */
int	MAxis::LoadParameter()
{
	int iResult;
	MAxisData	fileData("",m_strFileName);

	/** 파일에서 데이타를 읽고 사용자가 설정한 데이타를 적절히 섞어서 모션이 사용할 
	 * 파라미터 구조를 만들어 모션을 초기화 한다.
	 */

	/** 파일에서 데이타를 읽는다. */
	fileData.SetSection(m_SaxAxis.szName);	// Section을 지정 한다.

	BOOL bReadSuccess = fileData.ReadData();
	m_AxisParameter = fileData;	// Component 형태로 저장한다.
	/** 시스템에서 받은 데이타와 로드한 데이타를 가지고 Component를 초기화 한다. */
	iResult = SetAxisData();

	if (!bReadSuccess)
		return generateErrorCode(105118);	// ERR_MAXES_PARAMETER_LOAD_FAIL;
	
	return iResult;
}

/** Component에 데이타를 저장한다. 이때 파일에 같이 저장한다.
 * @param   *pData       : 설정할 각 축의 설정 Data
 * @return	Error : 0 = Success, 그외=기타
 */
int MAxis::SaveParameter(MAxisData* pData)
{
	int	iResult = ERR_MOTION_SUCCESS;

	MAxisData	fileData("",m_strFileName);

	/** 파일에서 데이타를 읽고 사용자가 설정한 데이타를 적절히 섞어서 모션이 사용할 
	 * 파라미터 구조를 만들어 모션을 초기화 한다.
	 */

	/** 파일에 저장 한다. */
	m_AxisParameter = *pData;
	fileData = m_AxisParameter;	// 저장할 데이타를 복사한다.

	fileData.SetSection(m_SaxAxis.szName);	// Section을 지정 한다.
	if (fileData.WriteData() != TRUE)
		iResult = generateErrorCode(105119);	// ERR_MAXES_PARAMETER_SAVE_FAIL

	/** 데이타를 Component 변수에 저장한다. */
	iResult = SetAxisData();

	return iResult;
}

/** 축 Parameter(DataManager)를 얻는다. 
 * @param   *pData       : 설정할 각 축의 설정 Data
 */
void MAxis::GetParameter(MAxisData* pData)
{
	*pData	= m_AxisParameter;
}


/**
 * 축의 이름을 Return 한다.
 * @return : Axis Name
 */
CString MAxis::GetAxisName()
{
	CString strName;

	strName.Format(_T("%s"), m_SaxAxis.szName);
	return strName;
}

/**
 * Motion 동작을 즉시 정지할 Interlock 조건에 해당되는 IO Address와 기준값을 설정한다.
 *
 * @param	usiIOAddress : 설정할 Interlock IO Address
 * @param	bJudgeValue	: Interlock 판단할 값
 * @return	Error Code : 0 = SUCCESS, 그외 = Error
 */
void MAxis::SetInterlockIOAddr(unsigned short usiIOAddress, BOOL bJudgeValue)
{
	/** Interlock IO Address */
	m_usiInterlockIOAddr = usiIOAddress;

	/** Interlock IO Check Value */
	m_bInterlockJudge = bJudgeValue;
}

/**
 * Motion Component를 초기화한다.
 *
 * 1. Motion Board 종류에 맞는 Motion Library 개체를 생성한다.
 * 2. 축 구성 개수를 설정한다.
 * 3. 축 정보를 설정한다.
 *
 * @param	SCommonAttribute commonData(공통적으로 사용할 Data)
 * @param	iBoardType		: Motion Board Type(1=MMC Board, 2=MEI board, 3=PPC Board, ...)
 * @param	saxAxis			: 1축 구성 정보
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXES NUMBER(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  xx = INVALID MOTION BOARD TYPE(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::Initialize(SCommonAttribute commonData, int iBoardType, SAxis1 saxAxis)
{
	int iResult = ERR_MOTION_SUCCESS;
	BOOL bUse = FALSE;
	CString strLogMsg;

	/** Motion Board 종류에 따라 해당 Library Class를 생성한다. */
	/* 확인 필요 : MAxis 의 기능에 대한 재정의 필요 - MEI Motion 포함 여부...
	switch (iBoardType)
	{
	case DEF_MMC_BOARD_TYPE :			// MMC
		if (m_pMotionLib != NULL)
		{
			delete m_pMotionLib;
			m_pMotionLib = NULL;
		}

		m_pMotionLib = new MMMCLib(commonData);
		break;
	case DEF_MEI_BOARD_TYPE :			// MEI
	default : 
		break;
	}
	*/

	// => MAxis 는 일단 MMC Motion 전용으로 사용하게 되므로 Motion Type 확인은 Skip!
	// => 조건 비교 없이 바로 MMMCLib Instance 생성.
	if (m_pMotionLib != NULL)
	{
		delete m_pMotionLib;
		m_pMotionLib = NULL;
	}
	
	m_pMotionLib = new MMMCLib(commonData);

	/** Data 하나씩 범위 검사하며 설정 */
	if ((iResult = m_pMotionLib->GetUseAxis(saxAxis.iAxisID, &bUse)) != ERR_MOTION_SUCCESS)
		return iResult;

	if (bUse == TRUE)
		return generateErrorCode(105020);	// ERR_MAXES_USED_AXIS_ID

	/** 축 사용으로 설정 */
	if ((iResult = m_pMotionLib->SetUseAxis(saxAxis.iAxisID, TRUE)) != ERR_MOTION_SUCCESS)
		return iResult;
	
	if (m_SaxAxis.iRoleOfHome != HOME_N_NONE)
		SetHomeSensorEvent(DEF_E_STOP_EVENT);
	else
		SetHomeSensorEvent(DEF_NO_EVENT);

	SetPositiveSensorEvent(DEF_E_STOP_EVENT);
	SetNegativeSensorEvent(DEF_E_STOP_EVENT);

	return ERR_MOTION_SUCCESS;
}
/**
 * 축 1개에 대한 Data를 설정한다.(구조체)
 *
 *	(1) 축 정보 영역이 있어야 한다.
 *	(2) 축이 이미 사용되고 있으면 안된다.
 *
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  xx = USED AXIS ID(MULTIAXES)
 *							  xx = NO EXIST AXIS PARAMETER AREA(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::SetAxisData()
{
	int		iResult = ERR_MOTION_SUCCESS;
	double	dPos;
	BOOL	bLevel;

	if ((iResult = checkAxisParameter(m_SaxAxis)) != ERR_MOTION_SUCCESS)
		return iResult;

	m_pMotionLib->GetInPosition(m_SaxAxis.iAxisID, &dPos, &bLevel);
	m_pMotionLib->SetInPosition(m_SaxAxis.iAxisID, m_AxisParameter.dTolerance * m_SaxAxis.dScale, bLevel);

	return ERR_MOTION_SUCCESS;
}
/**
 * 축 1개에 대한 Data를 읽는다.(구조체)
 *
 * @param   *pax1Data       : 설정할 각 축의 설정 Data
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::GetAxisData(SAxis1* pax1Data)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(pax1Data, TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS get Axis Data"),3, __FILE__, __LINE__);
		return iResult;
	}

	*pax1Data = m_SaxAxis;
	
	return ERR_MOTION_SUCCESS;
}
/** 
 * Board에 대한 자동 가, 감속 사용여부를 설정한다.
 *
 * @param   iBoardNo        : MMC Board 번호 0 ~ 7, -1 = All Board
 * @param   *pbAutoSet      : 자동 가,감속 설정여부, TRUE : 수동, FALSE : 자동, iBoardNo=-1이면 배열로 구성
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::SetAutoCP(int iBoardNo, BOOL* pbAutoSet)
{
	int iResult = ERR_MOTION_SUCCESS;
	short siTotalBoardNum;

	if ((iResult = checkBoardExistArgument(iBoardNo,(void*)pbAutoSet, TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Auto Accel/Decel Option"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** Board 구성 개수만큼 설정 */
	if (iBoardNo == DEF_ALL_MOTION_BD_ID)	// 전체 Board인 경우
	{
		/** 할당된 메모리에 설정 */
		if ((iResult = m_pMotionLib->GetBoardNum(&siTotalBoardNum)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("AXIS set Auto Accel/Decel Option"),3, __FILE__, __LINE__);
			return iResult;
		}

		for (int i = 0; i < siTotalBoardNum; i++)
		{
			if ((iResult = m_pMotionLib->SetSplAutoOff(i, pbAutoSet[i])) != ERR_MOTION_SUCCESS)
			{
				SetErrorLevel(_T("AXIS set Auto Accel/Decel Option"),3, __FILE__, __LINE__);
				return iResult;
			}
		}
	}
	else	// 축 하나인 경우
	{
		if ((iResult = m_pMotionLib->SetSplAutoOff(iBoardNo, *pbAutoSet)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("AXIS set Auto Accel/Decel Option"),3, __FILE__, __LINE__);
			return iResult;
		}
	}

	return ERR_MOTION_SUCCESS;
}
/** 
 * Board에 대한 자동 가, 감속 사용여부를 읽는다.
 *(Library에 조회 기능이 없는 관계로 SetAutpCP() 사용시에만 조회와 실제동작이 일치함)
 *
 * @param   iBoardNo        : MMC Board 번호 0 ~ 7, -1 = All Board
 * @param   *pbAutoSet      : 자동 가,감속 설정여부, TRUE : 수동, FALSE : 자동, iBoardNo=-1이면 배열로 구성
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::GetAutoCP(int iBoardNo, BOOL* pbAutoSet)
{
	int iResult = ERR_MOTION_SUCCESS;
	short siTotalBoardNum;

	if ((iResult = checkBoardExistArgument(iBoardNo,(void*)pbAutoSet, TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS get Auto Accel/Decel Option"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** Board 구성 개수만큼 설정 */
	if (iBoardNo == DEF_ALL_MOTION_BD_ID)	// 전체 Board인 경우
	{
		/** 할당된 메모리에서 Data 읽기 */
		if ((iResult = m_pMotionLib->GetBoardNum(&siTotalBoardNum)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("AXIS get Auto Accel/Decel Option"),3, __FILE__, __LINE__);
			return iResult;
		}

		for (int i = 0; i < siTotalBoardNum; i++)
		{
			if ((iResult = m_pMotionLib->GetSplAutoOff(i,(pbAutoSet + i))) != ERR_MOTION_SUCCESS)
			{
				SetErrorLevel(_T("AXIS get Auto Accel/Decel Option"),3, __FILE__, __LINE__);
				return iResult;
			}
		}
	}
	else	// 축 하나인 경우
	{
		if ((iResult = m_pMotionLib->GetSplAutoOff(iBoardNo, pbAutoSet)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("AXIS get Auto Accel/Decel Option"),3, __FILE__, __LINE__);
			return iResult;
		}
	}

	return ERR_MOTION_SUCCESS;
}

/** 
 * 축 1개에 대한 Axis ID를 읽는다.
 *
 * @return	Error Code		: Axis ID
 */
int MAxis::GetAxisID()
{
	return m_SaxAxis.iAxisID;	
}

/** 
 * 축 1개에 대한 Home 위치(원점복귀위치)를 읽는다.
 *
 * @return  double		 : 읽은 dHomePosition	 
 */
double MAxis::GetHomeOffset()
{
	return m_AxisParameter.dHomeOffset;	
}

/** 
 * 축 1개에 대한 Negative Limit 위치를 읽는다.
 *
 * @return   double     : 읽은 dNegativeLimit Position	 
 */
double MAxis::GetNegativeSWLimit()
{
	return m_AxisParameter.dCCWSWLimit;	
}

/** 
 * 축 1개에 대한 Positive Limit 위치를 읽는다.
 *
 * @return   double     : 읽은 dPositiveLimit Position	 
 */
double MAxis::GetPositiveSWLimit()
{
	return m_AxisParameter.dCWSWLimit;	
}

/** 
 * 축 1개에 대한 Slow Moving속도(Manual Run Velocity)를 읽는다.
 *
 * @return  double  : 읽은 dSlowMovingVelocity
 */
double MAxis::GetSlowMovingVelocity()
{
	return m_AxisParameter.dSlowRunVelocity;
}

/** 
 * 축 1개에 대한 Moving속도, 가속도를 읽는다.
 *
 * @return  double  : 읽은 dMovingVelocity
 */
double MAxis::GetMovingVelocity()
{
	return m_AxisParameter.dRunVelocity;
}

/** 
 * 축 1개에 대한 Moving속도, 가속도를 읽는다.
 *
 * @return double  : 읽은 iMovingAccelerate	 
 */
int MAxis::GetMovingAccelerate()
{
	return m_AxisParameter.iRunAccelerate;
}

/** 
 * 축 1개에 대한 Coarse속도, 가속도를 읽는다.
 *
 * return   double      : 읽은 dCoarseVelocity	 
 */
double MAxis::GetCoarseVelocity()
{
	return m_AxisParameter.dHomeFastVelocity;	
}

/** 
 * 축 1개에 대한 Coarse속도, 가속도를 읽는다.
 *
 * @return   int    : 읽은 iCoarseAccelerate	 
 */
int MAxis::GetCoarseAccelerate()
{
	return m_AxisParameter.iHomeAccelerate;
}

/** 
 * 축 1개에 대한 Fine속도, 가속도를 읽는다.
 *
 * @return  double     : 읽은 dFineVelocity	 
 */
double MAxis::GetFineVelocity()
{
	return m_AxisParameter.dHomeSlowVelocity;
}

/** 
 * 축 1개에 대한 Fine속도, 가속도를 읽는다.
 *
 * @return   double    : 읽은 iFineAccelerate	 
 */
int MAxis::GetFineAccelerate()
{
	return m_AxisParameter.iHomeAccelerate;
}

/** 
 * 축 1개에 대한 Jog Move의 Slow, 속도를 읽는다.
 *
 * @return   double         : 읽은 dJogSlow	 
 */
double MAxis::GetJogSlow()
{
	return m_AxisParameter.dJogSlow;	
}

/** 
 * 축 1개에 대한 Jog Move의 Fast, 속도를 읽는다.
 *
 * @return   double     : 읽은 dJogFast	 
 */
double MAxis::GetJogFast()
{
	return m_AxisParameter.dJogFast;
}

/** 
 * 축 1개에 대한 Sign을 읽는다.
 *
 * @return	BOOL          : 읽은 bSign 
 */
BOOL MAxis::GetSign()
{
	return m_SaxAxis.bSign;
}

/** 
 * 축 1개에 대한 Encoder Type이 ABS인지를 읽는다.
 *
 * @return   BOOL          : 읽은 bAbsEncoder	 
 */
BOOL MAxis::IsAbsEncoder() 
{
	return m_SaxAxis.bAbsEncoder;
}

/** 
 * 축 1개에 대한 원점복귀 진행(Coarse구간)방향을 읽는다.
 *   Coarse 속도 구간에서 초기 진행방향을 읽을 수 있게 한다.
 *
 * @return   BOOL           : 설정할 bOriginDir(TRUE : +방향, FALSE : -방향) 
 */
BOOL MAxis::GetOriginDir()
{
	return m_SaxAxis.bOriginDir;
}

/** 
 * 축 1개에 대한 원점복귀 진행(Fine구간)방향을 읽는다.
 *   Fine 속도 구간에서 초기 진행방향을 읽을 수 있게 한다.
 *
 * @return   BOOL           : 설정할 bOriginDir(TRUE : +방향, FALSE : -방향)
 */
BOOL MAxis::GetOriginFineDir()
{
	return m_SaxAxis.bOriginFineDir;
}

/** 
 * 축 1개에 대한 C상 사용 Type 을 읽는다.
 *
 * @param   int           : 읽은 C 상 사용 type
 */
int MAxis::GetCPhaseUseType()
{
	return m_SaxAxis.iCPhaseUseType;
}
/** 
 * 축 1개에 대한 Scale을 읽는다.
 *
 * @return   double         : 읽은 dScale
 */
double MAxis::GetScale()
{
	return m_SaxAxis.dScale;
}

/** 
 * 축 이동 시 지연 시간을 읽는다.
 *
 * @return   double          : 설정된 이동 지연 시간(초단위)
 */
double MAxis::GetMoveTime()
{
	return m_AxisParameter.dLimitTime;
}
/** 
 * 축 이동 후 안정화 시간을 읽는다.
 *
 * @return   double          : 설정된 이동 후 안정화 시간(초단위)
 */
double MAxis::GetMoveAfterTime()
{
	return m_AxisParameter.dStabilityTime;
}

/** 
 * 축 위치 허용 오차를 읽는다.
 *
 * @return   double     : 설정된 위치 허용 오차(mm단위) 
 */
double MAxis::GetTolerance()
{
	return m_AxisParameter.dTolerance;
}

/** 
 * 축 위치 허용 오차를 읽는다.
 *
 * @return   double     : 설정된 Offset(mm단위)
 */
double MAxis::GetPassOffset()
{
	return m_AxisParameter.dPassOffset;
}

/** 
 * 축 원점복귀 완료 대기 시간(초)을 읽는다.
 *
 * @return   double          : 설정된 원점복귀 완료 대기 시간(초 단위)
 */
double MAxis::GetOriginWaitTime()
{
	return m_AxisParameter.dOriginLimitTime;
}

/**
 * 축이 원점복귀 됐는지 확인한다.(한개의 축에 대해 가능)
 * 확인하고자 하는 축에 대해 오류 Code를 읽어봐야 한다.
 * 
 * @return	: TRUE = 원점복귀 완료
 *            FALSE = 원점복귀 미완료
 */
BOOL MAxis::IsOriginReturn()
{
	return m_bOriginFlag;
}

/**
 * 원점복귀 Flag를 TRUE로..... (한개의 축)
 */
void MAxis::SetOriginFlag()
{
	m_bOriginFlag = TRUE;
}

/**
 * 축 원점복귀 해제하기(한개의 축에 대해 가능)
 * 
 * @param   *pbReturn        :(OPTION = NULL) 원점복귀 결과 읽기
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::ResetOrigin(BOOL* pbReturn)
{
	/** 축 관련 오류 점검 */
	int iResult = checkAxisExistArgument(TRUE);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS reset Origin"),3, __FILE__, __LINE__);
		return iResult;
	}

	m_bOriginFlag = FALSE;
	m_iOriginStep = 100;
	m_iOriginPrevStep = 100;
	m_iOriginError = ERR_MOTION_SUCCESS;

	if (pbReturn != NULL)
		*pbReturn = m_bOriginFlag;
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축 원점복귀 강제 종료하기(구성된 모든 축에 대해 동작 정지 명령 수행)
 * 
 * @return	Error Code		 : 0 = SUCCESS
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::StopReturnOrigin(void)
{
	int iResult = ERR_MOTION_SUCCESS;
	
	/** Thread 종료 */
	TerminateThread(m_hOriginThread, 0);

	/** 축 모두에 대해 VStop 명령 수행 */
	iResult = VStop();

	m_iOriginStep = DEF_ORIGIN_ERROR_STEP;
	//WriteErrorLog("StopReturnOrigin(): Origin Stop By User");
	SetErrorLevel(_T("AXIS stop Return Origin"),3, __FILE__, __LINE__);
	m_iOriginError = generateErrorCode(105062);	// ERR_MAXES_ORIGIN_STOP_BY_USER

	SetHomeSensorEvent(DEF_NO_EVENT);
	SetPositiveSensorEvent(DEF_E_STOP_EVENT);
	SetNegativeSensorEvent(DEF_E_STOP_EVENT);
	return iResult;
}

/**
 * 축의 현재좌표를 읽는다.
 * 
 * @param   bCommand  : 위치를 읽을 때 사용하는 방법 Command/Encorder
 * @return   dCurrentPosition   : 현재 좌표값
 */
double MAxis::GetCurrentPosition(BOOL bCommandType)
{	
#ifdef SIMULATION
	return m_dCurrentAxisPos;
#endif
	
	ASSERT(m_pMotionLib != NULL);

	/** 위치 읽기 */
	double dCurrentPosition;
	m_pMotionLib->GetPosition(m_SaxAxis.iAxisID, bCommandType, &dCurrentPosition);

	/** Encoder가 CCW Type이면 값은 역상이 되어야 한다. */
	double dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;

	dCurrentPosition *= (dSign / m_SaxAxis.dScale);
	
	return dCurrentPosition;
}

/**
 * 축의 현재좌표를 설정한다.
 * 
 * @param   dCurrentPosition     : 현재 좌표값
 * @param   bType                : 읽을 위치 종류, FALSE=실제위치, TRUE=목표위치
 * @return	Error Code		     : 0 = SUCCESS
 *								  xx = INVALID AXIS ID(MULTIAXES)
 *								  xx = INVALID POINTER(MULTIAXES)
 *								  그 외 = 타 함수 Return Error
 */
int MAxis::SetCurrentPosition(double dCurrentPosition, BOOL bType)
{
	double dPos;
	SMotionAxis mAx;

	/** 축 관련 오류 점검 */
	int iResult = checkAxisExistArgument(TRUE);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Current Position"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** Encoder가 CCW Type이면 값은 역상이 되어야 한다. */
	m_pMotionLib->GetMotorParam(m_SaxAxis.iAxisID, &mAx);
	double dEncDir = (mAx.bEncoderDir == DEF_CORD_CW) ? -1.0 : 1.0;

	double dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;

	if (bType == FALSE)
		dPos = dCurrentPosition * dEncDir * dSign * m_SaxAxis.dScale;
	else
		dPos = dCurrentPosition * dSign * m_SaxAxis.dScale;

	/** 위치 설정 */
	iResult = m_pMotionLib->SetPosition(m_SaxAxis.iAxisID, bType, dPos);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Current Position"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 현재좌표와 특정좌표간의 수치에 의한 좌표차이를 비교한다.
 * 
 * @param	bPosOpt              : 비교할 위치 종류, FALSE=현재위치, TRUE=Motion의 목표위치
 * @param   dTargetPosition      : 비교할 좌표값 
 * @param   *pdPermission        :(OPTION = NULL) 비교허용 오차, NULL이면 내부 Tolerance값으로 비교한다.
 * @param   *pdDeviation         :(OPTION = NULL) 비교 차이값
 * @return   BOOL	             : 비교결과
 */
BOOL MAxis::ComparePosition(BOOL bPosOpt, 
							double dTargetPosition,
							double* pdPermission, 
							double* pdDeviation)
{	
	double dCurPosition = 0.0;
	double dDevPosition = 0.0;

	/** 현재 위치 읽기 */
#ifdef SIMULATION
	dCurPosition = m_dCurrentAxisPos;
#else
	m_pMotionLib->GetPosition(m_SaxAxis.iAxisID, bPosOpt, &dCurPosition);
	
	double dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;

	dCurPosition *= (dSign / m_SaxAxis.dScale);
#endif	

	/** 위치 차이 계산 */
	dDevPosition = dTargetPosition - dCurPosition;
	if (pdDeviation != NULL)
		*pdDeviation = dDevPosition;

	/** Judge 결정 */
	if (pdPermission != NULL)
	{
		if (fabs(dDevPosition) <= *pdPermission)
		{
			SetErrorLevel(_T("AXIS compare Position"),3, __FILE__, __LINE__);
			return TRUE;		
		}
	}
	else
	{
		if (fabs(dDevPosition) <= m_AxisParameter.dTolerance)
		{
			SetErrorLevel(_T("AXIS compare Position"),3, __FILE__, __LINE__);
			return TRUE;		
		}		
	}
	
	return FALSE;
}

/**
 * 축의 현재좌표와 특정좌표간의 수치에 의한 좌표차이를 비교한다.
 * 
 * @param   dTargetPosition      : 비교할 좌표값	 
 * @param   *pdPermission        :(OPTION = NULL) 비교허용 오차, NULL이면 내부 Tolerance값으로 비교한다.
 * @return  BOOL	             : 비교결과, 비교 좌표가 현재 좌표 - Tolerance 보다 작으면 True, 아니면 False
 */
BOOL MAxis::IsLessThanTargetPosition(double dTargetPosition, double* pdPermission)
{
	double dCurPosition = 0.0;
	double dDevPosition = 0.0;

	/** 현재 위치 읽기 */
#ifdef SIMULATION
	dCurPosition = m_dCurrentAxisPos;
#else
	m_pMotionLib->GetPosition(m_SaxAxis.iAxisID, FALSE, &dCurPosition);
	
	/** Encoder가 CCW Type이면 값은 역상이 되어야 한다. */
	SMotionAxis mAx;
	m_pMotionLib->GetMotorParam(m_SaxAxis.iAxisID, &mAx);
	double dEncDir = (mAx.bEncoderDir == DEF_CORD_CW) ? 1.0 : -1.0;

	double dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;

	dCurPosition *= (dEncDir * dSign / m_SaxAxis.dScale);
#endif

	/** Judge 결정 */
	if (pdPermission != NULL)
	{
		/** 위치 차이 계산 */
		dDevPosition = dTargetPosition - *pdPermission - dCurPosition;
		if (dDevPosition >= 0)
			return TRUE;		
	}
	else
	{
		dDevPosition = dTargetPosition - m_AxisParameter.dTolerance - dCurPosition;
		if (dDevPosition >= 0)
			return TRUE;		
	}
	
	return FALSE;
}

/**
 * 축의 현재좌표와 특정좌표간의 수치에 의한 좌표차이를 비교한다.
 * 
 * @param   dTargetPosition      : 비교할 좌표값	 
 * @param   *pdPermission        :(OPTION = NULL) 비교허용 오차, NULL이면 내부 Tolerance값으로 비교한다.
 * @return  BOOL	             : 비교결과, 비교할 좌표가 현재 좌표 + Tolerance 보다 크면 True, 아니면 False
 */
BOOL MAxis::IsGreaterThanTargetPosition(double dTargetPosition, double *pdPermission)
{
	double dCurPosition = 0.0;
	double dDevPosition = 0.0;

	/** 현재 위치 읽기 */
#ifdef SIMULATION
	dCurPosition = m_dCurrentAxisPos;
#else
	m_pMotionLib->GetPosition(m_SaxAxis.iAxisID, FALSE, &dCurPosition);
	
	/** Encoder가 CCW Type이면 값은 역상이 되어야 한다. */
	SMotionAxis mAx;
	m_pMotionLib->GetMotorParam(m_SaxAxis.iAxisID, &mAx);
	double dEncDir = (mAx.bEncoderDir == DEF_CORD_CW) ? 1.0 : -1.0;

	double dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;

	dCurPosition *= (dEncDir * dSign / m_SaxAxis.dScale);
#endif

	/** Judge 결정 */
	if (pdPermission != NULL)
	{
		/** 위치 차이 계산 */
		dDevPosition = dTargetPosition + *pdPermission - dCurPosition;
		if (dDevPosition <= 0)
			return TRUE;		
	}
	else
	{
		dDevPosition = dTargetPosition + m_AxisParameter.dTolerance - dCurPosition;
		if (dDevPosition <= 0)
			return TRUE;		
	}
	
	return FALSE;
}

/**
 * 축 이동(한개의 축에 대한 이동) - 이동 완료된 후 return
 * 
 * @param   dPosition        : 이동할 위치
 * @param   dVelocity        :(OPTION=0.0) 이동할 속도, 0.0 = 지정된 속도 사용
 * @param   iAccelerate      :(OPTION=0) 이동할 가속도, 0 = 지정된 가속도 사용	
 * @param   iDecelerate      :(OPTION=0) 이동할 감속도, 0 = 지정된 감속도 사용	
 * @param	iMoveType        :(OPTION=1) 이동 Type,
 *											0=사다리꼴 속도 Profile, 절대좌표 이동
 *											1=S-Curve 속도 Profile, 절대좌표 이동
 *											4=비대칭 사다리꼴 속도 Profile, 절대좌표 이동
 *											5=비대칭 S-Curve 속도 Profile, 절대좌표 이동
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  xx = INVALID MOVE-TYPE(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::Move(double dPosition, 
				 double dVelocity, 
				 int iAccelerate, 
				 int iDecelerate, 
				 int iMoveType)
{
	if ((iMoveType == DEF_MOVE_DISTANCE) 
		|| (iMoveType == DEF_SMOVE_DISTANCE)
		|| (iMoveType == DEF_TMOVE_DISTANCE) 
		|| (iMoveType == DEF_TSMOVE_DISTANCE))
	{
		CString strLogMsg;
		//strLogMsg.Format(_T("Move() : Invalid iMoveType Arguement %d"),iMoveType);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("AXIS move (Invalid iMoveType Arguement %d)"),iMoveType);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(105054);	// ERR_MAXES_INVALID_MOVE_TYPE
	}

	int iResult = StartMove(dPosition, dVelocity, iAccelerate, iDecelerate, iMoveType);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS move"),3, __FILE__, __LINE__);
		return iResult;
	}

	return Wait4Done();
}
/**
 * 축 이동(한개의 축에 대한 이동) - 이동 명령 후 바로 return
 * 
 * @param   dPosition        : 이동할 위치
 * @param   dVelocity        :(OPTION=0.0) 이동할 속도, 0.0 = 지정된 속도 사용
 * @param   iAccelerate      :(OPTION=0) 이동할 가속도, 0 = 지정된 가속도 사용	
 * @param   iDecelerate      :(OPTION=0) 이동할 감속도, 0 = 지정된 감속도 사용	
 * @param	iMoveType        :(OPTION=1) 이동 Type,
 *											0=사다리꼴 속도 Profile, 절대좌표 이동
 *											1=S-Curve 속도 Profile, 절대좌표 이동
 *											4=비대칭 사다리꼴 속도 Profile, 절대좌표 이동
 *											5=비대칭 S-Curve 속도 Profile, 절대좌표 이동
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  xx = INVALID MOVE-TYPE(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::StartMove(double dPosition, 
					  double dVelocity, 
					  int iAccelerate, 
					  int iDecelerate, 
					  int iMoveType)
{
#ifdef SIMULATION
	m_MotionTimer.StartTimer();
	m_dTargetAxisPos = dPosition;
	m_dVelocity = dVelocity;
	m_iAccelerate = iAccelerate;
	m_iDecelerate = iDecelerate;
	m_bRMoveStart = FALSE;
	m_dRMoveDistance = 0.0;
	return ERR_MOTION_SUCCESS;
#endif

	/** 축 관련 오류 점검 */
	int iResult = checkAxisExistArgument(TRUE);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS move"),3, __FILE__, __LINE__);
		return iResult;
	}

	if (iMoveType == DEF_MOVE_DISTANCE
		|| iMoveType == DEF_SMOVE_DISTANCE
		|| iMoveType == DEF_TMOVE_DISTANCE 
		|| iMoveType == DEF_TSMOVE_DISTANCE)
	{
		CString strLogMsg;
		//strLogMsg.Format(_T("StartMove() : Invalid iMoveType Arguement %d"),iMoveType);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("AXIS start move (Invalid iMoveType Arguement %d)"),iMoveType);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(105054);	// ERR_MAXES_INVALID_MOVE_TYPE
	}

	/** 이동 전 원점복귀 여부 확인 */
	if (!IsOriginReturn())
	{
		//WriteErrorLog("StartMove(): Not Origin Returned ");
		SetErrorLevel(_T("AXIS start move"),3, __FILE__, __LINE__);
		return generateErrorCode(105050);
	}
	
	/** 축 상태 점검 */
	if ((iResult = checkAxisState(m_SaxAxis.iAxisID)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS start move"),3, __FILE__, __LINE__);
		return iResult;
	}

	double dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;

	double dPos = dSign * m_SaxAxis.dScale * dPosition;

	/** 이동 속도 처리 */
	double dVel;
	if (dVelocity == 0.0)
	{
		if (m_AxisParameter.eVelocityMode == VELOCITY_MODE_NORMAL)
			dVel = m_SaxAxis.dScale * m_AxisParameter.dRunVelocity;
		else
			dVel = m_SaxAxis.dScale * m_AxisParameter.dSlowRunVelocity;
	}
	else
		dVel = dSign * m_SaxAxis.dScale * dVelocity;

	/** 이동 가속도 처리 */
	short iAccel = (iAccelerate == 0)
					? m_AxisParameter.iRunAccelerate
					: iAccelerate;

	/** 이동 감속도 처리 */
	short iDecel = (iDecelerate == 0)
					? m_AxisParameter.iRunAccelerate
					: iDecelerate;

	/** SW Limit Check */
	if ((iResult = checkSWLimit(dPosition)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS start move"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** No-wait 이동 */
	return m_pMotionLib->Move(m_SaxAxis.iAxisID, dPos, dVel, iAccel, iDecel, iMoveType);
}

/**
 * 축 이동(한개의 축에 대한 상대위치 이동) - 이동 완료된 후 return
 * 
 * @param   dDistance        : 이동할 거리
 * @param   dVelocity        :(OPTION=0.0) 이동할 속도, 0.0 = 지정된 속도 사용
 * @param   iAccelerate      :(OPTION=0) 이동할 가속도, 0 = 지정된 가속도 사용	
 * @param   iDecelerate      :(OPTION=0) 이동할 감속도, 0 = 지정된 감속도 사용	
 * @param	iMoveType        :(OPTION=3) 이동 Type,
 *											2=사다리꼴 속도 Profile, 상대거리 이동
 *											3=S-Curve 속도 Profile, 상대거리 이동
 *											6=비대칭 사다리꼴 속도 Profile, 상대거리 이동
 *											7=비대칭 S-Curve 속도 Profile, 상대거리 이동
 * @param	bClearOpt        :(OPTION=FALSE) 이동 전과 후에 Encoder 값을 Clear하는 동작 사용 여부(TRUE:사용, FALSE:미사용)
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::RMove(double dDistance, 
				  double dVelocity,
				  int iAccelerate,
				  int iDecelerate,
				  int iMoveType, 
				  BOOL bClearOpt)
{
	/** 축 관련 오류 점검 */
	int iResult = checkAxisExistArgument(TRUE);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS move Relative Position"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** 이동 전 원점복귀 여부 확인 */
	if (!IsOriginReturn())
		return generateErrorCode(105050);

	if ((iMoveType == DEF_MOVE_POSITION) || (iMoveType == DEF_SMOVE_POSITION)
		|| (iMoveType == DEF_TMOVE_POSITION) || (iMoveType == DEF_TSMOVE_POSITION))
		return generateErrorCode(105054);	// ERR_MAXES_INVALID_MOVE_TYPE


	if ((iResult = StartRMove(dDistance, dVelocity, iAccelerate,
							  iDecelerate, iMoveType, bClearOpt)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS move Relative Position"),3, __FILE__, __LINE__);
		return iResult;
	}

	return Wait4Done(FALSE, FALSE, TRUE);
}

/**
 * 축 이동(한개의 축에 대한 상대위치 이동) - 이동 명령 후 바로 return
 * 
 * @param   dDistance        : 이동할 거리
 * @param   dVelocity        :(OPTION=0.0) 이동할 속도, 0.0 = 지정된 속도 사용
 * @param   iAccelerate      :(OPTION=0) 이동할 가속도, 0 = 지정된 가속도 사용	
 * @param   iDecelerate      :(OPTION=0) 이동할 감속도, 0 = 지정된 감속도 사용	
 * @param	iMoveType        :(OPTION=3) 이동 Type,
 *											2=사다리꼴 속도 Profile, 상대거리 이동
 *											3=S-Curve 속도 Profile, 상대거리 이동
 *											6=비대칭 사다리꼴 속도 Profile, 상대거리 이동
 *											7=비대칭 S-Curve 속도 Profile, 상대거리 이동
 * @param	bClearOpt        :(OPTION=FALSE) 이동 전과 후에 Encoder 값을 Clear하는 동작 사용 여부(TRUE:사용, FALSE:미사용)
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::StartRMove(double dDistance, 
					   double dVelocity, 
					   int iAccelerate,
					   int iDecelerate, 
					   int iMoveType, 
					   BOOL bClearOpt)
{
#ifdef SIMULATION
	m_MotionTimer.StartTimer();
	m_bRMoveStart = TRUE;
	m_dRMoveDistance = dDistance;
	m_dVelocity = dVelocity;
	m_iAccelerate = iAccelerate;
	m_iDecelerate = iDecelerate;
	return ERR_MOTION_SUCCESS;
#endif

	/** 축 관련 오류 점검 */
	int iResult = checkAxisExistArgument(TRUE);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS start move Relative Position"),3, __FILE__, __LINE__);
		return iResult;
	}

	if ((iMoveType == DEF_MOVE_POSITION) 
		|| (iMoveType == DEF_SMOVE_POSITION)
		|| (iMoveType == DEF_TMOVE_POSITION)
		|| (iMoveType == DEF_TSMOVE_POSITION))
	{
		CString strLogMsg;
		//strLogMsg.Format(_T("StartRMove() : Invalid iMoveType Arguement %d"),iMoveType);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("AXIS start move Relative Position (Invalid iMoveType Arguement %d"),iMoveType);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(105054);	// ERR_MAXES_INVALID_MOVE_TYPE
	}

	/** 축 상태 점검 */
	if ((iResult = checkAxisState(m_SaxAxis.iAxisID)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS start move Relative Position"),3, __FILE__, __LINE__);
		return iResult;
	}

	double dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;

	/** 위치 정리 */
	double dPos = dSign * m_SaxAxis.dScale * dDistance;

	/** 이동 속도 처리 */
	double dVel;
	if (dVelocity == 0.0)
	{
		if (m_AxisParameter.eVelocityMode == VELOCITY_MODE_NORMAL)
			dVel = dSign * m_SaxAxis.dScale * m_AxisParameter.dRunVelocity;
		else
			dVel = dSign * m_SaxAxis.dScale * m_AxisParameter.dSlowRunVelocity;
	}
	else
		dVel = dSign * m_SaxAxis.dScale * dVelocity;

	/** 이동 가속도 처리 */
	int iAccel = (iAccelerate == 0)
				? m_AxisParameter.iRunAccelerate
				: iAccelerate;

	/** 이동 감속도 처리 */
	int iDecel = (iDecelerate == 0)
				? m_AxisParameter.iRunAccelerate
				: iDecelerate;

	/** 현재 Command 값을 Clear하고 RMove 동작 수행 */
	if (bClearOpt ==TRUE)
	{
		/** 현재 위치와 목표 위치를 0.0으로 설정 */
		m_pMotionLib->SetPosition(m_SaxAxis.iAxisID, TRUE, 0.0);
	}

	/** No-wait 이동 */
	return m_pMotionLib->Move(m_SaxAxis.iAxisID, dPos, dVel, iAccel, iDecel, iMoveType, bClearOpt);
}

/**
 * 축 이동(한개의 축에 대한 등속 이동, 등속 위치까진 가속 이동함) 
 * 
 * @param   dVelocity        :(OPTION=0.0) 이동할 속도, 0.0 = 지정된 속도 사용
 * @param   iAccelerate      :(OPTION=0) 이동할 가속도, 0 = 지정된 가속도 사용	
 * @param   bDir             :(OPTION=TRUE) 이동할 방향, TRUE:(+), FALSE:(-), 생략하면(+방향으로 이동
 *                             dVelocity에 값을 넣어주면 bDir은 생략해서 사용하면 된다.
 *                             이 경우는 dVelocity의 부호에 의해 이동 방향이 결정된다.
 *                             dVelocity에 0.0을 넣어 지정된 속도를 사용하는 경우는
 *                             bDir로(+/-) 방향을 설정할 수 있다.
 *                             만약, dVelocity에 값을 넣은 경우 bDir을 설정을 하게 되면
 *                             지정된 dVelocuty, dAccelerate에 bDir이 반영되어 이동을 하게 된다.
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::VMove(double dVelocity, int iAccelerate, BOOL bDir)
{
	double dVel = 0.0;
	int iAccel = 0;
	double dSign;
	double dDir;

	/** 축 관련 오류 점검 */
	int iResult = checkAxisExistArgument(TRUE);
	if (iResult != ERR_MOTION_SUCCESS)
	{	
		SetErrorLevel(_T("AXIS move Uniform Velocity"),3, __FILE__, __LINE__);
		return iResult;
	}

	/**(+) 방향 */
	if (bDir == TRUE)
		dDir = 1.0;
	/**(-) 방향 */
	else
		dDir = -1.0;

	/** 축 상태 점검 */
	if ((iResult = checkAxisState(m_SaxAxis.iAxisID)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS move Uniform Velocity"),3, __FILE__, __LINE__);
		return iResult;
	}

	dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;

	/** 이동 속도 처리 */
	if (dVelocity == 0.0)
	{
		if (m_AxisParameter.eVelocityMode == VELOCITY_MODE_NORMAL)
			dVel = dDir * dSign * m_SaxAxis.dScale * m_AxisParameter.dRunVelocity;
		else
			dVel = dDir * dSign * m_SaxAxis.dScale * m_AxisParameter.dSlowRunVelocity;
	}
	else
		dVel = dDir * dSign * m_SaxAxis.dScale * dVelocity;

	/** 이동 가속도 처리 */
	if (iAccelerate == 0)
		iAccel = m_AxisParameter.iRunAccelerate;
	else
		iAccel = iAccelerate;

	if ((iResult = m_pMotionLib->VMove(m_SaxAxis.iAxisID, dVel, iAccel)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS move Uniform Velocity"),3, __FILE__, __LINE__);
		return iResult;
	}

	if ((iResult = checkAxisState(m_SaxAxis.iAxisID)) != ERR_MOTION_SUCCESS)
	{
		VStop();
		SetErrorLevel(_T("AXIS move Uniform Velocity"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축 이동 후 완료를 확인한다.(한개의 축에 대한 완료 확인) 
 * 
 * @param   bSkipMode        :(OPTION=FALSE) 위치 확인 대기, 이동 후 안정화 시간 지연 사용 여부
 * @param	bUseInterlock    :(OPTION=FALSE) Interlock에 의한 동작 정지 기능 사용 여부(FALSE:사용안함, TRUE:사용함)
 * @param	bRMove		     :(OPTION=FALSE) RMove시 기능 사용 여부(FALSE:사용안함, TRUE:사용함)
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  xx = TIMEOUT MOVE-TIME(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::Wait4Done(BOOL bSkipMode, BOOL bUseInterlock, BOOL bRMove)
{
#ifdef SIMULATION
	return ERR_MOTION_SUCCESS;




// 확인 필요... Simualtion 동작...

	double dTime = calculateMotionTime();

	if (m_MotionTimer.IsTimerStarted())
	{
		while (m_MotionTimer.LessThan(dTime))
		{
			if (FALSE == m_bRMoveStart && m_dCurrentAxisPos == m_dTargetAxisPos)
			{
				break;
			}
			
			if (TRUE == m_bRMoveStart && 0 == m_dRMoveDistance)
			{
				break;
			}
			
			if (m_MotionTimer.MoreThan(m_AxisParameter.dLimitTime))
			{
				SetErrorLevel(_T("AXIS wait for Done"),3, __FILE__, __LINE__);
				return generateErrorCode(105021);
			}
			
			Sleep(5);
		}
		
		if (FALSE == m_bRMoveStart)
		{
			m_dCurrentAxisPos = m_dTargetAxisPos;
		}
		else
		{
			m_dCurrentAxisPos += m_dRMoveDistance;
			m_dTargetAxisPos = m_dCurrentAxisPos;	// For AxisDone 확인
			m_bRMoveStart = FALSE;
		}
		
		m_MotionTimer.StopTimer();
	}

	return ERR_MOTION_SUCCESS;
#endif

	int		iState;
	BOOL	bWaitDone = FALSE;
	BOOL	bWaitDone1 = TRUE;
	DWORD	dwElasp = 0;
	BOOL	bVal;
	double	dCurrentPos, dTargetPos;

	/** 축 관련 오류 점검 */
	int iResult = checkAxisExistArgument(TRUE);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS wait for Done"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** Timer Start */
	m_ttMovingTimer.StartTimer();

	while (!IsAxisDone())
	{
		/** Interlock Check */
		if ((m_usiInterlockIOAddr != 0) && (bUseInterlock == TRUE))
		{
			if (m_bInterlockJudge == TRUE)
				bVal = m_plnkIO->IsOn(m_usiInterlockIOAddr);
			else
				bVal = m_plnkIO->IsOff(m_usiInterlockIOAddr);

			if (bVal == TRUE)
			{
				//-> Motion 정지
				Stop();
				//WriteErrorLog("Wait4Done() : IO Interlock Checked");
				SetErrorLevel(_T("AXIS wait for Done"),3, __FILE__, __LINE__);
				return generateErrorCode(105066);	// ERR_MAXES_INTERLOCK_CHECKED
			}
		}

		//축 상태 읽기
		iResult = GetAxisState(&iState);
		if (iResult)
		{
			SetErrorLevel(_T("AXIS wait for Done"),3, __FILE__, __LINE__);
			return iResult;
		}

		if (iState == DEF_E_STOP_EVENT)
		{
			// E-Stop Event 발생
			EStop();
			//WriteErrorLog("Wait4Done() : E-Stop Event");
			SetErrorLevel(_T("AXIS wait for Done"),3, __FILE__, __LINE__);
			return generateErrorCode(105058);
		}

		//Amp Fault 확인
		if (GetAmpFault())
		{
			//Amp Fault 발생
			EStop();
			//WriteErrorLog("Wait4Done() : Amp Fault");
			SetErrorLevel(_T("AXIS wait for Done"),3, __FILE__, __LINE__);
			return generateErrorCode(105008);
		}

		if (m_ttMovingTimer.MoreThan(m_AxisParameter.dLimitTime))
		{
			//WriteErrorLog("Wait4Done() : Motion TimeOut");
			SetErrorLevel(_T("AXIS wait for Done"),3, __FILE__, __LINE__);
			return generateErrorCode(105021);	// ERR_MAXES_TIMEOUT_MOVE_TIME
		}
		Sleep(5);
	}

	/** 축 상태 점검 */
	if ((iResult = checkAxisState(m_SaxAxis.iAxisID)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS wait for Done"),3, __FILE__, __LINE__);
		return iResult;
	}

	if (!bSkipMode) 
		Sleep((DWORD)(m_AxisParameter.dStabilityTime * 1000));
	else 
		return ERR_MOTION_SUCCESS;

	/** 이동 완료 후 현재 위치가 목표위치와 다르면 Error 처리 
	 *  RMove 인 경우 계산하지 말아야 함
	 */
	if (m_bOriginFlag == TRUE && bRMove == FALSE)	// 원점복귀되어 있으면 위치 확인을 한다.
	{
		/* 1. 현재 위치 읽기 */
		dCurrentPos = GetCurrentPosition(FALSE);			
		/* 2. 목표 위치 읽기 */
		dTargetPos = GetCurrentPosition(TRUE);
		
		/* 3. 현재 위치와 목표 위치 Tolerance값과 비교하기 */
		if (fabs(dCurrentPos - dTargetPos) > m_AxisParameter.dTolerance)
		{
			CString strtmp;
			strtmp.Format(_T("Wait4Done() : Not In Position  CurrentPos:%.3f TargetPos:%.3f"), dCurrentPos, dTargetPos);
			WriteNormalLog(strtmp);
			Sleep(50);

			// 1. 현재 위치 읽기
			dCurrentPos = GetCurrentPosition(FALSE);
			// 2. 목표 위치 읽기
			dTargetPos = GetCurrentPosition(TRUE);
			
			// 3. 현재 위치와 목표 위치 Tolerance값과 비교하기
			if (fabs(dCurrentPos - dTargetPos) > m_AxisParameter.dTolerance)
			{
				strtmp.Format(_T("Wait4Done() : Not In Position  CurrentPos:%.3f TargetPos:%.3f"), dCurrentPos, dTargetPos);
				WriteNormalLog(strtmp);

				// 확인 필요....
				//			return generateErrorCode(105067);	// ERR_MAXES_NOT_IN_POSITION

			}
		}
	}

	if(MOlbSystemPre.GetTrsAutoManagerComponent()->GetOPMode() == MANUAL_MODE)
	{
		if (m_bOriginFlag == FALSE)
		{
			if(m_plnkIO->IsOn(IN_FRONT_STEP_STOP_SW) == TRUE)
			{
				Stop();
			}
		}
	}

	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 동작 완료 여부를 Return 한다.(정헌식 : 2005.01.11)
 * 이동 및 속도 이동 완료 확인 또는 더불어 In-Position 여부까지 확인한다.
 *
 * MMC Library : axis_done()
 *
 * @return	: TRUE = AXIS_DONE
 *			  FALSE = AXIS IS IN COMMAND(MOTIONLIB)
 */
BOOL MAxis::IsAxisDone()
{
#ifdef SIMULATION
	if (m_dCurrentAxisPos == m_dTargetAxisPos)
	{
		return TRUE;
	}

	return FALSE;
#endif
	return m_pMotionLib->IsAxisDone(m_SaxAxis.iAxisID);
}

/**
 *	축이 이동 중(속도 > 0) 인지를 Return 한다.
 *
 *	MMC Library : in_motion(axis)
 *
 *	@return : TRUE  = 축 이동 중.
 *            FALSE = 축 정지 상태
 */
BOOL MAxis::IsInMotion()
{
#ifdef SIMULATION
	double dTime = calculateMotionTime();

	if (m_MotionTimer.IsTimerStarted()
		&& m_MotionTimer.GetElapseTime() < dTime)
	{
		return TRUE;
	}
	
	return FALSE;
#endif

	if (m_pMotionLib->InCommand(m_SaxAxis.iAxisID, 1/*DEF_INMOTION*/) > 0)
	{
		return TRUE;
	}
	
	return FALSE;
}

/**
 * 축의 동작 완료 여부를 Return 한다.(정헌식 : 2005.01.11)
 * 이동 및 속도 이동 완료 확인한다.  In-Position 확인안함
 *
 * MMC Library : motion_done()
 *
 * @return	: TRUE = AXIS_DONE
 *			  FALSE = AXIS IS IN COMMAND(MOTIONLIB)
 */
BOOL MAxis::IsMotionDone()
{
#ifdef SIMULATION
	if (m_dCurrentAxisPos == m_dTargetAxisPos)
	{
		return TRUE;
	}

	return FALSE;
#endif

	return m_pMotionLib->IsMotionDone(m_SaxAxis.iAxisID);
}

/**
 * 축의 동작중 속도명령값을 PULSE값으로 돌려준다.
 *
 * @return	해당 Axis의 ComVelocity
 */
int MAxis::GetComVelocity()
{
	return m_pMotionLib->GetComVelocity(m_SaxAxis.iAxisID);
}

/**
 * 직선보간 이동한다.
 * 
 * @param   iMaxPoint        : 직선보간 이동구간 개수
 * @param   *pdPosition      : 직선보간 이동구간 지정, iMaxPoint만큼 설정
 * @param   *pdVelocity      : 이동 시 속도, iMaxPoint만큼 설정(Scale은 적용되지 않는다.)
 * @param   *piAccelerate    : 이동 시 가속도, iMaxPoint만큼 설정
 * @param	bAutoFlag        : Auto CP 여부, FALSE=AutoCP 사용안함, TRUE=AutoCP 사용함
 * @param	bWaitOpt         :(OPTION=TRUE)축 이동 완료 대기 여부, FALSE=대기 안함, TRUE=대기함
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  xx = NO EXIST AXIS ID TO MOVE(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::MoveSplineLine(int iMaxPoint, 
						   double* pdPosition, 
						   double* pdVelocity, 
						   int* piAccelerate,
						   BOOL bAutoFlag, 
						   BOOL bWaitOpt)
{
	int iResult = ERR_MOTION_SUCCESS;
	double rgdPos[DEF_SPLINE_MOVE_PATH_MAX_NO];
	double rgdVel[DEF_SPLINE_MOVE_PATH_MAX_NO];
	double dSign;
	double dScale;
	short iAxesID = DEF_AXIS_NON_ID;

	/** 축 관련 오류 점검 */
	iResult = checkAxisExistArgument((void*)pdPosition, (void*)pdVelocity, (void*)piAccelerate, TRUE);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS move Spline Line"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** 사용할 축 추출 */
	iAxesID = m_SaxAxis.iAxisID;
	dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;
	dScale = m_SaxAxis.dScale;

	/** 이동 전 축 Event State 확인 */
	if ((iResult = checkAxisState(m_SaxAxis.iAxisID)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS move Spline Line"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** 이동 Point에 따라 */
	for (int i = 0; i < iMaxPoint; i++)
	{
		/** 위치 정리 */
		rgdPos[i] = dSign * dScale * pdPosition[i];
		rgdVel[i] = dSign * dScale * pdVelocity[i];
	}

	/** 이동 Point에 따라 */
	for (int i = 0; i < iMaxPoint; i++)
	{
		if ((iResult = m_pMotionLib->SplAutoLineMoveNax(1, 
														&iAxesID, 
														&rgdPos[i], 
														rgdVel[i], 
														piAccelerate[i], 
														bAutoFlag)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("AXIS move Spline Line"),3, __FILE__, __LINE__);
			return iResult;
		}
	}

	if (bWaitOpt == TRUE)
	{
		/** Spline Line 이동 완료될 때까지 대기 */
		if ((iResult = m_pMotionLib->WaitForDone(1, &iAxesID)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("AXIS move Spline Line"),3, __FILE__, __LINE__);
			return iResult;
		}
	}
	
	return ERR_MOTION_SUCCESS;
}

/**
 * Jog Slow에 의한 이동한다.
 * 
 * @param   bDir             : 이동할 방향, TRUE:(+), FALSE:(-)
 * @param   dSlow           :(OPTION = 0.0) 이동할 거리, 0.0 = 지정된 Slow거리 사용
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::JogMoveSlow(BOOL bDir, double dSlow)
{
	int iResult = ERR_MOTION_SUCCESS;
	double dJogSlow = 0.0;
	double dVel;
	double dSign;
	double dPosDest;
	double dCurPos;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS move by Jog Slow"),3, __FILE__, __LINE__);
		return iResult;
	}

	dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;

	/** Jog Slow 처리 */
	if (dSlow == 0.0)
		dJogSlow = dSign * m_SaxAxis.dScale * m_AxisParameter.dJogSlow;
	else
		dJogSlow = dSign * m_SaxAxis.dScale * dSlow;

	if (bDir == FALSE)
		dJogSlow *= (-1.0);

	dVel = dSign * m_SaxAxis.dScale * m_AxisParameter.dRunVelocity;

	/** SW Limit Check */
	dCurPos = GetCurrentPosition(FALSE);
	dPosDest = dCurPos + dJogSlow / dSign / m_SaxAxis.dScale;

	if ((iResult = m_pMotionLib->VMove(m_SaxAxis.iAxisID, 
		                               dJogSlow,
									   m_AxisParameter.iRunAccelerate)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS move by Jog Slow"),3, __FILE__, __LINE__);
		return iResult;
	}

	if (GetAmpFault())
	{
		VStop();
		//WriteErrorLog("checkAxisState() : Amp Fault");
		SetErrorLevel(_T("AXIS move by Jog Slow"),3, __FILE__, __LINE__);
		return generateErrorCode(105008);
	}

	if ((iResult = CheckAxisStateForJog(bDir)) != ERR_MOTION_SUCCESS)
	{
		VStop();
		SetErrorLevel(_T("AXIS move by Jog Slow"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}

/**
 * Jog Fast에 의한 이동한다.
 * 
 * @param   bDir             : 이동할 방향, TRUE:(+), FALSE:(-)
 * @param   dFast        :(OPTION = 0.0) 이동할 속도, 0.0 = 지정된 속도 사용
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::JogMoveFast(BOOL bDir, double dFast)
{
	int iResult = ERR_MOTION_SUCCESS;
	double dJogVel = 0.0;
	double dSign;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS move by Jog Fast"),3, __FILE__, __LINE__);
		return iResult;
	}

	dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;

	/** Jog Fast 처리 */
	if (dFast == 0.0)
		dJogVel = dSign * m_SaxAxis.dScale * m_AxisParameter.dJogFast;
	else
		dJogVel = dSign * m_SaxAxis.dScale * dFast;

	if (bDir == FALSE)
		dJogVel *= (-1.0);

	/** V Move 사용 */
	if ((iResult = m_pMotionLib->VMove(m_SaxAxis.iAxisID, 
									   dJogVel,
									   m_AxisParameter.iRunAccelerate)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS move by Jog Fast"),3, __FILE__, __LINE__);
		return iResult;
	}

	if (GetAmpFault())
	{
		VStop();
		//WriteErrorLog("checkAxisState() : Amp Fault");
		SetErrorLevel(_T("AXIS move by Jog Fast"),3, __FILE__, __LINE__);
		return generateErrorCode(105008);
	}

	if ((iResult = CheckAxisStateForJog(bDir)) != ERR_MOTION_SUCCESS)
	{
		VStop();
		SetErrorLevel(_T("AXIS move by Jog Fast"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축을 정지한다.(한개의 축에 대한 정지)
 * 
 * @param   *pbStatus      :(OPTION = NULL) 축의 Stop 상태
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::Stop(BOOL* pbStatus)
{
	/** 축 관련 오류 점검 */
	int iResult = checkAxisExistArgument(TRUE);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS stop"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** STOP */
	if ((iResult = m_pMotionLib->SetStop(m_SaxAxis.iAxisID, DEF_STOP)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS stop"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** 결과 기록 */
	if (pbStatus != NULL)
		*pbStatus = TRUE;
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축을 등속이동에 대해 정지한다.(한개의 축의 등속이동에 대한 정지)
 * 
 * @param   *pbState         :(OPTION = NULL) 축의 VStop 상태
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::VStop(BOOL* pbStatus)
{
	/** 축 관련 오류 점검 */
	int iResult = checkAxisExistArgument(TRUE);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS stop in Uniform Velocity Move"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** V-STOP */
	if ((iResult = m_pMotionLib->SetStop(m_SaxAxis.iAxisID, DEF_VSTOP)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS stop in Uniform Velocity Move"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** VStop 후 안정화 시간 적용 - 2004.9.12 반용석K */
	Sleep((ULONG)(m_AxisParameter.dStabilityTime));

	/** 결과 기록 */
	if (pbStatus != NULL)
		*pbStatus = TRUE;
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축을 비상정지한다.(한개의 축에 대한 비상정지)
 * 
 * @param   *pbStatus        :(OPTION = NULL) 축의 EStop 상태
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::EStop(BOOL* pbStatus)
{
	/** 축 관련 오류 점검 */
	int iResult = checkAxisExistArgument(TRUE);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Emergency stop"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** E-STOP */
	if ((iResult = m_pMotionLib->SetStop(m_SaxAxis.iAxisID, DEF_ESTOP)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Emergency stop"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** 결과 기록 */
	if (pbStatus != NULL)
		*pbStatus = TRUE;
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 Servo를 On 한다.(한개의 축에 대한 Servo On 수행)
 * 
 * @param   *pbStatus        :(OPTION = NULL) 축의 Servo ON 상태
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::ServoOn(BOOL* pbStatus, BOOL bIsCheck)
{
	/** 축 관련 오류 점검 */
	int iResult = checkAxisExistArgument(TRUE);
	if (iResult != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo on"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** AMP Disable */
	if ((iResult = m_pMotionLib->SetAmpEnable(m_SaxAxis.iAxisID, FALSE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo on"),3, __FILE__, __LINE__);
		return iResult;
	}

	Sleep(10);
	
	/** AMP Fault Reset */
	if ((iResult = ResetAmpFault()) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo on"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	Sleep(10);
	
	/** AMP Fault Set */
	if ((iResult = m_pMotionLib->SetAmpFaultEnable(m_SaxAxis.iAxisID, TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo on"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	Sleep(10);

	//-> Home Sensor NO-EVENT로 설정(2004.11.13 pys)
	/** Home Sensor NO-EVENT */
	if ((iResult = m_pMotionLib->SetSensorEvent(m_SaxAxis.iAxisID, 
		                                        DEF_HOME_SENSOR, DEF_NO_EVENT)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo on"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** Status Clear */
	if ((iResult = m_pMotionLib->ClearStatus(m_SaxAxis.iAxisID)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo on"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	Sleep(10);
	
	/** Frame Clear */
	if ((iResult = m_pMotionLib->ClearFrames(m_SaxAxis.iAxisID)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo on"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	Sleep(10);
	
	/** AMP Enable */
	if ((iResult = m_pMotionLib->SetAmpEnable(m_SaxAxis.iAxisID, TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo on"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	Sleep(500);	// ServoOn 후 최소 500msec의 지연 후 실행해야 다음 명령이 적용됨(2004.9.12)

	BOOL bEnable = DEF_DISABLE;

	/** AMP Enable 상태 읽기 */
	if ((iResult = m_pMotionLib->GetAmpEnable(m_SaxAxis.iAxisID, &bEnable)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo on"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** 결과 기록 */
	if (pbStatus != NULL)
		*pbStatus = bEnable;
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 Servo를 Off 한다.(한개의 축에 대한 Servo Off 수행)
 * 
 * @param   *pbStatus        :(OPTION = NULL) 축의 Servo OFF 상태
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::ServoOff(BOOL* pbStatus,  BOOL bIsCheck)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo off"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** AMP Disable */
	if ((iResult = m_pMotionLib->SetAmpEnable(m_SaxAxis.iAxisID, FALSE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo off"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** 원점복귀 Flag Reest */
	ResetOrigin();

	Sleep(10);
	/** AMP Fault Reset */
	if ((iResult = ResetAmpFault()) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo off"),3, __FILE__, __LINE__);
		return iResult;
	}
	Sleep(10);
	/** AMP Fault Set */
	if ((iResult = m_pMotionLib->SetAmpFaultEnable(m_SaxAxis.iAxisID, TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo off"),3, __FILE__, __LINE__);
		return iResult;
	}
	Sleep(10);
	/** Frame Clear */
	if ((iResult = m_pMotionLib->ClearFrames(m_SaxAxis.iAxisID)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo off"),3, __FILE__, __LINE__);
		return iResult;
	}
	Sleep(10);
	/** Status Clear */
	if ((iResult = m_pMotionLib->ClearStatus(m_SaxAxis.iAxisID)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo off"),3, __FILE__, __LINE__);
		return iResult;
	}

	BOOL bEnable = DEF_DISABLE;

	if ((iResult = m_pMotionLib->GetAmpEnable(m_SaxAxis.iAxisID, &bEnable)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS Servo off"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** 결과 기록 */
	if (pbStatus != NULL)
		*pbStatus = bEnable;
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 Home Sensor 상태를 읽는다.(한개의 축에 대한 상태읽기)
 * 
 * @return   BOOL        : 축의 Home Sensor 상태 
 */
BOOL MAxis::CheckHomeSensor()
{
	ASSERT(m_pMotionLib != NULL);

	BOOL bStatus = FALSE;

	/** Home Sensor 상태 읽기 */
	m_pMotionLib->GetSensorStatus(m_SaxAxis.iAxisID, DEF_HOME_SENSOR, &bStatus);

	return bStatus;	
}

/**
 * 축의 Positive Sensor 상태를 읽는다.(한개의 축에 대한 상태읽기)
 * 
 * @return   BOOL        : 축의 Positive Sensor 상태 
 */
BOOL MAxis::CheckPositiveSensor()
{
	ASSERT(m_pMotionLib != NULL);

	BOOL bStatus = FALSE;

	/** Positive Sensor 상태 읽기 */
	m_pMotionLib->GetSensorStatus(m_SaxAxis.iAxisID, DEF_POSITIVE_SENSOR, &bStatus);

	return bStatus;	
}

/**
 * 축의 Negative Sensor 상태를 읽는다.(한개의 축에 대한 상태읽기)
 * 
 * @return   BOOL        : 축의 Negative Sensor 상태 
 */
BOOL MAxis::CheckNegativeSensor()
{	
	ASSERT(m_pMotionLib != NULL);

	BOOL bStatus = FALSE;

	m_pMotionLib->GetSensorStatus(m_SaxAxis.iAxisID, DEF_NEGATIVE_SENSOR, &bStatus);
	
	return bStatus;
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 Home Sensor에 대한 Event를 설정한다.(한개의 축에 대한 상태 설정)
 * 
 * @param	iLimit           : 동작할 Event(0=NO EVENT, 1=STOP EVENT, 2=ESTOP EVENT, 3=ABORT EVENT)
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::SetHomeSensorEvent(int iLimit)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Home Sensor Event"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** Home Sensor Event/Level 설정하기 */
	if ((iResult = m_pMotionLib->SetSensorEvent(m_SaxAxis.iAxisID, DEF_HOME_SENSOR, 
		                                      (short)iLimit)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Home Sensor Event"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 Home Sensor에 대한 Level을 설정한다.(한개의 축에 대한 상태 설정)
 * 
 * @param	bLevel           : 신호 Level(TRUE=HIGH, FLASE=LOW)
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::SetHomeSensorLevel(BOOL bLevel)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Home Sensor Level"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** Home Sensor Event/Level 설정하기 */
	if ((iResult = m_pMotionLib->SetSensorLevel(m_SaxAxis.iAxisID, 
		                                        DEF_HOME_SENSOR, bLevel)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Home Sensor Level"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 Positive Sensor에 대한 Event를 설정한다.(한개의 축에 대한 상태읽기)
 * 
 * @param	iLimit           : 동작할 Event(0=NO EVENT, 1=STOP EVENT, 2=ESTOP EVENT, 3=ABORT EVENT)
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::SetPositiveSensorEvent(int iLimit)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Positive Sensor Event"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** Home Sensor Event/Level 설정하기 */
	if ((iResult = m_pMotionLib->SetSensorEvent(m_SaxAxis.iAxisID, 
		                                        DEF_POSITIVE_SENSOR, 
												(short)iLimit)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Positive Sensor Event"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 Positive Sensor에 대한 Limit를 설정한다.(한개의 축에 대한 상태읽기)
 * 
 * @param	bLevel           : 신호 Level(TRUE=HIGH, FLASE=LOW)
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::SetPositiveSensorLevel(BOOL bLevel)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Positive Sensor Limit"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** Home Sensor Event/Level 설정하기 */
	if ((iResult = m_pMotionLib->SetSensorLevel(m_SaxAxis.iAxisID, 
		                                        DEF_POSITIVE_SENSOR, 
												bLevel)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Positive Sensor Limit"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 Negative Sensor에 대한 Event 설정한다.(한개의 축에 대한 상태읽기)
 * 
 * @param	iLimit           : 동작할 Event(0=NO EVENT, 1=STOP EVENT, 2=ESTOP EVENT, 3=ABORT EVENT)
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::SetNegativeSensorEvent(int iLimit)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Negative Sensor Event"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** Home Sensor Event/Level 설정하기 */
	if ((iResult = m_pMotionLib->SetSensorEvent(m_SaxAxis.iAxisID, 
		                                        DEF_NEGATIVE_SENSOR, 
												(short)iLimit)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Negative Sensor Event"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 Negative Sensor에 대한 Level를 설정한다.(한개의 축에 대한 상태읽기)
 * 
 * @param	bLevel           : 신호 Level(TRUE=HIGH, FLASE=LOW)
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::SetNegativeSensorLevel(BOOL bLevel)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Negative Sensor Level"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** Home Sensor Event/Level 설정하기 */
	if ((iResult = m_pMotionLib->SetSensorLevel(m_SaxAxis.iAxisID, 
												DEF_NEGATIVE_SENSOR, 
												bLevel)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Negative Sensor Level"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 상태(Source)를 읽는다. 
 * 
 * @return   int        : 축 하나에 대한 상태(Source) 
 */
int MAxis::GetAxisSource()
{	
	short siSource;

	/** 축 Source 상태 읽기 */
	m_pMotionLib->GetAxisSource(m_SaxAxis.iAxisID, &siSource);
	
	return siSource;
}

/**
 * 축의 상태(State)를 읽는다. 
 * 
 * @return   int        : 축 하나에 대한 상태(State) 
 */
int MAxis::GetAxisState(int* piReturn)
{
	short siState;	
	/** 축 Source 상태 읽기 */
	int iResult = m_pMotionLib->GetAxisState(m_SaxAxis.iAxisID, &siState);
	if (iResult)
		return iResult;
	
	*piReturn = (int)siState;
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 AMP Enable 상태를 읽는다. 
 * 
 * @param   BOOL        : 축 하나에 대한 AMP상태(AMP Enable : TRUE, 그외 : FALSE) 
 */
BOOL MAxis::GetAmpEnable()
{	
	BOOL bStatus = FALSE;
	
	/** AMP Enable 상태 읽기 */
	m_pMotionLib->GetAmpEnable(m_SaxAxis.iAxisID, &bStatus);
	
	return bStatus;
}

/**
 * 축의 AMP Enable/Disable 상태로 만든다.
 * 
 * @param   bEnable          : AMP Enable 상태로 변경 : TRUE
 *							   AMP Disable 상태로 변경 : FALSE
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::SetAmpEnable(BOOL bEnable)
{
	int iResult = ERR_MOTION_SUCCESS;
	
	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Amp Enable"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** AMP Fault 상태 변경 */
	if ((iResult = m_pMotionLib->SetAmpEnable(m_SaxAxis.iAxisID, bEnable)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Amp Enable"),3, __FILE__, __LINE__);
		return iResult;
	}

	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 AMP Fault 상태를 읽는다. 
 * 
 * @return   BOOL         : 축에 대한 AMP Fault상태(AMP Fault:TRUE, Fault아니면:FALSE)
 */
BOOL MAxis::GetAmpFault()
{
	BOOL bStatus;

	/** AMP Fault 상태 읽기 */
	m_pMotionLib->GetAmpFaultStatus(m_SaxAxis.iAxisID, &bStatus);
	return bStatus;
}

/**
 * 축의 AMP Fault 상태를 Reset 한다.(정헌식 : 2005.01.11)
 * 
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::ResetAmpFault(BOOL bIsCheck)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS reset Amp Fault State"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** AMP Fault 상태 설정 */
	if ((iResult = m_pMotionLib->SetAmpFaultEnable(m_SaxAxis.iAxisID, FALSE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS reset Amp Fault State"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 AMP Fault 상태를 Clear/Enable 한다. 
 * 
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::SetAmpFaultEnable()
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Amp Fault Enable"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** AMP Fault 상태 설정 */
	if ((iResult = m_pMotionLib->SetAmpFaultEnable(m_SaxAxis.iAxisID, TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS set Amp Fault Enable"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}
/**
 * 원점 복귀 시 Encoder의 C상 펄스 이용 여부를 읽는다.
 *
 * @param	*pbIndexReq		: C상 펄스 사용 여부, TRUE =Home Sensor와 Encoder의 Index Pulse를 동시 검출,
 *												  FALSE=Home Sensor만 검출
 * @return	Origin Step		: 1000 = ORIGIN RETURN SUCCESS
 *							  990 = ERROR
 *							  xx = 원점 복귀 중...
 */
int MAxis::GetIndexRequired(BOOL* pbIndexReq)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument((void*)pbIndexReq, TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS get Required Index"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** 축 상태 초기화 */
	if ((iResult = m_pMotionLib->GetIndexRequired(m_SaxAxis.iAxisID,
												  pbIndexReq)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS get Required Index"),3, __FILE__, __LINE__);
		return iResult;
	}
	
	return ERR_MOTION_SUCCESS;
}
/**
 * 원점 복귀 시 Encoder의 C상 펄스 이용 여부를 설정한다.
 *
 * @param	bIndexReq		: C상 펄스 사용 여부, TRUE =Home Sensor와 Encoder의 Index Pulse를 동시 검출,
 *												  FALSE=Home Sensor만 검출
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::SetIndexRequired(BOOL bIndexReq)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** 축 상태 초기화 */
	if ((iResult = m_pMotionLib->SetIndexRequired(m_SaxAxis.iAxisID, 
												  bIndexReq)) != ERR_MOTION_SUCCESS)
		return iResult;
	
	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 상태를 초기화 한다.(한개의 축에 대해 초기화)
 *  Clear Status & Clear Frames
 * 
 * @param   *pbStatus        :(OPTION = NULL) 축의 초기화 상태
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::ClearAxis(BOOL* pbStatus)
{
#ifdef SIMULATION
	if (NULL != pbStatus)
		*pbStatus = TRUE;

	return ERR_MOTION_SUCCESS;
#endif

	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS reset One Axis"),3, __FILE__, __LINE__);
		return iResult;
	}

	/** 축 상태 초기화 */
	if ((iResult = m_pMotionLib->ClearStatus(m_SaxAxis.iAxisID)) != ERR_MOTION_SUCCESS)
	{
		/** 결과 기록 */
		if (pbStatus != NULL)
			*pbStatus = FALSE;

		return iResult;
	}

	/** 축 Frame 초기화 */
	if ((iResult = m_pMotionLib->ClearFrames(m_SaxAxis.iAxisID)) != ERR_MOTION_SUCCESS)
	{
		/** 결과 기록 */
		if (pbStatus != NULL)
			*pbStatus = FALSE;

		SetErrorLevel(_T("AXIS reset One Axis"),3, __FILE__, __LINE__);

		return iResult;
	}

	/** 결과 기록 */
	if (pbStatus != NULL)
		*pbStatus = TRUE;
	
	return ERR_MOTION_SUCCESS;
}

/** 
 * 원점복귀 우선 순위를 Return 한다.
 *
 * @return	우선 순위		: 0~63
 */
int MAxis::GetOriginPriority()
{
	return m_SaxAxis.iOriginPriority;
}

/** 
 * 원점복귀 동작 수행 함수(한번 호출에 한 Step씩 수행)
 * 원점 복귀 Step이 완료 Step이 될 때 까지 계속 호출 해야함
 *
 * @param   iOriginMoveType :	DEF_ORIGIN_RETURN_NONE_MOVE (0) -> Motion 동작 없이 현재 위치를 원점으로 설정하는 경우.
 *								DEF_ORIGIN_RETURN_ALL_MOVE	(1) -> 원점 복귀 Offset 이동 동작을 포함한 모든 원점 복귀 관련 Motion 동작을 수행하는 경우.
 *								DEF_ORIGIN_RETURN_EXCEPT_ORIGIN_OFFSET_MOVE	(2) -> 원점 복귀 Offset 이동 동작을 제외한 원점 복귀 관련 Motion 동작을 수행하는 경우.
 * @return	OriginStep
 */
int MAxis::OriginReturn(int iOriginMoveType)
{
#ifdef SIMULATION
	m_bOriginFlag = TRUE;
	m_iOriginStep = 1000;

	m_dCurrentAxisPos = 0.0;
	m_dTargetAxisPos = 0.0;
	m_dRMoveDistance = 0.0;
	m_bRMoveStart = FALSE;
	return m_iOriginStep;
#endif

	int iResult = 0;
	short siAxisState;
	short siAxisSource;
	short siEncoderType;
	double dEncoderValue;
	double dSign;
	double dPos;
	double dVel;
	short iAccel;
	short iDecel;

	switch (m_iOriginStep)
	{
	case 100:
		m_iOriginError = 0;
		/**ResetOrigin */
		m_bOriginFlag = FALSE;

		iResult = SetPositiveSensorEvent(DEF_NO_EVENT);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		iResult = SetNegativeSensorEvent(DEF_NO_EVENT);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}

		SetOriginStep(110);
		break;
	case 110:
		/**AmpDisable */
		iResult = SetAmpEnable(DEF_DISABLE);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(120);
		m_ttOriginTimer.StartTimer();
		break;
	case 120:
		if (m_ttOriginTimer.MoreThan(0.5))
			SetOriginStep(130);
		break;
	case 130:
		iResult = ClearAxis();
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(140);
		m_ttOriginTimer.StartTimer();
		break;
	case 140:
		if (m_ttOriginTimer.MoreThan(0.5))
			SetOriginStep(150);
		break;
	case 150:
		iResult = ResetAmpFault();
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(160);
		m_ttOriginTimer.StartTimer();
		break;
	case 160:
		if (m_ttOriginTimer.MoreThan(0.5))
			SetOriginStep(170);
		break;
	case 170:
		iResult = SetAmpFaultEnable();
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(180);
		m_ttOriginTimer.StartTimer();
		break;
	case 180:
		if (m_ttOriginTimer.MoreThan(0.1))
			SetOriginStep(190);
		break;
	case 190:
		iResult = m_pMotionLib->SetPosition(m_SaxAxis.iAxisID, DEF_CURRENT_VAL, 0.0);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}

		if (IsAbsEncoder()) // Abs Encoder일 경우 
		{
			iResult = m_pMotionLib->GetAbsEncoderType(m_SaxAxis.iAxisID, &siEncoderType);
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}

			if (siEncoderType == DEF_YASKAWA_S3_SERVO_DRIVE)
			{
				iResult = m_pMotionLib->SetAbsEncoderType(m_SaxAxis.iAxisID, siEncoderType);// 야스까와 type==22
				if (iResult != ERR_MOTION_SUCCESS)
				{
					m_iOriginError = iResult;
					SetOriginStep(998);
					break;
				}

				iResult = m_pMotionLib->SetAbsEncoder(m_SaxAxis.iAxisID);	
				if (iResult != ERR_MOTION_SUCCESS)
				{
					m_iOriginError = iResult;
					SetOriginStep(998);
					break;
				}

				iResult = m_pMotionLib->GetAxisSource(m_SaxAxis.iAxisID, &siAxisSource);
				if (iResult != ERR_MOTION_SUCCESS)
				{
					m_iOriginError = iResult;
					SetOriginStep(998);
					break;
				}

				if ((siAxisSource&0x1000)!=0)
				{
					/** 절대 모터 Encoder값을 읽어오는데 실패 하였습니다. */
					SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
					m_iOriginError = generateErrorCode(106120);
					SetOriginStep(998);
					break;
				}
				
				Sleep(1000);// for 1회전데이타 받는 시간, 가장 중요한 시간임.

				iResult = m_pMotionLib->GetPosition(m_SaxAxis.iAxisID, FALSE, &dEncoderValue);
				if (iResult != ERR_MOTION_SUCCESS)
				{
					m_iOriginError = iResult;
					SetOriginStep(998);
					break;
				}

				dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;
			
				dEncoderValue -= dSign*GetHomeOffset()*GetScale();
 
				iResult = m_pMotionLib->SetPosition(m_SaxAxis.iAxisID, FALSE, dEncoderValue);
				if (iResult != ERR_MOTION_SUCCESS)
				{
					m_iOriginError = iResult;
					SetOriginStep(998);
					break;
				}

				iResult = m_pMotionLib->SetPosition(m_SaxAxis.iAxisID, TRUE, dEncoderValue);
				if (iResult != ERR_MOTION_SUCCESS)
				{
					m_iOriginError = iResult;
					SetOriginStep(998);
					break;
				}
			}
			else
			{
				/** 타 모터의 경우는 구현 필요. */
				SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
				m_iOriginError = generateErrorCode(106113);//절대 모터 종류가 이상합니다.
				SetOriginStep(998);
			}
		}
		
		SetOriginStep(200);
		break;
	case 200:
		iResult = SetAmpEnable(DEF_ENABLE);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(210);
		m_ttOriginTimer.StartTimer();
		break;
	case 210:
		if (m_ttOriginTimer.MoreThan(0.1))
			SetOriginStep(220);
		break;
	case 220:
		iResult = SetIndexRequired(FALSE);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		
		/** Home Sensor E-STOP EVENT 설정 */
		iResult = SetHomeSensorEvent(DEF_E_STOP_EVENT);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		/** Positive Sensor E-STOP EVENT 설정 */
		iResult = SetPositiveSensorEvent(DEF_E_STOP_EVENT);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			// set_home() 함수 설정 이상.
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		/** Negative Sensor E-STOP EVENT 설정 */
		iResult = SetNegativeSensorEvent(DEF_E_STOP_EVENT);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			// set_home() 함수 설정 이상.
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(230);
		break;
	case 230:
		iResult = ClearAxis();
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(240);
		m_ttOriginTimer.StartTimer();
		break;
	case 240:
		if (m_ttOriginTimer.MoreThan(0.2))
			SetOriginStep(250);
		break;
	case 250: // 현재위치에서 원점복귀완료시
		if (IsAbsEncoder()) // Abs Encoder일 경우 
		{
			m_bOriginFlag = TRUE;
			SetOriginStep(260);
			break;
		}
		else if (DEF_ORIGIN_RETURN_NONE_MOVE == iOriginMoveType)	// Motor 구동 없이 원점 복귀시... 예를 들면 Feeder 축....
		{
			/** Motor의 현좌표를 원점으로 재설정 */
			m_bOriginFlag = TRUE;
			iResult = m_pMotionLib->SetPosition(m_SaxAxis.iAxisID, DEF_CURRENT_VAL, 0.0);
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
			SetOriginStep(260);
			break;
		}
		SetOriginStep(300);
		break;

	case 260:// Sensor Event 초기화
		iResult = SetIndexRequired(FALSE);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		
		/** Home Sensor E-STOP EVENT 설정 */
		iResult = SetHomeSensorEvent(DEF_NO_EVENT);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		/** Positive Sensor E-STOP EVENT 설정 */
		iResult = SetPositiveSensorEvent(DEF_NO_EVENT);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			/** set_home() 함수 설정 이상. */
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		/** Negative Sensor E-STOP EVENT 설정 */
		iResult = SetNegativeSensorEvent(DEF_NO_EVENT);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			/** set_home() 함수 설정 이상. */
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(1000);
		break;

	case 300:// Coarse Motion Speed로 Motor 정회전
		iResult = VMove(m_AxisParameter.dHomeFastVelocity, 
					    m_AxisParameter.iHomeAccelerate,
						m_SaxAxis.bOriginDir); 
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(310);
		m_ttOriginTimer.StartTimer();
		break;
	case 310: // E_STOP_EVENT가 발생될 때까지 기다린다.
		if (IsAxisDone())
		{
			iResult = m_pMotionLib->GetAxisState(m_SaxAxis.iAxisID, &siAxisState);
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
			if (siAxisState != DEF_E_STOP_EVENT)
			{
				/** Event가 발생된 상태가 아닙니다.*/
				SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
				m_iOriginError = generateErrorCode(105058);
				SetOriginStep(998);
			}
			SetOriginStep(320);
			break;
		}
		else if (m_ttOriginTimer.MoreThan(m_AxisParameter.dOriginLimitTime))
		{
			/** 원점복귀 제한 시간을 초과하였습니다. */
			SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
			m_iOriginError = generateErrorCode(105053);
			SetOriginStep(998);
			break;
		}
		break;
	case 320:
		iResult = m_pMotionLib->GetAxisSource(m_SaxAxis.iAxisID, &siAxisSource);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}

		if (siAxisSource & DEF_ST_POS_LIMIT) 
		{
			iResult = SetPositiveSensorEvent(DEF_NO_EVENT);
			if (iResult != ERR_MOTION_SUCCESS)
			{
				/** set_positive_limit() 함수 설정 이상.*/
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
		}
		else if (siAxisSource & DEF_ST_NEG_LIMIT)
		{
			iResult = SetNegativeSensorEvent(DEF_NO_EVENT);
			if (iResult != ERR_MOTION_SUCCESS)
			{
				/** set_negative_limit() 함수 설정 이상.*/
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
		}
		iResult = ClearAxis();
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(330);
		m_ttOriginTimer.StartTimer();
		break;
	case 330:
		if (m_ttOriginTimer.MoreThan(0.1))
			SetOriginStep(340);
		break;
	case 340:// Coarse Motion Speed로 Motor 역회전
		iResult = VMove(m_AxisParameter.dHomeFastVelocity, 
					    m_AxisParameter.iHomeAccelerate,
						!m_SaxAxis.bOriginDir); 
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(350);
		m_ttOriginTimer.StartTimer();
		break;
	case 350: // E_STOP_EVENT가 발생될 때까지 기다린다.
#ifdef SIMULATION
		SetOriginStep(360);
#endif
		if (IsAxisDone())
		{
			iResult = m_pMotionLib->GetAxisState(m_SaxAxis.iAxisID, &siAxisState);
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
			if (siAxisState != DEF_E_STOP_EVENT)			
			{
				/** Event가 발생된 상태가 아닙니다. */
				SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
				m_iOriginError = generateErrorCode(105058);
				SetOriginStep(998);
			}
			SetOriginStep(360);
			break;
		}
		else if (m_ttOriginTimer.MoreThan(m_AxisParameter.dOriginLimitTime))
		{
			/**원점복귀 제한 시간을 초과하였습니다. */
			SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
			m_iOriginError = generateErrorCode(105053);
			SetOriginStep(998);
			break;
		}
		break;
	case 360: // 원점 센서가 감지되었는지 확인한다.		
		iResult = m_pMotionLib->GetAxisSource(m_SaxAxis.iAxisID, &siAxisSource);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
#ifndef SIMULATION
		if (!(siAxisSource & DEF_ST_HOME_SWITCH))
		{
			/** 원점복귀 중 Home Sensor 감지위치 이탈 */
			SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
			m_iOriginError = generateErrorCode(105120);
			SetOriginStep(998);
			break;
		}
#endif
		SetOriginStep(370);
		break;
	case 370: // Event 해제(원점 센서가 감지된 상태이다.)
		iResult = SetHomeSensorEvent(DEF_NO_EVENT);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			/**set_home() 함수 설정 이상. */
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		iResult = ClearAxis();
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(380);
		m_ttOriginTimer.StartTimer();
		break;
	case 380:
		if (m_ttOriginTimer.MoreThan(0.1))	
			SetOriginStep(390);
		break;
	case 390:
#ifndef SIMULATION
		if (!CheckHomeSensor()) 
		{
			/**원점복귀 중 Home Sensor 감지위치 이탈 */
			SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
			m_iOriginError = generateErrorCode(105120);
			SetOriginStep(998);
			break;
		}
#endif
		SetOriginStep(500);
		break;
	/** 저속 원점 복귀(기존 OriginReturn2 동작) */
	case 500: // Fine Motion Speed로 Motor 역회전
		iResult = VMove(m_AxisParameter.dHomeSlowVelocity, 
						m_AxisParameter.iHomeAccelerate, 
						m_SaxAxis.bOriginFineDir); 
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(510);
		m_ttOriginTimer.StartTimer();
		break;
	case 510: // 원점 센서 상태가 ON에서 OFF로 변경 ?		
		if (!CheckHomeSensor())
		{
			iResult = VStop();
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
			SetOriginStep(520);
			m_ttOriginTimer.StartTimer();
			break;
		}
		else if (m_ttOriginTimer.MoreThan(m_AxisParameter.dOriginLimitTime))
		{
			SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
			m_iOriginError = generateErrorCode(105053);
			SetOriginStep(998);
			break;
		}
		break;
	case 520:
		if (m_ttOriginTimer.MoreThan(0.6))
		{
			/**  발생된 EVENT를 해제시킨다. */
			iResult = ClearAxis();
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
			SetOriginStep(530);
			m_ttOriginTimer.StartTimer();
			break;
		}
		break;
	case 530: // C상 사용 유무에 따라 Event 설정한다.
		if (m_ttOriginTimer.MoreThan(0.2))
		{
			/** 원점 센서 Active : E_STOP_EVENT */
			iResult = SetHomeSensorEvent(DEF_E_STOP_EVENT);
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
			SetOriginStep(540);
		}
		break;

	case 540:// Fine Motion Speed로 Motor 정회전
		iResult = VMove(m_AxisParameter.dHomeSlowVelocity,
			            m_AxisParameter.iHomeAccelerate, 
						!m_SaxAxis.bOriginFineDir);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(550);
		m_ttOriginTimer.StartTimer();
		break;
	case 550: // E_STOP_EVENT가 발생될 때까지 기다린다.
		if (IsAxisDone())
		{
			iResult = m_pMotionLib->GetAxisState(m_SaxAxis.iAxisID, &siAxisState);
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
#ifndef SIMULATION
			if (siAxisState != DEF_E_STOP_EVENT)
			{
				SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
				m_iOriginError = generateErrorCode(105058);
				SetOriginStep(998);
				break;
			}
#endif
			SetOriginStep(560);
			break;
		}
		else if (m_ttOriginTimer.MoreThan(m_AxisParameter.dOriginLimitTime))
		{
			SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
			m_iOriginError = generateErrorCode(105053);
			SetOriginStep(998);
			break;
		}
		break;
	case 560: // C상 미사용인 경우 원점 센서가 감지되었는지 확인한다.
		if (DEF_USE_SWITCH_ONLY == m_SaxAxis.iCPhaseUseType)
		{
#ifndef SIMULATION
			iResult = m_pMotionLib->GetAxisSource(m_SaxAxis.iAxisID, &siAxisSource);
			if (!(siAxisSource & DEF_ST_HOME_SWITCH))
			{
				SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
				m_iOriginError = generateErrorCode(105120);
				SetOriginStep(998);
				break;
			}
#else
			SetOriginStep(570);
			break;
#endif
		}
		else
		{
#ifndef SIMULATION
			iResult = SetHomeSensorEvent(DEF_NO_EVENT);
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
			}
#endif
			SetOriginStep(561);
			break;
		}

		SetOriginStep(570);
		break;

	case 561: 
		if (m_ttOriginTimer.MoreThan(0.2))
		{
			iResult = ClearAxis();
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
			SetOriginStep(562);
		}
		break;
	case 562: // Event 해제(원점 센서가 감지된 상태이다.)
		/** C상 Pulse Active : E_STOP_EVENT */
		iResult = SetIndexRequired(TRUE);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(563);
		break;
	case 563:// Fine Motion Speed로 Motor 역회전(Z상 원점복귀시 무조건 Sensor 벗어나는 방향)
		iResult = VMove(m_AxisParameter.dHomeSlowVelocity, m_AxisParameter.iHomeAccelerate, m_SaxAxis.bOriginFineDir);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		else SetOriginStep(564);
		m_ttOriginTimer.StartTimer();
		break;
	case 564: // E_STOP_EVENT가 발생될 때까지 기다린다.
#ifdef SIMULATION
		SetOriginStep(570);
#endif
		if (IsAxisDone())
		{
			iResult = m_pMotionLib->GetAxisState(m_SaxAxis.iAxisID, &siAxisState);
			if (siAxisState != DEF_E_STOP_EVENT)
			{
				/** Event가 발생된 상태가 아닙니다. */
				SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
				m_iOriginError = generateErrorCode(105058);
				SetOriginStep(998);
			}
			SetOriginStep(570);
		}
		else if (m_ttOriginTimer.MoreThan(m_AxisParameter.dOriginLimitTime))
		{
			/** 원점복귀 제한 시간을 초과하였습니다.*/
			SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
			m_iOriginError = generateErrorCode(105053);
			SetOriginStep(998);
			break;
		}
		break;
	case 570:
		iResult = SetIndexRequired(FALSE);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
	
		/** Home Sensor는 No Evnet 설정후 원점 Offset 이동후 Event 설정 함 */
		iResult = SetHomeSensorEvent(DEF_NO_EVENT);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		iResult = SetPositiveSensorEvent(DEF_E_STOP_EVENT);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		iResult = SetNegativeSensorEvent(DEF_E_STOP_EVENT);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}

		SetOriginStep(580);
		m_ttOriginTimer.StartTimer();
		break;
	case 580: // 발생된 EVENT를 해제시킨다.
		if (m_ttOriginTimer.MoreThan(0.2))
		{
			iResult = ClearAxis();
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
			else SetOriginStep(590);
			m_ttOriginTimer.StartTimer();
		}
		break;
	case 590:
		if (m_ttOriginTimer.MoreThan(0.2))
		{
			/** Motor의 현좌표를 원점으로 설정 */
			iResult = m_pMotionLib->SetPosition(m_SaxAxis.iAxisID, DEF_CURRENT_VAL, 0.0);
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
			SetOriginStep(595);
			m_ttOriginTimer.StartTimer();
		}
		break;
	case 595:
		if (m_ttOriginTimer.MoreThan(0.2)) 
			SetOriginStep(600);
		break;
	case 600:// Moving Speed로 원점 Offset 만큼 이동

		if (DEF_ORIGIN_RETURN_EXCEPT_ORIGIN_OFFSET_MOVE == iOriginMoveType)
		{
			// 원점 복귀 Offset 만큼 이동하는 동작 Skip!
			SetOriginStep(630);
			break;
		}

		dSign	= (m_SaxAxis.bSign) ? 1.0 : -1.0;
		dPos	= dSign * m_SaxAxis.dScale * m_AxisParameter.dHomeOffset;
		dVel	= dSign * m_SaxAxis.dScale * m_AxisParameter.dRunVelocity / 3.0;
		iAccel	= m_AxisParameter.iRunAccelerate;
		iDecel	= m_AxisParameter.iRunAccelerate;

		iResult = m_pMotionLib->Move(m_SaxAxis.iAxisID, dPos, dVel,
									iAccel, iDecel, DEF_MOVE_POSITION);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(605);
		m_ttOriginTimer.StartTimer();
		break;

	case 605:	// 축 동작 완료 대기
		if (TRUE == IsAxisDone())
		{
#ifndef SIMULATION	
			m_pMotionLib->GetAxisState(m_SaxAxis.iAxisID, &siAxisState);
			if (siAxisState == DEF_E_STOP_EVENT)
			{
				/** Event가 발생된 상태 입니다. */
				SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
				m_iOriginError = generateErrorCode(105058);
				SetOriginStep(998);
				break;
			}
#endif
			SetOriginStep(610);
			m_ttOriginTimer.StartTimer();
			break;			
		}	

		if (m_ttOriginTimer.MoreThan(m_AxisParameter.dOriginLimitTime))
		{
			/** 원점복귀 이동시간을 초과했습니다. */
			SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
			m_iOriginError = generateErrorCode(105053);
			EStop();
			SetOriginStep(998);
			break;
		}
		break;

	case 610:
		if (m_ttOriginTimer.MoreThan(0.5))
			SetOriginStep(620);
		break;

	case 620: // Motor의 현좌표를 원점으로 재설정
		iResult = m_pMotionLib->SetPosition(m_SaxAxis.iAxisID, DEF_CURRENT_VAL, 0.0);
		if (iResult != ERR_MOTION_SUCCESS)
		{
			m_iOriginError = iResult;
			SetOriginStep(998);
			break;
		}
		SetOriginStep(630);
		break;

	case 630:
		/**Home Sensor가 Home_n_None가 아닐때는 E Stop Event를 설정 한다
		 *Positive, Negative Limit은 Step 570에서 Evnet를 설정 한다.
		 */
		if (m_SaxAxis.iRoleOfHome != HOME_N_NONE)
		{			
			iResult = SetHomeSensorEvent(DEF_E_STOP_EVENT);
			if (iResult != ERR_MOTION_SUCCESS)
			{
				m_iOriginError = iResult;
				SetOriginStep(998);
				break;
			}
		}
		m_ttOriginTimer.StartTimer();
		SetOriginStep(650);
		break;

	case 650: // Origin Flag 설정
		//Set Origin Flag
		m_bOriginFlag = TRUE;
		SetOriginStep(1000);
		break;

	case 998:
		m_bOriginFlag = FALSE;
		SetPositiveSensorEvent(DEF_E_STOP_EVENT);
		SetNegativeSensorEvent(DEF_E_STOP_EVENT);

		EStop();
		Sleep(50);
		SetOriginStep(999);
		break;
	case 999:
		break;
	case 1000:
		break;
	default:
		SetErrorLevel(_T("AXIS return Origin"),3, __FILE__, __LINE__);
		m_iOriginError = generateErrorCode(105051);
		SetOriginStep(998);
		break;
	}
	return m_iOriginStep;
}

/**
 * 원점복귀 Step을 설정한다.(한개의 축)
 * 
 * @param   iStep            : 설정값(0:시작, 999:오류, 1000:완료, 그외:동작중)
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = INVALID ORIGIN STEP(<0)(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::SetOriginStep(int iStep)
{
	m_iOriginPrevStep = m_iOriginStep;
	m_iOriginStep = iStep;

	return ERR_MOTION_SUCCESS;
}

/**
 * 원점복귀 Step을 읽는다.(한개의 축)
 * 
 * @return	Origin Step
 */
int MAxis::GetOriginStep()
{
	return m_iOriginStep;
}

/**
 * 원점복귀 Error를 초기화한다.(한개의 축)
 * 
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::ClearOriginError()
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument(TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS clear Origin Return Error"),3, __FILE__, __LINE__);
		return iResult;
	}

	m_iOriginError = ERR_MOTION_SUCCESS;

	return ERR_MOTION_SUCCESS;
}

/**
 * 원점복귀 Error를 읽는다.(한개의 축)
 * 
 * @param   *piError         : 발생한 오류 Code
 * @return	Error Code		 : 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::GetOriginError(int* piError)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 축 관련 오류 점검 */
	if ((iResult = checkAxisExistArgument((void*)piError, TRUE)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS read Origin Return Error"),3, __FILE__, __LINE__);
		return iResult;
	}

	*piError = m_iOriginError;

	return ERR_MOTION_SUCCESS;
}

/**
 * Home Sensor의 역할을 반환 한다.
 *  	 
 * @return	ERoleOfHome		HOME_N_NONE : Home Sensor 역할
 *							HOME_N_POSITIVE_LIMIT : Home, Positive Sensor 역할
 *							HOME_N_NEGATIVE_LIMIT : Home, Negative Sensor 역할
 */
ERoleOfHome MAxis::GetRoleOfHomeSensor()
{
	return m_SaxAxis.iRoleOfHome;
}


/**
 * SAxis1 Data에 대한 오류 점검과 개체 복사를 수행한다.
 *
 * @param	srcAx			: 오류 점검할 원본 Data
 * @param	*pdstAx			:(OPTION=NULL) 복사본 Data
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID(MULTIAXES)
 *							  xx = INVALID MOTION AXIS ID(MULTIAXES)
 *							  xx = INVALID MOVE-PRIORITY NUMBER(MULTIAXES)
 *							  xx = INVALID ORIGIN-PRIORITY NUMBER(MULTIAXES)
 */
int MAxis::checkAxisParameter(SAxis1 srcAx)
{
	CString strLogMsg;

	/** 축 ID 범위 점검 */
	if ((srcAx.iAxisID < DEF_AXIS_NON_ID) || (srcAx.iAxisID >(DEF_MAX_AXIS_NO - 1)))
	{
		//strLogMsg.Format(_T("checkAxisParameter() : Invalid Axis ID Arguement %d "), srcAx.iAxisID);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("AXIS check Parameter (Axis ID %d)"), srcAx.iAxisID);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(105034);	// ERR_MAXES_INVALID_AXIS_ID
	}

	return ERR_MOTION_SUCCESS;
}
/** 
 * 축 구성에 대한 오류를 점검한다.(포인터 인수 없음)
 *  1. Motion Library 개체 생성 여부
 *  2. 축 ID가 정상범위를 벗어난 경우
 *  축이 구성되어있어야하는 경우
 *    3. 설정된 축이 없는 경우
 *    4. 축 ID가 구성된 축의 범위를 벗어난 경우
 *    5. 설정된 축에 대한 축 설정정보 개체 생성 여부
 *
 * @param   bAxisExist      : 축 구성되어있는지 점검 여부, TRUE=구성되어있어야한다.
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = NO-EXIST MOTION LIBRARY OBJECT(MULTIAXES)
 *							  xx = INVALID MOTION AXIS ID(MULTIAXES)
 *							  xx = NO-EXIST MOTION AXIS CONFIG(MULTIAXES)
 *							  xx = OVER MOTION AXIS NUMBER(MULTIAXES)
 *							  xx = NO-EXIST MOTION AXIS AREA POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::checkAxisExistArgument(BOOL bAxisExist)
{
#ifdef SIMULATION
	return ERR_MOTION_SUCCESS;
#endif

	/** 1. Motion Library 미생성 오류 */
	if (m_pMotionLib == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : Motion Library Object Not Exist");
		SetErrorLevel(_T("AXIS check Axis Element(Motion Library)"),3, __FILE__, __LINE__);
		return generateErrorCode(105024);	// ERR_MAXES_NO_EXIST_MOTION_LIBRARY_OBJECT
	}

	/** 축 구성되어있어야 한다. */
	if (bAxisExist == TRUE)
	{
		/** 2. 축이 사용하고 있어야 한다. */
		BOOL bStatus = FALSE;
		m_pMotionLib->GetUseAxis(m_SaxAxis.iAxisID, &bStatus);
		if (bStatus == FALSE)
		{
			//WriteErrorLog("checkAxisExistArgument() : Motion Axis Config Not Exist");
			SetErrorLevel(_T("AXIS check Axis Elements"),3, __FILE__, __LINE__);
			return generateErrorCode(105026);	// ERR_MAXES_NO_EXIST_MOTION_AXIS_CONFIG
		}
	}

	return ERR_MOTION_SUCCESS;
}
/** 
 * 축 구성에 대한 오류를 점검한다.(포인터 인수 1개)
 *  1. 전달된 포인터 인수 정상 여부
 *  2. 기타 오류 점검
 *
 * @param   *pPointer       : Pointer로 전달된 인수
 * @param   bAxisExist      : 축 구성되어있는지 점검 여부, TRUE=구성되어있어야한다.
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::checkAxisExistArgument(void* pPointer, BOOL bAxisExist)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 1. 인수 포인터 오류 */
	if (pPointer == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element(Pointer)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 2. 축 구성 Index ID 범위 오류 */
	if ((iResult = checkAxisExistArgument(bAxisExist)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS check Axis Element(Index ID)"),3, __FILE__, __LINE__);
		return iResult;
	}

	return ERR_MOTION_SUCCESS;
}
/** 
 * 축 구성에 대한 오류를 점검한다.(포인터 인수 2개)
 *  1. 전달된 포인터 인수1 정상 여부
 *  2. 전달된 포인터 인수2 정상 여부
 *  3. 기타 오류 점검
 *
 * @param   *pPointer1      : Pointer로 전달된 인수1
 * @param   *pPointer2      : Pointer로 전달된 인수2
 * @param   bAxisExist      : 축 구성되어있는지 점검 여부, TRUE=구성되어있어야한다.
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::checkAxisExistArgument(void* pPointer1, void* pPointer2, BOOL bAxisExist)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 1. 인수 포인터1 오류 */
	if (pPointer1 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer1 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element(Pointer 1)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 2. 인수 포인터2 오류 */
	if (pPointer2 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer2 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element(Pointer 2)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 3. 축 구성 Index ID 범위 오류 */
	if ((iResult = checkAxisExistArgument(bAxisExist)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS check Axis Element(Axis Index ID)"),3, __FILE__, __LINE__);
		return iResult;
	}

	return ERR_MOTION_SUCCESS;
}
/** 
 * 축 구성에 대한 오류를 점검한다.(포인터 인수 3개)
 *  1. 전달된 포인터 인수1 정상 여부
 *  2. 전달된 포인터 인수2 정상 여부
 *  3. 전달된 포인터 인수3 정상 여부
 *  4. 기타 오류 점검
 *
 * @param   *pPointer1      : Pointer로 전달된 인수1
 * @param   *pPointer2      : Pointer로 전달된 인수2
 * @param   *pPointer3      : Pointer로 전달된 인수3
 * @param   bAxisExist      : 축 구성되어있는지 점검 여부, TRUE=구성되어있어야한다.
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::checkAxisExistArgument(void* pPointer1, 
								  void* pPointer2, 
								  void* pPointer3,
								  BOOL bAxisExist)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 1. 인수 포인터1 오류 */
	if (pPointer1 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer1 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element(Pointer 1)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 2. 인수 포인터2 오류 */
	if (pPointer2 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer2 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element(Pointer 2)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 3. 인수 포인터3 오류 */
	if (pPointer3 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer3 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element(Pointer 3)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 4. 축 구성 Index ID 범위 오류 */
	if ((iResult = checkAxisExistArgument(bAxisExist)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS check Axis Element(Axis Index ID)"),3, __FILE__, __LINE__);
		return iResult;
	}

	return ERR_MOTION_SUCCESS;
}
/** 
 * 축 구성에 대한 오류를 점검한다.(포인터 인수 4개)
 *  1. 전달된 포인터 인수1 정상 여부
 *  2. 전달된 포인터 인수2 정상 여부
 *  3. 전달된 포인터 인수3 정상 여부
 *  4. 전달된 포인터 인수4 정상 여부
 *  5. 기타 오류 점검
 *
 * @param   *pPointer1      : Pointer로 전달된 인수1
 * @param   *pPointer2      : Pointer로 전달된 인수2
 * @param   *pPointer3      : Pointer로 전달된 인수3
 * @param   *pPointer4      : Pointer로 전달된 인수4
 * @param   bAxisExist      : 축 구성되어있는지 점검 여부, TRUE=구성되어있어야한다.
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::checkAxisExistArgument(void* pPointer1, 
								  void* pPointer2, 
								  void* pPointer3,
								  void* pPointer4,
								  BOOL bAxisExist)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 1. 인수 포인터1 오류 */
	if (pPointer1 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer1 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element(Pointer 1)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 2. 인수 포인터2 오류 */
	if (pPointer2 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer2 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element(Pointer 2)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 3. 인수 포인터3 오류 */
	if (pPointer3 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer3 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element(Pointer 3)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 4. 인수 포인터4 오류 */
	if (pPointer4 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer4 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element(Pointer 4)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 5. 축 구성 Index ID 범위 오류 */
	if ((iResult = checkAxisExistArgument(bAxisExist)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS check Axis Element(Axis Index ID)"),3, __FILE__, __LINE__);
		return iResult;
	}

	return ERR_MOTION_SUCCESS;
}
/** 
 * 축 구성에 대한 오류를 점검한다.(포인터 인수 4개)
 *  1. 전달된 포인터 인수1 정상 여부
 *  2. 전달된 포인터 인수2 정상 여부
 *  3. 전달된 포인터 인수3 정상 여부
 *  4. 전달된 포인터 인수4 정상 여부
 *  5. 전달된 포인터 인수5 정상 여부
 *  6. 기타 오류 점검
 *
 * @param   *pPointer1      : Pointer로 전달된 인수1
 * @param   *pPointer2      : Pointer로 전달된 인수2
 * @param   *pPointer3      : Pointer로 전달된 인수3
 * @param   *pPointer4      : Pointer로 전달된 인수4
 * @param   *pPointer5      : Pointer로 전달된 인수5
 * @param   bAxisExist      : 축 구성되어있는지 점검 여부, TRUE=구성되어있어야한다.
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::checkAxisExistArgument(void* pPointer1, 
								  void* pPointer2, 
								  void* pPointer3,
								  void* pPointer4, 
								  void* pPointer5, 
								  BOOL bAxisExist)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 1. 인수 포인터1 오류 */
	if (pPointer1 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer1 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element (Pointer 1)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 2. 인수 포인터2 오류 */
	if (pPointer2 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer2 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element (Pointer 2)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 3. 인수 포인터3 오류 */
	if (pPointer3 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer3 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element (Pointer 3)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 4. 인수 포인터4 오류 */
	if (pPointer4 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer4 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element (Pointer 4)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 5. 인수 포인터5 오류 */
	if (pPointer5 == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer5 Arguement NULL ");
		SetErrorLevel(_T("AXIS check Axis Element (Pointer 5)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 6. 축 구성 Index ID 범위 오류 */
	if ((iResult = checkAxisExistArgument(bAxisExist)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS check Axis Element (Axis Index ID)"),3, __FILE__, __LINE__);
		return iResult;
	}

	return ERR_MOTION_SUCCESS;
}
/** 
 * 축 구성에 대한 오류를 점검한다.
 *  1. Motion Library 개체 생성 여부
 *  2. 전달된 포인터 인수 정상 여부
 *  3. 구성된 Board 개수가 정상범위를 벗어난 경우
 *  4. Board ID가 정상범위를 벗어난 경우
 *  Board가 구성되어있어야하는 경우
 *    5. 설정된 Board이 없는 경우
 *    6. Board ID가 구성된 Board의 범위를 벗어난 경우
 *
 * @param   iBoardID        : Board ID, -1 = All Board
 * @param   *pPointer       : Pointer로 전달된 인수
 * @param   bBoardExist     : Board 구성되어있는지 점검 여부, TRUE=구성되어있어야한다.
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = NO-EXIST MOTION LIBRARY OBJECT(MULTIAXES)
 *							  xx = INVALID POINTER(MULTIAXES)
 *							  xx = INVALID MOTION BOARD ID(MULTIAXES)
 *							  xx = INVALID MOTION BOARD NUMBER(MULTIAXES)
 *							  xx = NO-EXIST MOTION BOARD CONFIG(MULTIAXES)
 *							  xx = OVER MOTION BOARD NUMBER(MULTIAXES)
 */
int MAxis::checkBoardExistArgument(int iBoardID, void* pPointer, BOOL bBoardExist)
{
	short siBdNum;
	CString strLogMsg;

	/** 1. Motion Library 미생성 오류 */
	if (m_pMotionLib == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : Motion Library Object Not Exist");
		SetErrorLevel(_T("AXIS check Board Argument(Motion Library)"),3, __FILE__, __LINE__);
		return generateErrorCode(105024);	// ERR_MAXES_NO_EXIST_MOTION_LIBRARY_OBJECT
	}

	/** 2. 인수 포인터 오류 */
	if (pPointer == NULL)
	{
		//WriteErrorLog("checkAxisExistArgument() : pPointer Arguement NULL ");
		SetErrorLevel(_T("AXIS check Board Argument(Pointer)"),3, __FILE__, __LINE__);
		return generateErrorCode(105028);	// ERR_MAXES_INVALID_POINTER
	}

	/** 구성된 Board 수 읽기 */
	m_pMotionLib->GetBoardNum(&siBdNum);

	/** 3. 구성된 Board 개수 Data 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > DEF_MAX_MOTION_BD))
	{
		//strLogMsg.Format(_T("checkBoardExistArgument() : Invalid Board No Range %d"),siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("AXIS check Board Argument(Number of Board : %d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(105032);	// ERR_MAXES_INVALID_MOTION_BOARD_NUMBER
	}

	/** 4. Board ID Data 범위 오류 */
	if ((iBoardID < DEF_NON_MOTION_BD - 1) || (iBoardID > DEF_MAX_MOTION_BD - 1))
	{
		//strLogMsg.Format(_T("checkBoardExistArgument() : Invalid Board ID Range %d"),iBoardID);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("AXIS check Board Argument(Board ID %d)"),iBoardID);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(105032);	// ERR_MAXES_INVALID_MOTION_BOARD_NUMBER
	}

	if (bBoardExist == TRUE)
	{
		/** 5. Board 개수 설정 Data 미일치 - 설정할 Board 없음 */
		if (siBdNum == 0)
		{
			//WriteErrorLog("checkBoardExistArgument() : Board No Is 0");
			SetErrorLevel(_T("AXIS check Board Argument(Board)"),3, __FILE__, __LINE__);
			return generateErrorCode(105025);	// ERR_MAXES_NO_EXIST_MOTION_BOARD_CONFIG
		}

		/** 6. Board 개수 설정 Data 미일치 - 설치된 Board보다 큰 인수값 */
		if (iBoardID >(siBdNum - 1))
		{
			//strLogMsg.Format(_T("checkBoardExistArgument() : \
			//	              BoardID Value(%d)  Over Board Number(%d)"),iBoardID,siBdNum - 1);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("AXIS check Board Argument(Board ID %d)"),iBoardID);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return generateErrorCode(105022);	// ERR_MAXES_OVER_MOTION_BOARD_NUMBER
		}
	}

	return ERR_MOTION_SUCCESS;
}

/**
 * 원점복귀된 축에 대해서 Event가 발생한 경우에 대해 점검 및 조치를 한다.
 * 
 * @param   iAxisID			: 축 ID(0 ~ 63)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID(MULTIAXES)
 *							  xx = HOME SWITCH AXIS SOURCE(MULTIAXES)
 *							  xx = POSITIVE LIMIT AXIS SOURCE(MULTIAXES)
 *							  xx = NEGATIVE LIMIT AXIS SOURCE(MULTIAXES)
 *							  xx = AMP FAULT AXIS SOURCE(MULTIAXES)
 *							  xx = ACCELERATE LIMIT AXIS SOURCE(MULTIAXES)
 *							  xx = VELOCITY LIMIT AXIS SOURCE(MULTIAXES)
 *							  xx = X NEGATIVE LIMIT AXIS SOURCE(MULTIAXES)
 *							  xx = X POSITIVE LIMIT AXIS SOURCE(MULTIAXES)
 *							  xx = ERROR LIMIT AXIS SOURCE(MULTIAXES)
 *							  xx = PC COMMAND AXIS SOURCE(MULTIAXES)
 *							  xx = OUT OF FRAMES AXIS SOURCE(MULTIAXES)
 *							  xx = AMP POWER ON OFF AXIS SOURCE(MULTIAXES)
 *							  xx = RUN STOP COMMAND AXIS SOURCE(MULTIAXES)
 *							  xx = COLLISION STATE AXIS SOURCE(MULTIAXES)
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::checkAxisState(int iAxisID)
{
	int iResult = ERR_MOTION_SUCCESS;
	short siState, siSource;

	if ((iResult = m_pMotionLib->GetAxisState(iAxisID, &siState)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
		return iResult;
	}

	if ((m_bOriginFlag == TRUE) && (siState != DEF_NO_EVENT))
	{
		if ((iResult = m_pMotionLib->GetAxisSource(iAxisID, &siSource)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return iResult;
		}

 		if ((siSource & DEF_ST_HOME_SWITCH) && (m_SaxAxis.iRoleOfHome != HOME_N_NONE))
		{
			m_bOriginFlag = FALSE;
			//WriteErrorLog("checkAxisState() : HOME_SWITCH_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105036);	// ERR_MAXES_HOME_SWITCH_AXIS_SOURCE;
		}

		else if (siSource & DEF_ST_POS_LIMIT)
		{
			m_bOriginFlag = FALSE;
			//WriteErrorLog("checkAxisState() : POSITIVE_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105037);	// ERR_MAXES_POSITIVE_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_NEG_LIMIT)
		{
			m_bOriginFlag = FALSE;
			//WriteErrorLog("checkAxisState() : NEGATIVE_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105038);	// ERR_MAXES_NEGATIVE_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_AMP_FAULT)
		{
			m_bOriginFlag = FALSE;
			//WriteErrorLog("checkAxisState() : AMP_FAULT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105039);	// ERR_MAXES_AMP_FAULT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_A_LIMIT)
		{
			//WriteErrorLog("checkAxisState() : ACCELERATE_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105040);	// ERR_MAXES_ACCELERATE_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_V_LIMIT)
		{
			//WriteErrorLog("checkAxisState() : VELOCITY_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105041);	// ERR_MAXES_VELOCITY_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_X_NEG_LIMIT)
		{
			//WriteErrorLog("checkAxisState() : X_NEGATIVE_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105042);	// ERR_MAXES_X_NEGATIVE_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_X_POS_LIMIT)
		{
			//WriteErrorLog("checkAxisState() : X_POSITIVE_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105043);	// ERR_MAXES_X_POSITIVE_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_ERROR_LIMIT)
		{
			//WriteErrorLog("checkAxisState() : ERROR_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105044);	// ERR_MAXES_ERROR_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_PC_COMMAND)
		{
			//WriteErrorLog("checkAxisState() : PC_COMMAND_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105045);	// ERR_MAXES_PC_COMMAND_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_OUT_OF_FRAMES)
		{
			//WriteErrorLog("checkAxisState() : OUT_OF_FRAMES_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105046);	// ERR_MAXES_OUT_OF_FRAMES_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_AMP_POWER_ONOFF)
		{
			//WriteErrorLog("checkAxisState() : AMP_POWER_ON_OFF_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105047);	// ERR_MAXES_AMP_POWER_ON_OFF_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_RUN_STOP_COMMAND)
		{
			//WriteErrorLog("checkAxisState() : RUN_STOP_COMMAND_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105048);	// ERR_MAXES_RUN_STOP_COMMAND_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_COLLISION_STATE)
		{
			//WriteErrorLog("checkAxisState() : COLLISION_STATE_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105049);	// ERR_MAXES_COLLISION_STATE_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_NONE)
		{
			if ((iResult = m_pMotionLib->ClearStatus(iAxisID)) != ERR_MOTION_SUCCESS)
			{
				SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
				return iResult;
			}

			Sleep(400);
			return ERR_MOTION_SUCCESS;
		}
		else if (siSource & DEF_ST_INPOSITION_STATUS)
		{
			if ((iResult = ClearAxis()) != ERR_MOTION_SUCCESS)
			{
				SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
				return iResult;
			}

			Sleep(400);
			return ERR_MOTION_SUCCESS;
		}
		else if (siSource & DEF_ST_ABS_COMM_ERROR)
		{
			if ((iResult = ClearAxis()) != ERR_MOTION_SUCCESS)
			{
				SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
				return iResult;
			}

			Sleep(400);
			return ERR_MOTION_SUCCESS;
		}
		else if (siSource != ERR_MOTION_SUCCESS)
		{
			//WriteErrorLog("checkAxisState() : UNKNOWN_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check State"),3, __FILE__, __LINE__);
			return generateErrorCode(105056);	// ERR_MAXES_UNKNOWN_AXIS_SOURCE
		}
		else
			m_pMotionLib->ClearStatus(iAxisID);
	}

	return ERR_MOTION_SUCCESS;
}

/**
 * Jog동작중 Event가 발생한 경우에 대해 점검 및 조치를 한다.
 * 
 * @param   bDir             : 이동할 방향, TRUE:(+), FALSE:(-)
 * @return	Error Code		: 0 = SUCCESS
 *							  그 외 = 타 함수 Return Error
 */
int MAxis::CheckAxisStateForJog(BOOL bDir)
{
	int iResult = ERR_MOTION_SUCCESS;
	short siState, siSource;
	static BOOL bOriginEventSet = FALSE;

	if ((iResult = m_pMotionLib->GetAxisState(m_SaxAxis.iAxisID, &siState)) != ERR_MOTION_SUCCESS)
	{
		SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
		return iResult;		
	}


	if (siState != DEF_NO_EVENT)
	{
		if ((iResult = m_pMotionLib->GetAxisSource(m_SaxAxis.iAxisID, 
			                                       &siSource)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return iResult;
		}

		if ((siSource & DEF_ST_HOME_SWITCH) 
			 && (m_SaxAxis.iRoleOfHome == HOME_N_NEGATIVE_LIMIT) && !bDir)
		{
			//WriteErrorLog("checkAxisState() : HOME_SWITCH_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105036);	// ERR_MAXES_HOME_SWITCH_AXIS_SOURCE;
		}
		else if ((siSource & DEF_ST_HOME_SWITCH) 
			      && (m_SaxAxis.iRoleOfHome == HOME_N_POSITIVE_LIMIT) && bDir)
		{
			//WriteErrorLog("checkAxisState() : HOME_SWITCH_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105036);	// ERR_MAXES_HOME_SWITCH_AXIS_SOURCE;
		}
		else if ((siSource & DEF_ST_POS_LIMIT) && bDir)
		{
			//WriteErrorLog("checkAxisState() : POSITIVE_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105037);	// ERR_MAXES_POSITIVE_LIMIT_AXIS_SOURCE
		}

		else if ((siSource & DEF_ST_NEG_LIMIT) && !bDir)
		{
			//WriteErrorLog("checkAxisState() : NEGATIVE_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105038);	// ERR_MAXES_NEGATIVE_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_AMP_FAULT)
		{
			//WriteErrorLog("checkAxisState() : AMP_FAULT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105039);	// ERR_MAXES_AMP_FAULT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_A_LIMIT)
		{
			//WriteErrorLog("checkAxisState() : ACCELERATE_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105040);	// ERR_MAXES_ACCELERATE_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_V_LIMIT)
		{
			//WriteErrorLog("checkAxisState() : VELOCITY_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105041);	// ERR_MAXES_VELOCITY_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_X_NEG_LIMIT)
		{
			//WriteErrorLog("checkAxisState() : X_NEGATIVE_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105042);	// ERR_MAXES_X_NEGATIVE_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_X_POS_LIMIT)
		{
			//WriteErrorLog("checkAxisState() : X_POSITIVE_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105043);	// ERR_MAXES_X_POSITIVE_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_ERROR_LIMIT)
		{
			//WriteErrorLog("checkAxisState() : ERROR_LIMIT_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105044);	// ERR_MAXES_ERROR_LIMIT_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_OUT_OF_FRAMES)
		{
			//WriteErrorLog("checkAxisState() : OUT_OF_FRAMES_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105046);	// ERR_MAXES_OUT_OF_FRAMES_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_AMP_POWER_ONOFF)
		{
			//WriteErrorLog("checkAxisState() : AMP_POWER_ON_OFF_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105047);	// ERR_MAXES_AMP_POWER_ON_OFF_AXIS_SOURCE
		}

		else if (siSource & DEF_ST_COLLISION_STATE)
		{
			//WriteErrorLog("checkAxisState() : COLLISION_STATE_AXIS_SOURCE");
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return generateErrorCode(105049);	// ERR_MAXES_COLLISION_STATE_AXIS_SOURCE
		}
		else if (siSource & DEF_ST_INPOSITION_STATUS)
		{
			if ((iResult = ClearAxis()) != ERR_MOTION_SUCCESS)
			{
				SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
				return iResult;
			}

			Sleep(400);
			return ERR_MOTION_SUCCESS;
		}
		else if (siSource & DEF_ST_ABS_COMM_ERROR)
		{
			if ((iResult = ClearAxis()) != ERR_MOTION_SUCCESS)
			{
				SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
				return iResult;
			}

			Sleep(400);
			return ERR_MOTION_SUCCESS;
		}
		else
		{
			if (siSource & DEF_ST_HOME_SWITCH)
			{
				/** Home에서 E-Stop 발생 했을 때 반대 Jog 동작을 위해 Event 해제 */
				SetHomeSensorEvent(DEF_NO_EVENT);				

				bOriginEventSet = TRUE;
			}
						
			if ((iResult = ClearAxis()) != ERR_MOTION_SUCCESS)
			{
				SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
				return iResult;
			}
			
			return ERR_MOTION_SUCCESS;
		}
	}

	if (bOriginEventSet)
	{
		/** Home에서 E-Stop 발생 했을 때 반대 Jog 동작을 위해 Event 해제 한 후
		 * Home Sensor가 벗어나면 다시 E-Stop Event를 걸기 위해...
		 */
		if ((iResult = m_pMotionLib->GetAxisSource(m_SaxAxis.iAxisID, 
			                                       &siSource)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("AXIS check Jog State"),3, __FILE__, __LINE__);
			return iResult;
		}

		if (!(siSource & DEF_ST_HOME_SWITCH))
		{
			if (m_SaxAxis.iRoleOfHome != HOME_N_NONE)
				SetHomeSensorEvent(DEF_E_STOP_EVENT);

			bOriginEventSet = FALSE;
		}
	}

	return ERR_MOTION_SUCCESS;
}

/**
 * 이동할 위치가 SW Limit을 벗어나는지 확인한다.
 * 
 * @param   dPosition		: 검사할 위치
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = OVER SW POSITIVE LIMIT(MULTIAXES)
 *							  xx = OVER SW NEGATIVE LIMIT(MULTIAXES)
 */
int	MAxis::checkSWLimit(double dPosition)
{
	if (dPosition > m_AxisParameter.dCWSWLimit)
	{
		//WriteErrorLog("checkSWLimit() : OVER_SW_POSITIVE_LIMIT");
		SetErrorLevel(_T("AXIS check Switch Limit"),3, __FILE__, __LINE__);
		return generateErrorCode(105060);	// ERR_MAXES_OVER_SW_POSITIVE_LIMIT
	}

	if (dPosition < m_AxisParameter.dCCWSWLimit)
	{
		//WriteErrorLog("checkSWLimit() : OVER_SW_NAGATIVE_LIMIT");
		SetErrorLevel(_T("AXIS check Switch Limit"),3, __FILE__, __LINE__);
		return generateErrorCode(105061);	// ERR_MAXES_OVER_SW_NAGATIVE_LIMIT
	}

	return ERR_MOTION_SUCCESS;
}

double MAxis::calculateMotionTime()
{
	double dMotionTime = 0.0;
	double dMovingDistance = 0.0;

	double dSign = (m_SaxAxis.bSign) ? 1.0 : -1.0;

	if (FALSE == m_bRMoveStart)	// PtoP Move
	{
		dMovingDistance = fabs(m_dCurrentAxisPos - dSign * m_dTargetAxisPos);
	}
	else	// R Move
	{
		dMovingDistance = fabs(m_dRMoveDistance);
	}

	double dVel;
	if (m_dVelocity == 0.0)
	{
		if (m_AxisParameter.eVelocityMode == VELOCITY_MODE_NORMAL)
			dVel = m_AxisParameter.dRunVelocity;
		else
			dVel = m_AxisParameter.dSlowRunVelocity;
	}
	else
		dVel = dSign * m_dVelocity;

	short iAccel = (m_iAccelerate == 0) ? m_AxisParameter.iRunAccelerate : m_iAccelerate;
	short iDecel = (m_iDecelerate == 0) ? m_AxisParameter.iRunAccelerate : m_iDecelerate;

	double dAccelateTime = (double)iAccel / 1000;
	double dDecelateTime = (double)iDecel / 1000;

	// 가감속 구간에서의 이동 거리
	double dAccDecelMovingDistance = dVel * dAccelateTime / 2 + dVel * dDecelateTime / 2;
	if (dAccDecelMovingDistance >= dMovingDistance)
	{
		// 확인 필요 : 임시 코드. 정확한 계산은 아님. 그냥 대충 가감속 시간만큼만 먹는다고 생각.

		dMotionTime = dAccelateTime + dDecelateTime;
	}
	else
	{
		double dUniformMotiontime = (dMovingDistance - dAccDecelMovingDistance) / dVel;
		dMotionTime = dAccelateTime + dUniformMotiontime + dDecelateTime;
	}

	return dMotionTime;
}

// Null Functions
// 확인 필요 : 이하 5개 함수 이름 통일 필요.
BOOL MAxis::IsOnHomeSensor()
{
	return CheckHomeSensor();
}

BOOL MAxis::IsOnPositiveSensor()
{
	return CheckPositiveSensor();
}

BOOL MAxis::IsOnNegativeSensor()
{
	return CheckNegativeSensor();
}

BOOL MAxis::IsAmpEnable()
{
	return GetAmpEnable();
}

BOOL MAxis::IsAmpFault()
{
	return GetAmpFault();
}

// 확인 필요 : 사용하지도 않는 함수를 굳이 왜 만들었나? Sercos 에서도 이와 똑같이 구현되어 있음.
BOOL MAxis::IsEStopEvent()
{
	int iState;
	int iResult = GetAxisState(&iState);
	if (iResult)
	{
		SetErrorLevel(_T("AXIS State : EStop Event"),3, __FILE__, __LINE__);
		return iResult;
	}

	if (iState == DEF_E_STOP_EVENT)
	{
		SetErrorLevel(_T("AXIS State : EStop Event"),3, __FILE__, __LINE__);
		return TRUE;
	}
	
	return FALSE;
}

void MAxis::SetAxisPosReset()
{
	m_dCurrentAxisPos = 0.0;
	m_dTargetAxisPos = 0.0;
}

int MAxis::JogStop()
{
	return VStop();
}

// MMC 에서는 불필요한 함수들.
int MAxis::GetRingID()
{
	return ERR_MOTION_SUCCESS;
}

int MAxis::GetNodeID()
{
	return ERR_MOTION_SUCCESS;
}

int MAxis::ChangePhase(int Phase)
{
	return ERR_MOTION_SUCCESS;
}

int MAxis::NodeClear()
{
	return ERR_MOTION_SUCCESS;
}

int MAxis::SetEStopRate()
{
	return ERR_MOTION_SUCCESS;
}

int MAxis::HomingStop()
{
	return ERR_MOTION_SUCCESS;
}

BOOL MAxis::IsOriginComplete()
{
	return FALSE;
}

void MAxis::ResetOriginComplete()
{
}

double MAxis::DistanceToCurrentToHome()
{
	return 0.0;
}

int MAxis::SetHomingSwitchSource(int iSourceAxisNodeID)
{
	return ERR_MOTION_SUCCESS;
}

int MAxis::SetMotorScale(double dScale)
{
	return ERR_MOTION_SUCCESS;
}

/* End Of Code */
