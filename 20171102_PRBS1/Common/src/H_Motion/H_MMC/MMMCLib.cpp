/* Generated by Together */
/* 
 * Motion Component
 *
 * Copyright 2004 by Mechatronics Center, Samsung Electronics, Inc.,
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of Smasung Electronics, Inc. ("Confidential Information"). You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Samsung.
 */

#include "stdafx.h"

#include "math.h"
#include "MTickTimer.h"

#include "MMMCLib.h"
#include "common.h"

#include "MMCWFP40.h"
#pragma comment(lib, "VC60FP40")

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

 /**
 * MMMCLib.cpp : This file implements the class of MMC Motion Library.
 *				 이 파일은 MMC Motion Library를 위한 Class의 실행 코드를 구현한다.
 *
 * @author Yong-Seog Pahn (dragon.pahn@samsung.com)
 * @version $Revision$
 */

int	MMMCLib::m_iObjNo = 0;

/**
 * Constructor : create and clear data
 *				 Data를 생성하고 초기화한다.
 * @stereotype constructor
 */
MMMCLib::MMMCLib (SCommonAttribute commonData)
:ICommon(commonData)	//** 1222
{

	m_pBoardConfig = new MMotionBoard();

	/** MMMCLib 개체 수 증가 */
	m_iObjNo++;
}

/**
 * Destructor : Delete inner object
 *				내부 개체를 소멸한다.
 * @stereotype destructor
 */
MMMCLib::~MMMCLib ()	//**1222
{
	BOOL bStatus;

	/** MMMCLib 개체 수 감소 */
	m_iObjNo--;

	/** 마지막 개체이면 */
	if (m_iObjNo == 0)
	{
		/** Axis All Stop */
		/** Servo All Off */
		for (int i = 0; i < DEF_MAX_AXIS_NO; i++)
		{
			m_pBoardConfig->GetUseAxis (i, &bStatus);
			if (bStatus == TRUE)
			{
				SetStop(i, DEF_STOP);
				SetAmpEnable(i, FALSE);
			}
		}
	}

	/** Board 구성정보 개체 소멸 */
	if (m_pBoardConfig != NULL)
		delete m_pBoardConfig;
}

/**
 * 축 사용 여부 설정 (이미 사용중인 축은 사용으로 설정 불가)
 *
 * 축 사용 여부 설정은 Motor Parameter 설정과는 무관하며, 사용자에 의해 설정이 되어야 한다.
 *
 * @param	siAxisID		: 축 ID
 * @param	bState			: 사용 여부 (TRUE=사용, FALSE=미사용)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = USED AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetUseAxis (short siAxisID, BOOL bState)
{
	int		iResult;
	BOOL	bStt = 0;
	short	siBdNum;
	CString	strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxisID < DEF_AXIS_NON_NO) || (siAxisID > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	/** 축 사용 유무에 따라 */
	if (bState == DEF_AXIS_USE)
	{
		/** 축 사용 여부 읽기 */
		if ((iResult = m_pBoardConfig->GetUseAxis(siAxisID, &bStt)) != ERR_MOTION_SUCCESS)
			return iResult;

		/** 이미 축을 사용하고 있으면 */
		if (bStt == DEF_AXIS_USE)
			return ERR_MOTION_SUCCESS;

		/** 축 사용하기로 설정 */
		if ((iResult = m_pBoardConfig->SetUseAxis(siAxisID, bState)) != ERR_MOTION_SUCCESS)
			return iResult;
	}
	else
	{
		/** 축 사용안하기로 설정 */
		if ((iResult = m_pBoardConfig->SetUseAxis(siAxisID, bState)) != ERR_MOTION_SUCCESS)
			return iResult;
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 축 사용 여부 읽기
 *
 * @param	siAxisID		: 축 ID
 * @param	*pbState		: 사용 여부 (TRUE=사용, FALSE=미사용)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetUseAxis (short siAxisID, BOOL *pbState)
{
	int		iResult;
	BOOL	bStt = 0;
	short	siBdNum;
	CString	strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxisID < DEF_AXIS_NON_NO) || (siAxisID > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	/** 인수 Pointer 오류 */
	if (pbState == NULL)
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	/** 축 사용 여부 읽기 */
	if ((iResult = m_pBoardConfig->GetUseAxis(siAxisID, pbState)) != ERR_MOTION_SUCCESS)
		return iResult;

	return ERR_MOTION_SUCCESS;
}
/**
 * Motor Parameter 설정 (Board 초기화 후 사용 가능)
 *
 * 전달된 SMotionAxis의 내용으로 Motion을 설정한다. (축 1개 단위로 설정)
 *
 * 1. Board가 초기화 안되어 있으면 Error Return
 * 2. 축 AMP Enable(Servo ON)이면 Disable(OFF) 후 작업 진행
 * 3. Motor 종류 설정
 * 4. Feedback Device 설정
 * 5. Loop 형태 설정
 * 6. Motor 종류에 따라
 *		6.1 속도형 Servo의 경우
 *			제어 모드와 출력 형태 설정
 *		6.2 일반 Stepper의 경우
 *			펄스 분주비와 전자기어비 설정
 *		6.3 Micro Stepper 혹은 위치형 Servo의 경우
 *			펄스 분주비(default:8)와 전자기어비(default:1.0) 설정
 * 7. 출력 펄스 형태 설정
 * 8. Encoder와 좌표 방향 설정
 * 9. AMP Enable, Fault, Reset 설정
 * 10. Home, Positive, Negative Sensor 설정
 * 11. Positive, Negative S/W Limit 설정
 * 12. In-Position 설정
 * 13. 축 AMP Enable(Servo ON)이었으면 Enable(ON) 설정
 *
 * @param	siAxisID		: 축 ID, -1=허용안됨
 * @param	mAx				: Motor Parameter
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 기록할지 여부, TRUE=boot file에 기록
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = USED AXIS ID (MOTIONLIB)
 *							  xx = MOTION BOARD NO INITIALIZED (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetMotorParam (short siAxisID, SMotionAxis mAx, BOOL bBootOpt)
{
	int		iResult = ERR_MOTION_SUCCESS;
	short	siBdNum;
	BOOL	bAmpState = FALSE;
	CString	strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxisID < DEF_AXIS_NON_NO) || (siAxisID > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109); // ERR_MLIB_INVALID_AXIS_ID

	/** Board 초기화 수행 여부 */
	if (m_pBoardConfig->GetBoardInitSuccess() != TRUE)
		return generateErrorCode(106073); // ERR_MLIB_NO_MOTION_BOARD_INITIALIZED

	/** AMP Enable 상태 확인 */
	if ((iResult = GetAmpEnable(siAxisID, &bAmpState)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** AMP Enable이면 Disable 설정 */
	if (bAmpState == DEF_ENABLE)
	{
		if ((iResult = SetAmpEnable(siAxisID, DEF_DISABLE)) != ERR_MOTION_SUCCESS)
			return iResult;
	}

	/** Motor 종류 설정 */
	if ((iResult = SetMotorType(siAxisID, mAx.iMotorType, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** Motor Feed Device와 Lop 종류 설정 */
	if ((iResult = SetAxisProperty(siAxisID, mAx.iFeedbackType, mAx.bLoopType, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** Motor Type에 따라 */
	switch (mAx.iMotorType)
	{
	case DEF_SERVO_MOTOR :			// 속도형 Serve
		/** 속도형 Servo의 제어 모드와 출력 형태 설정 */
		if ((iResult = SetVServoProperty(siAxisID, mAx.bVServoControl, mAx.bVServoPolar, bBootOpt)) != ERR_MOTION_SUCCESS)
			return iResult;

		break;
	case DEF_STEPPER :				// 일반 Stepper
		/** 펄스 분주비와 전자기어비 설정 */
		if ((iResult = SetRatioProperty(siAxisID, mAx.iStepperPulseR, mAx.dStepperEGear, bBootOpt)) != ERR_MOTION_SUCCESS)
			return iResult;

		break;
	case DEF_MICRO_STEPPER :		// Micro Stepper 또는 위치형 Servo
		/** 펄스 분주비와 전자기어비 설정 */
		if ((iResult = SetRatioProperty(siAxisID, mAx.iStepperPulseR, mAx.dStepperEGear, bBootOpt)) != ERR_MOTION_SUCCESS)
			return iResult;

		break;
	}

	/** 출력 펄스 형태 설정 */
	if ((iResult = SetStepMode(siAxisID, mAx.bPulseType, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** Encoder 방향과 좌표 방향 설정 */
	if ((iResult = SetEncoderDirection(siAxisID, mAx.bEncoderDir, mAx.bCoordinateDir, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;
	Sleep(10);
	/** AMP Enable Level 설정 */
	if ((iResult = SetAmpEnableLevel(siAxisID, mAx.bAmpEnableLevel, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** AMP Fault Level 설정 */
	if ((iResult = SetAmpFaultLevel(siAxisID, mAx.bAmpFaultLevel, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** AMP Fault Event 설정 */
	if ((iResult = SetAmpFaultEvent(siAxisID, mAx.iAmpFaultEvent, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** AMP Reset Level 설정 */
	if ((iResult = SetAmpResetLevel(siAxisID, mAx.bAmpResetLevel, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** Home Sensor Level/Event 설정 */
	if ((iResult = SetSensorLimit(siAxisID, DEF_HOME_SENSOR, mAx.iHomeEvent, mAx.bHomeLevel, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** Positive Sensor Level/Event 설정 */
	if ((iResult = SetSensorLimit(siAxisID, DEF_POSITIVE_SENSOR, mAx.iPositiveEvent, mAx.bPositiveLevel, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** Negative Sensor Level/Event 설정 */
	if ((iResult = SetSensorLimit(siAxisID, DEF_NEGATIVE_SENSOR, mAx.iNegativeEvent, mAx.bNegativeLevel, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** Positive S/W Limit Level/Event 설정 */
	if ((iResult = SetSWLimit(siAxisID, DEF_POSITIVE_SENSOR, mAx.dPositiveSWLimit, mAx.iPositiveSWEvent, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** Negative S/W Limit Level/Event 설정 */
	if ((iResult = SetSWLimit(siAxisID, DEF_NEGATIVE_SENSOR, mAx.dNegativeSWLimit, mAx.iNegativeSWEvent, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** In-Position 위치결정값과 Level 설정 */
	if ((iResult = SetInPosition(siAxisID, mAx.dInpositionError, mAx.bInpositionLevel, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** In-Position 사용여부 설정 설정 */
	if ((iResult = SetInpositionRequired(siAxisID, TRUE, bBootOpt)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** AMP Enable이었으면 Enable 설정 */
	if (bAmpState == DEF_ENABLE)
	{
		if ((iResult = SetAmpEnable(siAxisID, DEF_ENABLE)) != ERR_MOTION_SUCCESS)
			return iResult;
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * Motor Parameter 읽기
 *
 * @param	siAxisID		: 축 ID, -1=All Motor
 * @param	*pmAx			: Motor Parameter, siAxisID=-1이면 배열 구조로 구성
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = USED AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetMotorParam (short siAxisID, SMotionAxis *pmAx)
{
	int iResult = ERR_MOTION_SUCCESS;
	short siMotorType;
	short siFeedbackType;
	short siStepperPulseR;
	short siAmpFaultEvent;
	short siHomeEvent;
	short siPositiveEvent;
	short siNegativeEvent;
	short siPositiveSWEvent;
	short siNegativeSWEvent;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxisID < DEF_AXIS_NON_NO) || (siAxisID > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109); // ERR_MLIB_INVALID_AXIS_ID

	/** 인수 Pointer 오류 */
	if (pmAx == NULL)
		return generateErrorCode(106090); // ERR_MLIB_INVALID_POINTER

	/** Motor Parameter 읽기 */

	/** Motor 종류 읽기 */
	if ((iResult = GetMotorType(siAxisID, &siMotorType)) != ERR_MOTION_SUCCESS)
		return iResult;
	pmAx->iMotorType = siMotorType;

	/** Motor Feed Device와 Lop 종류 읽기 */
	if ((iResult = GetAxisProperty(siAxisID, &siFeedbackType, &pmAx->bLoopType)) != ERR_MOTION_SUCCESS)
		return iResult;
	pmAx->iFeedbackType = (int)siFeedbackType;

	/** Motor Type에 따라 */
	switch (pmAx->iMotorType)
	{
	case 0 :			// 속도형 Serve
		/** 속도형 Servo의 제어 모드와 출력 형태 읽기 */
		if ((iResult = GetVServoProperty(siAxisID, &pmAx->bVServoControl, &pmAx->bVServoPolar)) != ERR_MOTION_SUCCESS)
			return iResult;

		break;
	case 1 :				// 일반 Stepper
		/** 펄스 분주비와 전자기어비 읽기 */
		if ((iResult = GetRatioProperty(siAxisID, &siStepperPulseR, &pmAx->dStepperEGear)) != ERR_MOTION_SUCCESS)
			return iResult;
		pmAx->iStepperPulseR = (int)siStepperPulseR;

		break;
	case 2 :		// Micro Stepper 또는 위치형 Servo
		/** 펄스 분주비와 전자기어비 읽기 */
		if ((iResult = GetRatioProperty(siAxisID, &siStepperPulseR, &pmAx->dStepperEGear)) != ERR_MOTION_SUCCESS)
			return iResult;
		pmAx->iStepperPulseR = (int)siStepperPulseR;

		break;
	}

	/** 출력 펄스 형태 읽기 */
	if ((iResult = GetStepMode(siAxisID, &pmAx->bPulseType)) != ERR_MOTION_SUCCESS)
		return iResult;

	/** Encoder 방향과 좌표 방향 읽기 */
	if ((iResult = GetEncoderDirection(siAxisID, &pmAx->bEncoderDir, &pmAx->bCoordinateDir)) != ERR_MOTION_SUCCESS)
		return iResult;


	/** AMP Enable Level 읽기 */
	if ((iResult = GetAmpEnableLevel(siAxisID, &pmAx->bAmpEnableLevel)) != ERR_MOTION_SUCCESS)
		return iResult;


	/** AMP Fault Level 읽기 */
	if ((iResult = GetAmpFaultLevel(siAxisID, &pmAx->bAmpFaultLevel)) != ERR_MOTION_SUCCESS)
		return iResult;


	/** AMP Fault Event 읽기 */
	if ((iResult = GetAmpFaultEvent(siAxisID, &siAmpFaultEvent)) != ERR_MOTION_SUCCESS)
		return iResult;

	pmAx->iAmpFaultEvent = siAmpFaultEvent;

	/** AMP Rest Level 읽기 */
	if ((iResult = GetAmpResetLevel(siAxisID, &pmAx->bAmpResetLevel)) != ERR_MOTION_SUCCESS)
		return iResult;


	/** Home Sensor Level/Event 읽기 */
	if ((iResult = GetSensorLimit(siAxisID, 0, &siHomeEvent, &pmAx->bHomeLevel)) != ERR_MOTION_SUCCESS)
		return iResult;

	pmAx->iHomeEvent = siHomeEvent;

	/** Positive Sensor Level/Event 읽기 */
	if ((iResult = GetSensorLimit(siAxisID, 1, &siPositiveEvent, &pmAx->bPositiveLevel)) != ERR_MOTION_SUCCESS)
		return iResult;

	pmAx->iPositiveEvent = siPositiveEvent;

	/** Negative Sensor Level/Event 읽기 */
	if ((iResult = GetSensorLimit(siAxisID, 2, &siNegativeEvent, &pmAx->bNegativeLevel)) != ERR_MOTION_SUCCESS)
		return iResult;

	pmAx->iNegativeEvent = siNegativeEvent;

	/** Positive S/W Limit Level/Event 읽기 */
	if ((iResult = GetSWLimit(siAxisID, 1, &pmAx->dPositiveSWLimit, &siPositiveSWEvent)) != ERR_MOTION_SUCCESS)
		return iResult;

	pmAx->iPositiveSWEvent = siPositiveSWEvent;

	/** Negative S/W Limit Level/Event 읽기 */
	if ((iResult = GetSWLimit(siAxisID, 0, &pmAx->dNegativeSWLimit, &siNegativeSWEvent)) != ERR_MOTION_SUCCESS)
		return iResult;
	pmAx->iNegativeSWEvent = siNegativeSWEvent;

	/** In-Position 위치결정값과 Level 읽기 */
	if ((iResult = GetInPosition(siAxisID, &pmAx->dInpositionError, &pmAx->bInpositionLevel)) != ERR_MOTION_SUCCESS)
		return iResult;

	return ERR_MOTION_SUCCESS;
}
/**
 * Motion Board Parameter 설정
 *
 * @param	iObjectID		: Object ID
 * @param	MotionBd		: Motion Board Parameter
 * @param	iErrorBase		: Error Code Start Number
 * @param	strFullFileName	: Log File Path & File Name
 * @param	ucLevel			: Log LEvel (None, Normal, Warning, Error)
 * @param	iDays			: Log 우지 일 수
 * @return	Error Code		: 0 = SUCCESS
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetBoardParam (SMotionBoard MotionBd)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** Board Parameter 설정 */
	if ((iResult = m_pBoardConfig->SetBoardConfig(MotionBd)) != ERR_MOTION_SUCCESS)
		return iResult;


	/** Board 초기화 */
	if ((iResult = Initialize(MotionBd.iMaxBoardNo, MotionBd.rglAddress)) != ERR_MOTION_SUCCESS)
		return iResult;

	return ERR_MOTION_SUCCESS;
}
/**
 * Motion Board Parameter 읽기
 *
 * @param	*pmBd			: Motion Board Parameter
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetBoardParam (SMotionBoard *pmBd)
{
	int iResult = ERR_MOTION_SUCCESS;

	/** 인수 Pointer 오류 */
	if (pmBd == NULL)
		return generateErrorCode(106090);  // ERR_MLIB_INVALID_POINTER

	/** Board Parameter 읽기 */
	if ((iResult = m_pBoardConfig->GetBoardConfig(pmBd)) != ERR_MOTION_SUCCESS)
		return iResult;

	return ERR_MOTION_SUCCESS;
}
/**
 * 구성된 Board 개수 읽기
 *
 * @param	*psiBdNum		: Board 구성 개수
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetBoardNum (short *psiBdNum)
{
	int iResult = ERR_MOTION_SUCCESS;
	CString strLogMsg;

	/** 인수 Pointer 오류 */
	if (psiBdNum == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

	/** 구성된 Board 개수 읽기 */
	if ((iResult = m_pBoardConfig->GetBoardNum(psiBdNum)) != ERR_MOTION_SUCCESS)
		return iResult;

	return ERR_MOTION_SUCCESS;
}
/**
 * Motion Board 초기화
 * 
 * 1. Motion Board 초기화가 수행된 경우
 * 	(1) Board 구성 수와 Board DPRAM Address가 같은 경우
 * 		→ Board 초기화 과정 Pass
 * 	(2) Board 구성 수가 다른 경우
 * 		→ Board 초기화 오류 처리
 * 	(3) Board DPRAM Address가 다른 경우
 * 		→ Board 초기화 오류 처리
 * 
 * 2. Motion Board 초기화가 수행되지 않은 경우
 * 	→ Board 초기화 수행
 *
 * MMC Library : mmc_initx()
 *
 * @param	siBdNum			: Motion Board 수 (1 ~ 4)
 * @param	*plAddress		: Board DPRAM Address (Board 수만큼)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD NUMBER (MOTIONLIB)
 *							  xx = NOT EQUAL MOTION BOARD NUMBER (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  xx = NOT EQUAL MOTION DPRAM ADDRESS (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::Initialize (short siBdNum, long *plAddress)
{
	int iResult = ERR_MOTION_SUCCESS;
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	long  rglAddr[DEF_MAX_MOTION_BD];
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber, rglAddr);

	/** Board 개수 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > siBdNumber))
		return generateErrorCode(106096);	// ERR_MLIB_INVALID_MOTION_BOARD_NUMBER

	/** 인수 Pointer 오류 */
	if (plAddress == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

	/** Board 초기화가 되어 있으면 */
	if (m_pBoardConfig->GetBoardInitSuccess() == TRUE)
	{
		/** 설정되어 있는 Board 개수와 설정하려는 Board 개수가 다르면 */
		if (siBdNumber != siBdNum)
			return generateErrorCode(106072);	// ERR_MLIB_NOT_EQUAL_MOTION_BOARD_NUMBER

		for (int i = 0; i < siBdNum; i++)
		{
			if (plAddress[i] != rglAddr[i])
				return generateErrorCode(106071);	// ERR_MLIB_NOT_EQUAL_MOTION_DPRAM_ADDRESS
		}
	}
	/** Board 초기화가 안되어 있으면 */
	else
	{
		/** Board 개수, DPRAM Address 설정 */
		if ((iResult = m_pBoardConfig->SetBoardNum(siBdNum, plAddress)) != ERR_MOTION_SUCCESS)
			return iResult;

#ifndef SIMULATION
		/** Motion Board 초기화 */
		if ((siResult = mmc_initx(siBdNum, plAddress)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("Initialize(): mmc_initx(MMC Initialize) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC initialize(Board)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif

		/** Motion Board 초기화 Flag 설정 */
		m_pBoardConfig->SetBoardInitSuccess(TRUE);
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * Motion Board 초기화 여부 읽기
 *
 * @param	*pbInit			: Board 초기화 여부, TRUE=초기화됐음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetBoardInit (BOOL *pbInit)
{
	/** 인수 Pointer 오류 */
	if (pbInit == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

	/** Board 초기화 성공 Flag 읽기 */
	*pbInit = m_pBoardConfig->GetBoardInitSuccess();

	return ERR_MOTION_SUCCESS;
}
/**
 * Motion Board의 제어 축 수를 돌려준다.
 *
 * MMC Library : mmc_all_axes(), mmc_axes()
 *
 * @param	siBdNum			: Motion Board ID (0 ~ 7), -1=All Board
 * @param	*psiAxes		: Board에 구성된 제어 축 수
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAxes (short siBdNum, short *psiAxes)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_ALL_MOTION_BD_ID) || (siBdNum > (siBdNumber - 1)))
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID

	/** 인수 Pointer 오류 */
	if (psiAxes == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

	/** 모든 Board 선택 시 */
	if (siBdNum == DEF_ALL_MOTION_BD_ID)
	{
#ifndef SIMULATION
		*psiAxes = mmc_all_axes();
#else
		*psiAxes = 1;
#endif
	}
	/** Board 1개 선택 시 */
	else
	{
#ifndef SIMULATION
		if ((siResult = mmc_axes(siBdNum, psiAxes)) != ERR_MOTION_SUCCESS)
			//strLogMsg.Format(_T("GetAxes(): mmc_axes(get a number of axes) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC get Number of Axis"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
#else
		*psiAxes = 1;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 직선, 원, 원호등의 동작을 수행할 각 좌표계의 축을 정의
 * 같은 Board의 축으로 구성해야 한다.
 *
 * MMC Library : map_axes()
 *
 * @param	siAxNum			: 축 수 (1 ~ 8)
 * @param	*psiMapArray	: 축 ID 배열 (같은 Board안의 축 ID이어야 한다.)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS NUMBER (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  xx = NO COMMON MOTION BOARD AXIS (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::MapAxes (short siAxNum, short *psiMapArray)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdID;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 개수 범위 오류 */
	if ((siAxNum < (DEF_AXIS_NON_NO + 1)) || (siAxNum > (siBdNum * DEF_AXIS_NO_PER_BRD)))
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER

	/** 인수 Pointer 오류 */
	if (psiMapArray == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

	/** 축 ID 범위의 Board가 없음 오류 */
	siBdID = (int)(psiMapArray[0] / DEF_AXIS_NO_PER_BRD);

	for (int i = 0; i < siAxNum; i++)
	{
		if (siBdID != (int)(psiMapArray[i] / DEF_AXIS_NO_PER_BRD))
			return generateErrorCode(106074); // ERR_MLIB_NO_COMMON_MOTION_BOARD_AXIS
	} // Next i

#ifndef SIMULATION
	/** Axes Map 설정 */
	if ((siResult = map_axes(siAxNum, psiMapArray)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("MapAxes(): map_axes(set the axis of coordinates) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC define Map Axis"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 직선, 원, 원호등의 동작을 수행할 각 좌표계의 축을 정의
 * Motion 프로그램 지연과 축 다음 동작 실행 지연 2가지를 제공한다.
 * 지연시간은 1msec 단위이며 0보다 커야 한다.
 *
 * MMC Library : mmcDelay(), mmc_dwell()
 *
 * @param	siAxis			: 축 ID (-1 ~ 63), -1=프로그램지연
 * @param	*plDuration		: 지연시간 (1msec단위)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  xx = INVALID DELAY DURATION (<=0) (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::Dwell (short siAxis, long *plDuration)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER

	/** 인수 Pointer 오류 */
	if (plDuration == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

	/** 지연 시간 범위 오류 */
	if (*plDuration <= 0)
		return generateErrorCode(106107);	// ERR_MLIB_INVALID_DELAY_DURATION

	/** 프로그램 지연 */
	if (siAxis == DEF_AXIS_ALL_ID)
	{
#ifndef SIMULATION
		if ((siResult = mmcDelay(*plDuration)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("Dwell(): mmcDelay(delay the execution of program) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC define Delay Map Axis"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
		Sleep(*plDuration);
#endif
	}
	/** 축 다음 동작 실행 지연 */
	else
	{
#ifndef SIMULATION
		if ((siResult = mmc_dwell(siAxis, *plDuration)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("Dwell(): mmc_dwell(delay the execution of next action) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC define Delay Map Axis"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
		Sleep(*plDuration);
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * I/O Bit가 지정된 상태로 될 때까지 해당 축의 다음 동작 실행을 지연한다.
 * I/O Bit No는 Board 구성 상태에 따라 32개 단위로 변동된다.
 *  (Board#1 : 0 ~ 31, Board #2 : 32 ~ 63, Board #3 : 64 ~ 95, Board #4 : 96 ~ 127)
 *
 * MMC Library : mmc_io_trigger()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siBitNo			: I/O Bit No
 * @param	bState			: I/O Bit 상태
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID BIT IO NUMBER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::IOTrigger (short siAxis, short siBitNo, BOOL bState)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	
	/** I/O Bit No 범위 오류 */
	if ((siBitNo < 0) || (siBdNum < (int)(siBitNo / DEF_MAX_IO_PER_BOARD)))
		return generateErrorCode(106101);	// ERR_MLIB_INVALID_IO_BIT_NUMBER

#ifndef SIMULATION
	/** IO Trigger 지정 */
	if ((siResult = mmc_io_trigger(siAxis, siBitNo, bState)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("IOTrigger(): mmc_io_trigger(delay the execution of next action until I/O bit status changes to %d) Fail[AxisID=%d] - Error# is %d"), 
		//					(int)bState, siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC use IO Trigger"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 축 명령 수행에 대한 상태를 돌려준다.
 * 명령 수행 완료된 상태이면 SUCCESS를 Return한다.
 *
 * MMC Library : in_sequence(), in_motion(), in_position()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siType			: 조회 종류, 0=이동명령, 1=속도명령, 2=InPosition 범위내 여부
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID IN COMMAND TYPE (MOTIONLIB)
 *							  xx = AXIS IS IN COMMAND (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::InCommand (short siAxis, short siType)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	
	/** 축 명령 수행 상태 조회 */
	switch (siType)
	{
	case DEF_INSEQUENCE :	// 이동 명령 상태 조회
#ifndef SIMULATION
		if ((siResult = in_sequence(siAxis)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("MMC return Command Result"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	case DEF_INMOTION :		// 속도 명령 상태 조회
#ifndef SIMULATION
		if ((siResult = in_motion(siAxis)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("MMC return Command Result"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	case DEF_INPOSITION :	// In-Position 범위내 상태 조회
#ifndef SIMULATION
		if ((siResult = in_position(siAxis)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("MMC return Command Result"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
		break;
#endif
	default :
		return generateErrorCode(106103);	// ERR_MLIB_INVALID_IN_COMMAND_TYPE
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 직선, 원, 원호등의 동작이 완료되었는지 여부를 돌려준다.
 * MapAxes()에서 설정한 축들에 대해 확인한다.
 *
 * MMC Library : all_done()
 *
 * @param	*pbStatus		: 완료 여부
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  xx = AXIS IS IN COMMAND (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::AllDone (BOOL *pbStatus)
{
	short siResult = ERR_MOTION_SUCCESS;

	/** 인수 Pointer 오류 */
	if (pbStatus == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

#ifndef SIMULATION
	/** 동작 완료 확인 */
	if ((siResult = all_done()) != ERR_MOTION_SUCCESS)
	{
		*pbStatus = FALSE;
		SetErrorLevel(_T("MMC return Action Complete"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
	else
	{
#endif
		*pbStatus = TRUE;
		return ERR_MOTION_SUCCESS;
#ifndef SIMULATION
	}
#endif
}
/**
 * 축의 동작 완료될 때까지 대기한다.
 * 이동 및 속도 이동 완료 확인 또는 더불어 In-Position 여부까지 확인한다.
 *
 * MMC Library : motion_done(), axis_done()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siMode			: 대기 종류, 0=이동 및 속도이동 완료,
 *										 1=이동 및 속도이동 완료 & InPosition 범위내 이동 완료
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID WAITDONE TYPE (MOTIONLIB)
 *							  xx = AXIS IS IN COMMAND (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::WaitDone(short siAxis, short siMode)
{
	int iResult = ERR_MOTION_SUCCESS;
	short siBdNum;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	/** 동작 완료 확인 */
	switch (siMode)
	{
	case DEF_MOTION_DONE :		// 이동 및 속도이동 완료
#ifndef SIMULATION
		if (motion_done(siAxis))
			iResult = ERR_MOTION_SUCCESS;
		else
		{
			SetErrorLevel(_T("MMC wait for Done"),3, __FILE__, __LINE__);
			iResult = generateErrorCode(106114); // ERR_MLIB_AXIS_IS_IN_COMMAND
		}
#endif
		break;
	case DEF_AXIS_DONE :		// 이동 및 속도이동 완료 & InPosition 범위내 이동 완료
#ifndef SIMULATION
		if (axis_done(siAxis))
			iResult = ERR_MOTION_SUCCESS;
		else
		{
			SetErrorLevel(_T("MMC wait for Done"),3, __FILE__, __LINE__);
			iResult = generateErrorCode(106114); // ERR_MLIB_AXIS_IS_IN_COMMAND
		}
#endif
		break;
	default :
		return generateErrorCode(106075);	// ERR_MLIB_INVALID_WAITDONE_TYPE
	}

	return iResult;
}

/**
 * 축의 동작 완료 여부를 Return 한다. (정헌식 : 2005.01.11)
 * 이동 및 속도 이동 완료 확인 또는 더불어 In-Position 여부까지 확인한다.
 *
 * MMC Library : axis_done()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @return	: TRUE = AXIS_DONE
 *			  FALSE = AXIS IS IN COMMAND (MOTIONLIB)
 */
BOOL MMMCLib::IsAxisDone(short siAxis)
{
#ifndef SIMULATION
		if(axis_done(siAxis))
			return TRUE;
		else
			return FALSE;
#endif

	return TRUE;
}

/**
 * 축의 동작 완료 여부를 Return 한다. (정헌식 : 2005.01.11)
 * 이동 및 속도 이동 완료 확인한다. InPosition 확인 안함
 *
 * MMC Library : axis_done()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @return	: TRUE = AXIS_DONE
 *			  FALSE = AXIS IS IN COMMAND (MOTIONLIB)
 */

BOOL MMMCLib::IsMotionDone(short siAxis)
{
#ifndef SIMULATION
		if(motion_done(siAxis))
			return TRUE;
		else
			return FALSE;
#endif

	return TRUE;
}

/**
 * 지정 축이 동작 완료될 때까지 기다린다.
 * *psiAxis가 NULL로 전달되면 siAxis가 축 ID로 인식되어 동작한다.
 * *psiAxis가 NULL이 아닌걸로 전달되면 siAxis가 축 수로 인식되어 동작한다.
 *
 * MMC Library : wait_for_done(), wait_for_all()
 *
 * @param	siAxis			: 축 ID (0 ~ 63) 혹은 축 수 (1 ~ 64)
 * @param	*psiAxis		: (OPTION=NULL) 축 ID 배열, siAxis가 축 수일 경우 사용
 *																 축 ID라면 생략
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID AXIS NUMBER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::WaitForDone(short siAxis, short *psiAxis)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 인수 Pointer 검사 */
	if (psiAxis == NULL)	// siAxis가 축 ID
	{
		/** 축 ID 범위 오류 */
		if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

#ifndef SIMULATION
		if ((siResult = wait_for_done(siAxis)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("MMC wait for Done"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	else					// siAxis가 축 수
	{
		/** 축 개수 범위 오류 */
		if ((siAxis < (DEF_AXIS_NON_NO + 1)) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD)))
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

		/** 축 ID 범위 오류 */
		for (int i = 0; i < siAxis; i++)
		{
			if ((psiAxis[i] < DEF_AXIS_NON_NO) || (psiAxis[i] > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
				return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}

#ifndef SIMULATION
		if ((siResult = wait_for_all(siAxis, psiAxis)) != ERR_MOTION_SUCCESS)
		{
			SetErrorLevel(_T("MMC wait for Done"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 AMP Fault를 Clear하거나 Fault Port를 Enable 상태로 지정한다.
 *
 * MMC Library : amp_fault_reset(), amp_fault_set()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bState			: 지정할 상태, FALSE=Clear, TRUE=Enable
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAmpFaultEnable(short siAxis, BOOL bState)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	/** 축 AMP Fault Enable 지정 */
	if (bState == TRUE)
	{
#ifndef SIMULATION
		if ((siResult = amp_fault_set(siAxis)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("WaitForDone(): wait_for_done(wait until the movement of an axis is completed) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC set Amp Fault"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** 축 AMP Fault Clear 지정 */
	else
	{
#ifndef SIMULATION
		if ((siResult = amp_fault_reset(siAxis)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("WaitForDone(): Invalid Axis Number(AxisNo=%d is out of range)"), siAxis);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Amp Fault(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 축 모든 현재 상태를 한꺼번에 읽는다.
 * psIstatus[0] = axis_source 함수값
 * psistatus[1] = in_sequence 함수값
 * psistatus[2] = get_com_velocity 함수값
 * psistatus[3] = get_act_velocity 함수값
 * psistatus[4] = motion_done 함수값
 * psistatus[5] = in_position 함수값
 * psistatus[6] = axis_done 함수값
 * 
 * plstatus[0] = get_io 함수값
 * 
 * pdstatus[0] = get_position 함수값
 * pdstatus[1] = get_command 함수값
 * pdstatus[2] = get_error 함수값
 *
 * MMC Library : axis_all_status()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiState		: 상태, (axis_source, in_sequence, get_com_velocity, get_act_velocity,
 *									 motion_done, in_position, axis_done 결과값)
 * @param	*plStatus		: 상태, (get_io 결과값)
 * @param	*pdStatus		: 상태, (get_position, get_command, get_error 결과값)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 */
int MMMCLib::GetAllStatus(short siAxis, short *psiStatus, long *plStatus, double *pdStatus)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	/** 인수 Pointer 오류 */
	if (psiStatus == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

	/** 인수 Pointer 오류 */
	if (plStatus == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

	/** 인수 Pointer 오류 */
	if (pdStatus == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

#ifndef SIMULATION
	/** 축 상태 읽기 */
	if ((siResult = axis_all_status(siAxis, psiStatus, plStatus, pdStatus)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("GetAllStatus(): axis_all_status(read all status of axes) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC get All Status"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	psiStatus[0] = 0x00;
	psiStatus[1] = 0x00;
	psiStatus[2] = 0x00;
	psiStatus[3] = 0x00;
	psiStatus[4] = 0x00;
	psiStatus[5] = 0x00;
	psiStatus[6] = 0x00;
	
	plStatus[0] = 0x00;
	
	pdStatus[0] = 0.00;
	pdStatus[1] = 0.00;
	pdStatus[2] = 0.00;
#endif
	
	return ERR_MOTION_SUCCESS;
}
/**
 * 축 현재 상태를 읽는다.
 *
 * 		ST_NONE					0x0000		정상동작
 * 		ST_HOME_SWITCH			0x0001		원점 센서 감지
 * 		ST_POS_LIMIT			0x0002		+ 방향 센서 감지
 * 		ST_NEG_LIMIT   			0x0004		- 방향 센서 감지
 * 		ST_AMP_FAULT			0x0008		AMP Fault 상태 발생
 * 		ST_A_LIMIT    			0x0010		가, 감속 시간이 limit보다 클 때 발생
 * 		ST_V_LIMIT  			0x0020		현재 속도가 속도 limit을 벗어날 때 발생
 * 		ST_X_NEG_LIMIT 			0x0040		- Position limit을 벗어날 때 발생
 * 		ST_X_POS_LIMIT			0x0080		+ Position limit을 벗어날 때 발생
 * 		ST_ERROR_LIMIT			0x0100		위치오차가 limit값보다 클 때 발생
 * 		ST_PC_COMMAND  			0x0200		EVENT가 발생된 상태일 때 발생
 * 		ST_OUT_OF_FRAMES    	0x0400		Frame Buffer가 Full 상태일 때 발생
 * 		ST_AMP_POWER_ONOFF  	0x0800		AMP Disable 상태일 때 발생
 * 		ST_ABS_COMM_ERROR   	0x1000		ABS Encoder 통신 Error 시 발생
 * 		ST_INPOSITION_STATUS	0x2000		??
 * 		ST_RUN_STOP_COMMAND 	0x4000 		??
 * 		ST_COLLISION_STATE  	0x8000		??
 *
 * MMC Library : axis_source()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiState		: 상태, 각 상태는 bit 조합으로 구성된다.
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 */
int MMMCLib::GetAxisSource(short siAxis, short *psiState)
{
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	/** 인수 Pointer 오류 */
	if (psiState == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

#ifndef SIMULATION
	/** 축 상태 읽기 */
	*psiState = axis_source(siAxis);
#else
	*psiState = 0x00;
#endif
	
	return ERR_MOTION_SUCCESS;
}

/**
 * 해동축의 동작중 속도명령값을 PULSE값으로 돌려준다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @return	Puls
 */
int MMMCLib::GetComVelocity(short siAxis)
{
	short siBdNum;
	CString strLogMsg;
	
	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	return get_com_velocity(siAxis);
}

/**
 * 축의 센서(Home, Positive, Negative) 상태를 읽는다.
 *
 * MMC Library : home_switch(), pos_switch(), neg_switch()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siType			: 센서 종류, 0=Home, 1=Positive, 2=Negative
 * @param	*pbState		: 센서 상태, TRUE=Active, FALSE=No Active
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  xx = INVALID SENSOR TYPE (MOTIONLIB)
 */
int MMMCLib::GetSensorStatus(short siAxis, short siType, BOOL *pbState)
{
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	/** 인수 Pointer 오류 */
	if (pbState == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

	/** Sensor 상태 읽기 */
	switch (siType)
	{
	case DEF_HOME_SENSOR :		// Home Sensor
#ifndef SIMULATION
		if (home_switch(siAxis) == FALSE)
			*pbState = FALSE;
		else
			*pbState = TRUE;
#else
		*pbState = FALSE;
#endif
		break;
	case DEF_POSITIVE_SENSOR :	// Positive Sensor
#ifndef SIMULATION
		if (pos_switch(siAxis) == FALSE)
			*pbState = FALSE;
		else
			*pbState = TRUE;
#else
		*pbState = FALSE;
#endif
		break;
	case DEF_NEGATIVE_SENSOR :	// Negative Sensor
#ifndef SIMULATION
		if (neg_switch(siAxis) == FALSE)
			*pbState = FALSE;
		else
			*pbState = TRUE;
#else
		*pbState = FALSE;
#endif
		break;
	default :
		return generateErrorCode(106079);	// ERR_MLIB_INVALID_SENSOR_TYPE
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * AMP Disable/Enable 상태를 읽는다. (Servo ON/OFF)
 *
 * MMC Library : get_amp_enable()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbState		: AMP Enable 상태, TRUE=Enable, FALSE=Disable
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAmpEnable(short siAxis, BOOL *pbState)
{
	int		iResult = ERR_MOTION_SUCCESS;
	short	siState = 0;
	short	siBdNum;
	CString	strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	/** 인수 Pointer 오류 */
	if (pbState == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

	/** AMP Enable 상태 읽기 */
// State까지 반영되어 Source에서 읽는걸로 수정함. 20040329
//	if ((siResult = get_amp_enable(siAxis, &siState)) != ERR_MOTION_SUCCESS)
//		return siResult;

	if ((iResult = GetAxisSource(siAxis, &siState)) != ERR_MOTION_SUCCESS)
		return iResult;

	if ((siState & DEF_ST_AMP_POWER_ONOFF) != DEF_ST_AMP_POWER_ONOFF)
		*pbState = DEF_ENABLE;
	else
		*pbState = DEF_DISABLE;

	return ERR_MOTION_SUCCESS;
}
/**
 * AMP Enable의 Active Level을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_amp_enable_level(), fget_amp_enable_level()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbLevel		: Enable Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAmpEnableLevel(short siAxis, BOOL *pbLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siLevel = DEF_LOW;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	/** 인수 Pointer 오류 */
	if (pbLevel == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축의 AMP Driver에 Enable의 Active Level 설정 읽기 */
		if ((siResult = fget_amp_enable_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAmpEnableLevel(): fget_amp_enable_level(get AMP Enable Level from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Amp Enable Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
		siLevel = DEF_LOW;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축의 AMP Driver에 Enable의 Active Level 설정 읽기 */
		if ((siResult = get_amp_enable_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAmpEnableLevel(): get_amp_enable_level(get AMP Enable Level from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Amp Enable Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
		siLevel = DEF_LOW;
#endif
	}

	if (siLevel == DEF_LOW)
		*pbLevel = DEF_LOW;
	else
		*pbLevel = DEF_HIGH;

	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 현재 Event 발생 상태를 읽는다.
 *
 *		NO_EVENT		0		Event 발생없이 정상 동작
 *		STOP_EVENT		1		stop_rate로 감속하면서 정지
 *		E_STOP_EVENT	2		e_stop_rate로 감속하면서 정지
 *		ABORT_EVENT		3		AMP disable 상태
 *
 * MMC Library : axis_state()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiState		: Event 내역, 0=NO EVENT, 1=STOP EVENT, 2=ESTOP EVENT, 3=ABORT EVENT
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 */
int MMMCLib::GetAxisState(short siAxis, short *psiState)
{
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	/** 인수 Pointer 오류 */
	if (psiState == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

#ifndef SIMULATION
	/** 축 Event 발생 내역 읽기 */
	*psiState = axis_state(siAxis);
#else
	*psiState = 0x00;
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * Board의 Position Latch 여부를 읽는다.
 *
 * MMC Library : latch_status()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	*pbState		: Position Latch 여부, TRUE=Latch상태
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 */
int MMMCLib::GetAxisLatchStatus(short siBdNum, BOOL *pbState)
{
	short	siBdNumber;
	CString	strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID

	/** 인수 Pointer 오류 */
	if (pbState == NULL)
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER

#ifndef SIMULATION
	/** 축 Event 발생 내역 읽기 */
	if (latch_status(siBdNum) == FALSE)
		*pbState = FALSE;
	else
		*pbState = TRUE;
#else
	*pbState = FALSE;
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 축에 발생된 Event를 해제하고, 다음 명령부터 실행한다.
 * Event 발생 후에는 항상 Event를 해제해 주어야 한다.
 * ABORT_EVENT 발생 시에는 Event 해제 후 AMP가 Disable 상태이므로 다시 Enable해주어야 한다.
 *
 * MMC Library : clear_status()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::ClearStatus(short siAxis)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

#ifndef SIMULATION
	/** 축 발생 Event 해제 */
	if ((siResult = clear_status(siAxis)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("ClearStatus(): clear_status(clear all events) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC clear State(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 Frame Buffer를 Clear한다.
 * 축별 최대 50개의 Frame의 내용을 Clear한다. 단 현재 실행중인 명령은 계속 수행된다.
 *
 * MMC Library : frames_clear()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::ClearFrames(short siAxis)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

#ifndef SIMULATION
	/** 축 발생 Event 해제 */
	if ((siResult = frames_clear(siAxis)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("ClearFrames(): frames_clear(clear frame buffers) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC clear Frame(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 비어있는 Interpolation Frame 개수를 돌려준다.
 *
 * MMC Library : frames_interpolation()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiFrameNo		: Frame 개수
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 */
int MMMCLib::FramesInterpolation(short siAxis, short *psiFrameNo)
{
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID

	/** 인수 Pointer 오류 */
	if (psiFrameNo == NULL)
	{
		//WriteErrorLog("FramesInterpolation(): psiFrameNo Pointer is NULL");
		strLogMsg.Format(_T("MMC count Empty Interpolation Frame(AxisID=%d)"), siAxis);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** 축 Interpolation Frame 개수 읽기 */
	*psiFrameNo = frames_interpolation(siAxis);
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 비어있는 Frame 개수를 돌려준다.
 *
 * MMC Library : frames_left()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiFrameNo		: 비어있는 Frame 개수
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 */
int MMMCLib::FramesLeft(short siAxis, short *psiFrameNo)
{
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("FramesLeft(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC count Empty Frame(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiFrameNo == NULL)
	{
		//WriteErrorLog("FramesLeft(): psiFrameNo Pointer is NULL");
		strLogMsg.Format(_T("MMC count Empty Frame(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** 축 Interpolation Frame 개수 읽기 */
	*psiFrameNo = frames_left(siAxis);
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 Board의 Latch 상태를 지정하고, Latch Status를 False로 만들거나, S/W적으로 Position을 Latch한다.
 *
 * MMC Library : latch(), arm_latch()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	bType			: Latch 종류, FALSE=S/W Position Latch, TRUE=Board Latch Enable/Disable 지정
 * @param	bState			: (OPTION=FALSE) bType=TRUE인 경우 Enable/Disable 지정
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::Latch(short siBdNum, BOOL bType, BOOL bState)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("Latch(): Invalid Board ID(BoardID=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Latch Status(Board ID =%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

	/** S/W Position Latch */
	if (bType == 0)
	{
#ifndef SIMULATION
		if ((siResult = latch(siBdNum)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("Latch(): latch(latch the position through S/W) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Latch Status(Board ID =%d)"), siBdNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** Board Latch Enable/Disable */
	else
	{
#ifndef SIMULATION
		if ((siResult = arm_latch(siBdNum, bState)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("Latch(): arm_latch(set latch status) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Latch Status(Board ID =%d)"), siBdNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 Latch된 Position을 돌려준다.
 *
 * MMC Library : get_latched_position()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pdPosition		: Latch된 Position
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetLatchedPosition(short siAxis, double *pdPosition)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetLatchedPosition(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Latch Position(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdPosition == NULL)
	{
		//WriteErrorLog("GetLatchedPosition(): pdPosition Pointer is NULL");
		strLogMsg.Format(_T("MMC get Latch Position(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** Latch된 Position 읽기 */
	if ((siResult = get_latched_position(siAxis, pdPosition)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("GetLatchedPosition(): get_latched_position Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Latch Position(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	*pdPosition = 0.00;
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 동작중 목표위치를 재지정할 때 사용한다. (원, 원호 동작중에는 적용되지 않는다.)
 *
 * MMC Library : compensation_pos()
 *
 * @param	siLen			: 축 수
 * @param	*psiAxes		: 축 ID 배열
 * @param	*pdDist			: 위치 보정값
 * @param	*psiAccel		: 이동 가,감속 구간
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS NUMBER (<=0) (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::CompensationPos(short siLen, short *psiAxes, double *pdDist, short *psiAccel)
{
	short siResult = ERR_MOTION_SUCCESS;
	double rgdDist[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 축 개수 범위 오류 */
	if (siLen <= DEF_AXIS_NON_NO)
	{
		//strLogMsg.Format(_T("CompensationPos(): Invalid Axis Number(AxisNo=%d is out of range)"), siLen);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC reset Target Position"),3, __FILE__, __LINE__);
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER
	}

	/** 인수 Pointer 오류 */
	if (psiAxes == NULL)
	{
		//WriteErrorLog("CompensationPos(): psiAxes Pointer is NULL");
		SetErrorLevel(_T("MMC reset Target Position"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pdDist == NULL)
	{
		//WriteErrorLog("CompensationPos(): pdDist Pointer is NULL");
		SetErrorLevel(_T("MMC reset Target Position"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (psiAccel == NULL)
	{
		//WriteErrorLog("CompensationPos(): psiAccel Pointer is NULL");
		SetErrorLevel(_T("MMC reset Target Position"),3, __FILE__, __LINE__);
		return generateErrorCode(106090); // ERR_MLIB_INVALID_POINTER
	}

	// **1202 -> msec 단위로 수정
	short *psiTempAccel;

	psiTempAccel = new short[siLen];
	for (int i=0; i<siLen; i++)
	psiTempAccel[i] = (short)psiAccel[i]/4;

	/** Value 반올림 */
	for (int i=0; i<siLen; i++)
		rgdDist[i] = motionRoundValue(*(pdDist+i));

#ifndef SIMULATION
	/** 동작중 목표위치 재지정 */
	if ((siResult = compensation_pos(siLen, psiAxes, pdDist, psiTempAccel)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("compensation_pos(): compensation_pos(re-assign a target pos) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC reset Target Position"),3, __FILE__, __LINE__);
		delete[] psiTempAccel;
		return makeMMCError((int)siResult);
	}
#endif

	delete[] psiTempAccel;

	return ERR_MOTION_SUCCESS;
}
/**
 * Board DPRAM Address를 읽는다.
 *
 * MMC Library : get_dpram_addr()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	*plAddr			: DPRAM Address
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetDpramAddress(short siBdNum, long *plAddr)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("GetDpramAddress(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get DPRAM Address(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

#ifndef SIMULATION
	/** DPRAM Address 읽기 */
	if ((siResult = get_dpram_addr(siBdNum, plAddr)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("GetDpramAddress(): get_dpram_addr Fail[BoardID=%d] - Error# is %d"), siBdNum, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get DPRAM Address(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	*plAddr = 0xd8000000;
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 절대치 Motor의 Type을 읽는다.
 *
 * MMC Library : get_abs_encoder_type()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiType		: Motor 종류, 1=삼성CSDJ, CSDJ+SERVO DRIVE, 2=YASKAWA SERVO DRIVE
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAbsEncoderType(short siAxis, short *psiType)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetAbsEncoderType(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Absolute Encoder Type(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiType == NULL)
	{
		//WriteErrorLog("GetAbsEncoderType(): psiType Pointer is NULL");
		strLogMsg.Format(_T("MMC get Absolute Encoder Type(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** 절대치 Motor 종류 읽기 */
	if ((siResult = get_abs_encoder_type(siAxis, psiType)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("GetAbsEncoderType(): get_abs_encoder_type(get a type of an absolute motor) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Absolute Encoder Type(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	*psiType = 1;
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 이동 최고속도와 가,감속 구간값의 제한값을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_accel_limit(), fget_accel_limit(), get_vel_limit(), fget_vel_limit()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pdVelocity		: 이동 최고속도, 1 ~ 2047000 coutn/sec
 * @param	*psiAccel		: 가,감속 구간값, 1 ~ 200, 10msec 단위
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetVelLimit(short siAxis, double *pdVelocity, short *psiAccel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetVelLimit(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Velocity Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdVelocity == NULL)
	{
		//WriteErrorLog("GetVelLimit(): pdVelocity Pointer is NULL");
		strLogMsg.Format(_T("MMC get Velocity Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (psiAccel == NULL)
	{
		//WriteErrorLog("GetVelLimit(): psiAccel Pointer is NULL");
		strLogMsg.Format(_T("MMC get Velocity Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 제한 속도 읽기 */
		if ((siResult = fget_vel_limit(siAxis, pdVelocity)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetVelLimit(): fget_vel_limit(get a velocity limit from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Velocity Limit(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 제한 가,감속도 읽기 */
		if ((siResult = fget_accel_limit(siAxis, psiAccel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetVelLimit(): fget_accel_limit(get a accelerate limit from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Velocity Limit(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*pdVelocity = 2047000.0;
	*psiAccel = 200;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 제한 속도 읽기 */
		if ((siResult = get_vel_limit(siAxis, pdVelocity)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetVelLimit(): get_vel_limit(get a velocity limit from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Velocity Limit(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 제한 가,감속도 읽기 */
		if ((siResult = get_accel_limit(siAxis, psiAccel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetVelLimit(): get_accel_limit(get a accelerate limit from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Velocity Limit(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*pdVelocity = 2047000.0;
	*psiAccel = 200;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * AMP Drive에 Fault 발생 상태를 읽는다.
 *
 * MMC Library : amp_fault_switch()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbStatus		: AMP Fault 상태를 읽는다. TRUE=FAULT, FALSE=NORMAL
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 */
int MMMCLib::GetAmpFaultStatus(short siAxis, BOOL *pbStatus)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetAmpFaultStatus(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Amp Fault Status(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pbStatus == NULL)
	{
		//WriteErrorLog("GetAmpFaultStatus(): pbStatus Pointer is NULL");
		strLogMsg.Format(_T("MMC get Amp Fault Status(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** 축 AMP Fault 상태 읽기 */
	if (amp_fault_switch(siAxis) == ERR_MOTION_SUCCESS)
		*pbStatus = FALSE;
	else
		*pbStatus = TRUE;
#else
	*pbStatus = FALSE;
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * AMP Drive에 Fault 발생 시 동작할 Event를 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_amp_fault(), fget_amp_fault()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiAction		: 동작할 Event, NO EVENT, STOP EVENT, ESTOP EVENT, ABORT EVENT
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAmpFaultEvent(short siAxis, short *psiAction, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetAmpFaultEvent(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Amp Fault Event(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiAction == NULL)
	{
		//WriteErrorLog("GetAmpFaultEvent(): psiAction Pointer is NULL");
		strLogMsg.Format(_T("MMC get Amp Fault Event(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 AMP Fault Event 설정 읽기 */
		if ((siResult = fget_amp_fault(siAxis, psiAction)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAmpFaultEvent(): fget_amp_fault(get AMP Fault Event from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Amp Fault Event(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiAction = 0x00;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 AMP Fault Event 설정 읽기 */
		if ((siResult = get_amp_fault(siAxis, psiAction)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAmpFaultEvent(): get_amp_fault(get AMP Fault Event from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Amp Fault Event(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiAction = 0x00;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * AMP Enable의 Active Level을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_amp_enable_level(), fget_amp_enable_level()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbLevel		: Enable 신호 Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAmpEanbleLevel(short siAxis, BOOL *pbLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siLevel = 0;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetAmpFaultLevel(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Amp Enable Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pbLevel == NULL)
	{
		//WriteErrorLog("GetAmpFaultLevel(): pbLevel Pointer is NULL");
		strLogMsg.Format(_T("MMC get Amp Enable Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 AMP Enable Level 설정 읽기 */
		if ((siResult = fget_amp_enable_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAmpFaultLevel(): fget_amp_fault_level(get AMP Fault Level from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Amp Enable Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siLevel = DEF_LOW;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 AMP Enable Level 설정 읽기 */
		if ((siResult = get_amp_enable_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAmpFaultLevel(): get_amp_fault_level(get AMP Fault Level from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Amp Enable Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siLevel = DEF_LOW;
#endif
	}

	if (siLevel == DEF_LOW)
		*pbLevel = DEF_LOW;
	else
		*pbLevel = DEF_HIGH;

	return ERR_MOTION_SUCCESS;
}
/**
 * AMP Fault의 Active Level을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_amp_fault_level(), fget_amp_fault_level()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbLevel		: Fault 신호 Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAmpFaultLevel(short siAxis, BOOL *pbLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siLevel = 0;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetAmpResetLevel(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Amp Fault Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pbLevel == NULL)
	{
		//WriteErrorLog("GetAmpResetLevel(): pbLevel Pointer is NULL");
		strLogMsg.Format(_T("MMC get Amp Fault Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 AMP Fault Level 설정 읽기 */
		if ((siResult = fget_amp_fault_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAmpResetLevel(): fget_amp_reset_level(get AMP Reset Level from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Amp Fault Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siLevel = DEF_LOW;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 AMP Fault Level 설정 읽기 */
		if ((siResult = get_amp_fault_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAmpResetLevel(): get_amp_reset_level(get AMP Reset Level from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Amp Fault Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siLevel = DEF_LOW;
#endif
	}

	if (siLevel == DEF_LOW)
		*pbLevel = DEF_LOW;
	else
		*pbLevel = DEF_HIGH;

	return ERR_MOTION_SUCCESS;
}
/**
 * AMP Reset의 Active Level을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_amp_reset_level(), fget_amp_reset_level()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbLevel		: Reset 신호 Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAmpResetLevel(short siAxis, BOOL *pbLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siLevel = 0;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetAmpResolution(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Amp Reset Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pbLevel == NULL)
	{
		//WriteErrorLog("GetAmpResolution(): psiResolution Pointer is NULL");
		strLogMsg.Format(_T("MMC get Amp Reset Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 AMP Reset Level 설정 읽기 */
		if ((siResult = fget_amp_reset_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAmpResolution(): fget_amp_resolution(get AMP Resolution from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Amp Reset Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siLevel = DEF_LOW;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 AMP Reset Level 설정 읽기 */
		if ((siResult = get_amp_reset_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAmpResolution(): get_amp_resolution(get AMP Resolution from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Amp Reset Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siLevel = DEF_LOW;
#endif
	}

	if (siLevel == DEF_LOW)
		*pbLevel = DEF_LOW;
	else
		*pbLevel = DEF_HIGH;

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 AMP Drive의 Resolution을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_amp_resolution(), fget_amp_resolution()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiResolution	: AMP Resolution, default=2500 pulse/rev
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAmpResolution(short siAxis, short *psiResolution, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetAmpResolution(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Amp Resolution(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiResolution == NULL)
	{
		//WriteErrorLog("GetAmpResolution(): psiResolution Pointer is NULL");
		strLogMsg.Format(_T("MMC get Amp Resolution(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 AMP Resolution 설정 읽기 */
		if ((siResult = fget_amp_resolution(siAxis, psiResolution)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAmpResolution(): fget_amp_resolution(get AMP Resolution from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Amp Resolution(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiResolution = 2500;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 AMP Resolution 설정 읽기 */
		if ((siResult = get_amp_resolution(siAxis, psiResolution)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAmpResolution(): get_amp_resolution(get AMP Resolution from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Amp Resolution(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiResolution = 2500;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 분주비에 대한 분자값, 분모값을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiRatioA		: Encoder 분주비 분자값
 * @param	*psiRatioB		: Encoder 분주비 분모값
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID DENOMINATOR (<1) (MOTIONLIB)
 *							  xx = INVALID MOLECULE (<1) (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetEncoderRatio(short siAxis, short *psiRatioA, short *psiRatioB, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetEncoderRatio(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Encoder Ratio(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiRatioA == NULL)
	{
		//WriteErrorLog("GetEncoderRatio(): psiRatioA Pointer is NULL");
		strLogMsg.Format(_T("MMC get Encoder Ratio(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (psiRatioB == NULL)
	{
		//WriteErrorLog("GetEncoderRatio(): psiRatioB Pointer is NULL");
		strLogMsg.Format(_T("MMC get Encoder Ratio(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 분주비 분자값 설정 */
		if ((siResult = fget_encoder_ratioa(siAxis, psiRatioA)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetEncoderRatio(): fget_encoder_ratioa(get a numerator of an encoder ratio from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Encoder Ratio(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 분주비 분모값 설정 */
		if ((siResult = fget_encoder_ratiob(siAxis, psiRatioB)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetEncoderRatio(): fget_encoder_ratiob(get a denominator of an encoder ratio from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Encoder Ratio(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiRatioA = 1;
	*psiRatioB = 1;
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 분주비 분자값 설정 */
		if ((siResult = get_encoder_ratioa(siAxis, psiRatioA)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetEncoderRatio(): get_encoder_ratioa(get a numerator of an encoder ratio from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Encoder Ratio(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 분주비 분모값 설정 */
		if ((siResult = get_encoder_ratiob(siAxis, psiRatioB)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetEncoderRatio(): get_encoder_ratioa(get a denominator of an encoder ratio from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Encoder Ratio(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiRatioA = 1;
	*psiRatioB = 1;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축이 회전/직선운동하는 무한회전 축인지 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_endless_linearax(), fget_endless_linearax(),
 *				 get_endless_rotationax(), fget_endless_rotationax()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbStatus		: 무한회전 축 설정여부
 * @param	bType			: 운동 종류, FALSE=직선, TRUE=회전
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetEndlessAx(short siAxis, BOOL *pbStatus, BOOL bType, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siStatus = 0;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetEndlessAx(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Endless Axis(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pbStatus == NULL)
	{
		//WriteErrorLog("GetEndlessAx(): pbStatus Pointer is NULL");
		strLogMsg.Format(_T("MMC get Endless Axis(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}
	
	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
		/** 회전 운동 */
		if (bType == TRUE)
		{
#ifndef SIMULATION
			/** 축 회전운동 무한회전 설정 읽기 */
			if ((siResult = fget_endless_rotationax(siAxis, &siStatus)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetEndlessAx(): fget_endless_rotationax(get an establishment of endless rotation from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Endless Axis(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siStatus = 0;
#endif
		}
		/** 직선 운동 */
		else
		{
#ifndef SIMULATION
			/** 축 직선운동 무한회전 설정 읽기 */
			if ((siResult = fget_endless_linearax(siAxis, &siStatus)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetEndlessAx(): fget_endless_linearax(get an establishment of endless linear rotation from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Endless Axis(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siStatus = 0;
#endif
		}
	}
	/** memory에서 축 설정 읽기 */
	else
	{
		/** 회전 운동 */
		if (bType == TRUE)
		{
#ifndef SIMULATION
			/** 축 회전운동 무한회전 설정 읽기 */
			if ((siResult = get_endless_rotationax(siAxis, &siStatus)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetEndlessAx(): get_endless_rotationax(get an establishment of endless rotation from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Endless Axis(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siStatus = 0;
#endif
		}
		/** 직선 운동 */
		else
		{
#ifndef SIMULATION
			/** 축 직선운동 무한회전 설정 읽기 */
			if ((siResult = get_endless_linearax(siAxis, &siStatus)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetEndlessAx(): get_endless_linearax(get an establishment of endless linear rotation from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Endless Axis(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siStatus = 0;
#endif
		}
	}

	if (siStatus == FALSE)
		*pbStatus = FALSE;
	else
		*pbStatus = TRUE;

	return ERR_MOTION_SUCCESS;
}
/**
 * 무한회전 축의 움직이는 영역을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_endless_range(), fget_endless_range(),
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pdRange		: 이동 영역
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetEndlessRange(short siAxis, double *pdRange, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetEndlessRange(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Endless Axis Range(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdRange == NULL)
	{
		//WriteErrorLog("GetEndlessRange(): pdRange Pointer is NULL");
		strLogMsg.Format(_T("MMC get Endless Axis Range(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 무한회전 영역 설정 읽기 */
		if ((siResult = fget_endless_range(siAxis, pdRange)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetEndlessRange(): fget_endless_range(get an establishment of endless rotation range from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Endless Axis Range(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*pdRange = 0.0;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 무한회전 영역 설정 읽기 */
		if ((siResult = get_endless_range(siAxis, pdRange)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetEndlessRange(): get_endless_range(get an establishment of endless rotation range from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Endless Axis Range(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*pdRange = 0.0;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 위치결정 완료값과 위치결정 시 신호 Level을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_in_position(), fget_in_position(),
 *				 get_inposition_level(), fget_inposition_level()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pdInPosition	: 위치 결정값
 * @param	*pbLevel		: 신호 Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetInPosition(short siAxis, double *pdInPosition, BOOL *pbLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siLevel = DEF_LOW;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetInPosition(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get In-Position(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdInPosition == NULL)
	{
		//WriteErrorLog("GetInPosition(): pdInPosition Pointer is NULL");
		strLogMsg.Format(_T("MMC get In-Position(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pbLevel == NULL)
	{
		//WriteErrorLog("GetInPosition(): pbLevel Pointer is NULL");
		strLogMsg.Format(_T("MMC get In-Position(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 In-Position 위치 범위 설정 읽기 */
		if ((siResult = fget_in_position(siAxis, pdInPosition)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetInPosition(): fget_in_position(get 'in_position' value from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get In-Position(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 축 In-Position Active Level 설정 읽기 */
		if ((siResult = fget_inposition_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetInPosition(): fget_inposition_level(get 'in_position' level from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get In-Position(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*pdInPosition = 10.0;
	siLevel = DEF_LOW;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 In-Position 위치 범위 설정 읽기 */
		if ((siResult = get_in_position(siAxis, pdInPosition)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetInPosition(): get_in_position(get 'in_position' value from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get In-Position(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 축 In-Position Active Level 설정 읽기 */
		if ((siResult = get_inposition_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetInPosition(): get_inposition_level(get 'in_position' level from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get In-Position(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*pdInPosition = 10.0;
	siLevel = DEF_LOW;
#endif
	}

	if (siLevel == DEF_LOW)
		*pbLevel = DEF_LOW;
	else
		*pbLevel = DEF_HIGH;

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 InPosition 신호 사용여부를 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_inposition_required(), fget_inposition_required()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbReq			: 사용 여부, TRUE=사용
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetInpositionRequired(short siAxis, BOOL *pbReq, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siReq = 0;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetInpositionRequired(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get In-Position Required(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pbReq == NULL)
	{
		//WriteErrorLog("GetInpositionRequired(): pbReq Pointer is NULL");
		strLogMsg.Format(_T("MMC get In-Position Required(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 In-Position 사용 여부 설정 읽기 */
		if ((siResult = fget_inposition_required(siAxis, &siReq)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetInpositionRequired(): fget_inposition_required(get an establishment of 'in_position' from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get In-Position Required(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siReq = 0;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 In-Position 사용 여부 설정 읽기 */
		if ((siResult = get_inposition_required(siAxis, &siReq)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetInpositionRequired(): get_inposition_required(get an establishment of 'in_position' from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get In-Position Required(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siReq = 0;
#endif
	}

	if (siReq == FALSE)
		*pbReq = FALSE;
	else
		*pbReq = TRUE;

	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 위치오차 제한값과 Event를 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_error_limit(), fget_error_limit()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pdLimit		: 위치오차 제한값, 최대 35000 count
 * @param	*psiAction		: 위치오차 Event, NO EVENT, ESTOP EVENT, ABORT EVENT
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetErrorLimit(short siAxis, double *pdLimit, short *psiAction, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetErrorLimit(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Error Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdLimit == NULL)
	{
		//WriteErrorLog("GetErrorLimit(): pdLimit Pointer is NULL");
		strLogMsg.Format(_T("MMC get Error Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (psiAction == NULL)
	{
		//WriteErrorLog("GetErrorLimit(): psiAction Pointer is NULL");
		strLogMsg.Format(_T("MMC get Error Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 위치오차 제한값과 Event 설정 읽기 */
		if ((siResult = fget_error_limit(siAxis, pdLimit, psiAction)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetErrorLimit(): fget_error_limit(get an error limit & event from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Error Limit(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiAction = 0x00;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 위치오차 제한값과 Event 설정 읽기 */
		if ((siResult = get_error_limit(siAxis, pdLimit, psiAction)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetErrorLimit(): get_error_limit(get an error limit & event from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Error Limit(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiAction = 0x00;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 원점 복귀 시 Encoder의 C상 펄스 이용 여부를 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_index_required(), fget_index_required()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbIndexReq		: C상 펄스 사용 여부, TRUE=Home Sensor와 Encoder의 Index Pulse를 동시 검출,
 *												  FALSE=Home Sensor만 검출
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetIndexRequired(short siAxis, BOOL *pbIndexReq, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siIndexReq = 0;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetIndexRequired(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get C Phase Pulse Required(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pbIndexReq == NULL)
	{
		//WriteErrorLog("GetIndexRequired(): pbIndexReq Pointer is NULL");
		strLogMsg.Format(_T("MMC get C Phase Pulse Required(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 C상 펄스 사용 여부 설정 읽기 */
		if ((siResult = fget_index_required(siAxis, &siIndexReq)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetIndexRequired(): fget_index_required(get an establishment of C pulse from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get C Phase Pulse Required(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siIndexReq = 0;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 C상 펄스 사용 여부 설정 읽기 */
		if ((siResult = get_index_required(siAxis, &siIndexReq)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetIndexRequired(): get_index_required(get an establishment of C pulse from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get C Phase Pulse Required(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siIndexReq = 0;
#endif
	}

	if (siIndexReq == FALSE)
		*pbIndexReq = FALSE;
	else
		*pbIndexReq = TRUE;

	return ERR_MOTION_SUCCESS;
}
/**
 * I/O 8점에 대한  입,출력 모드를 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_io_mode(), fget_io_mode()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	*pbMode			: 입, 출력 모드, TRUE=출력, FALSE=입력
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetIOMode(short siBdNum, BOOL *pbMode, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siMode = FALSE;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("GetIOMode(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get IO Mode(BoardNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

	/** 인수 Pointer 오류 */
	if (pbMode == NULL)
	{
		//WriteErrorLog("GetIOMode(): pbMode Pointer is NULL");
		strLogMsg.Format(_T("MMC get IO Mode(BoardNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 I/O 입,출력모드 설정 읽기 */
		if ((siResult = fget_io_mode(siBdNum, &siMode)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetIOMode(): fget_io_mode(get an I/O mode from boot file) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get IO Mode(BoardNo=%d)"), siBdNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siMode = 0;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 I/O 입,출력모드 설정 읽기 */
		if ((siResult = get_io_mode(siBdNum, &siMode)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetIOMode(): get_io_mode(get an I/O mode from memory) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get IO Mode(BoardNo=%d)"), siBdNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siMode = 0;
#endif
	}

	if (siMode == FALSE)
		*pbMode = FALSE;
	else
		*pbMode = TRUE;

	return ERR_MOTION_SUCCESS;
}
/**
 * Home, +/- 방향 Limit Switch Active시 동작할 Event와 신호 Level을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_home_level(), fget_home_level(),
 *				 get_home(), fget_home(),
 *				 get_negative_level(), fget_negative_level(),
 *				 get_negative_limit(), fget_negative_limit(),
 *				 get_positive_level(), fget_positive_level(),
 *				 get_positive_limit(), fget_positive_limit()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siType			: Sensor 종류, 0=Home, 1=Positive, 2=Negative
 * @param	*psiLimit		: 동작할 Event
 * @param	*pbLevel		: 신호 Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  xx = INVALID SENSOR TYPE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetSensorLimit(short siAxis, short siType, short *psiLimit, BOOL *pbLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siLevel = DEF_LOW;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetSensorLimit(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiLimit == NULL)
	{
		//WriteErrorLog("GetSensorLimit(): psiLimit Pointer is NULL");
		strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pbLevel == NULL)
	{
		//WriteErrorLog("GetSensorLimit(): pbLevel Pointer is NULL");
		strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	switch (siType)
	{
	case DEF_HOME_SENSOR :		// Home Sensor
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Home Sensor Active Level 설정 읽기 */
			if ((siResult = fget_home_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorLimit(): fget_home_level(get an Active Level of home sensor from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}

			/** 축 Home Sensor Event 설정 읽기 */
			if ((siResult = fget_home(siAxis, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorLimit(): fget_home(get an event when an axis arrives at home sensor from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siLevel = DEF_LOW;
	*psiLimit = 0x00;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 Home Sensor Active Level 설정 읽기 */
			if ((siResult = get_home_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorLimit(): get_home_level(get an Active Level of home sensor from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}

			/** 축 Home Sensor Event 설정 읽기 */
			if ((siResult = get_home(siAxis, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorLimit(): get_home(get an event when an axis arrives at home sensor from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siLevel = DEF_LOW;
	*psiLimit = 0x00;
#endif
		}
		break;
	case DEF_POSITIVE_SENSOR :	// Positive Sensor
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Home Sensor Active Level 설정 읽기 */
			if ((siResult = fget_positive_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorLimit(): fget_positive_level(get an Active Status of positive sensor from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}

			/** 축 Home Sensor Event 설정 읽기 */
			if ((siResult = fget_positive_limit(siAxis, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorLimit(): fget_positive_limit(get an event when positive sensor is Active from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siLevel = DEF_LOW;
	*psiLimit = 0x00;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 Home Sensor Active Level 설정 읽기 */
			if ((siResult = get_positive_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorLimit(): get_positive_level(get an Active Status of positive sensor from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}

			/** 축 Home Sensor Event 설정 읽기 */
			if ((siResult = get_positive_limit(siAxis, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorLimit(): get_positive_limit(get an event when positive sensor is Active from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siLevel = DEF_LOW;
	*psiLimit = 0x00;
#endif
		}
		break;
	case DEF_NEGATIVE_SENSOR :	// Negative Sensor
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Negative Sensor Active Level 설정 읽기 */
			if ((siResult = fget_negative_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorLimit(): fget_negative_level(get an Active Status of negative sensor from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}

			/** 축 Negative Sensor Event 설정 읽기 */
			if ((siResult = fget_negative_limit(siAxis, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorLimit(): fget_negative_limit(get an event when negative sensor is Active from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siLevel = DEF_LOW;
	*psiLimit = 0x00;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 Negative Sensor Active Level 설정 읽기 */
			if ((siResult = get_negative_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorLimit(): get_negative_level(get an Active Status of negative sensor from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}

			/** 축 Negative Sensor Event 설정 읽기 */
			if ((siResult = get_negative_limit(siAxis, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorLimit(): get_negative_limit(get an event when negative sensor is Active from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siLevel = DEF_LOW;
	*psiLimit = 0x00;
#endif
		}
		break;
	default :
		strLogMsg.Format(_T("MMC get Sensor Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106079);	// ERR_MLIB_INVALID_SENSOR_TYPE
	}

	if (siLevel == DEF_LOW)
		*pbLevel = DEF_LOW;
	else
		*pbLevel = DEF_HIGH;

	return ERR_MOTION_SUCCESS;
}

/**
 * Home, +/- 방향 Limit Switch Active시 동작할 Event를 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siType			: Sensor 종류, 0=Home, 1=Positive, 2=Negative
 * @param	*psiLimit		: 동작할 Event
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  xx = INVALID SENSOR TYPE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetSensorEvent(short siAxis, short siType, short *psiLimit, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetSensorEvent(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Sensor Event(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiLimit == NULL)
	{
		//WriteErrorLog("GetSensorEvent(): psiLimit Pointer is NULL");
		strLogMsg.Format(_T("MMC get Sensor Event(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	switch (siType)
	{
	case DEF_HOME_SENSOR :		// Home Sensor
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Home Sensor Event 설정 읽기 */
			if ((siResult = fget_home(siAxis, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorEvent(): fget_home(get an event when an axis arrives at home sensor from boot file) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Event(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*psiLimit = 0x00;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 Home Sensor Event 설정 읽기 */
			if ((siResult = get_home(siAxis, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorEvent(): get_home(get an event when an axis arrives at home sensor from memory) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Event(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*psiLimit = 0x00;
#endif
		}
		break;
	case DEF_POSITIVE_SENSOR :	// Positive Sensor
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Home Sensor Event 설정 읽기 */
			if ((siResult = fget_positive_limit(siAxis, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorEvent(): fget_positive_limit(get an event when positive sensor is Active from boot file) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Event(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*psiLimit = 0x00;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 Home Sensor Event 설정 읽기 */
			if ((siResult = get_positive_limit(siAxis, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorEvent(): get_positive_limit(get an event when positive sensor is Active from memory) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Event(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*psiLimit = 0x00;
#endif
		}
		break;
	case DEF_NEGATIVE_SENSOR :	// Negative Sensor
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Negative Sensor Event 설정 읽기 */
			if ((siResult = fget_negative_limit(siAxis, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorEvent(): fget_negative_limit(get an event when negative sensor is Active from boot file) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Event(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*psiLimit = 0x00;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 Negative Sensor Event 설정 읽기 */
			if ((siResult = get_negative_limit(siAxis, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSensorEvent(): get_negative_limit(get an event when negative sensor is Active from memory) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Sensor Event(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*psiLimit = 0x00;
#endif
		}
		break;
	default :
		//strLogMsg.Format(_T("GetSensorEvent(): Invalid Sensor Type[AxisID=%d]"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Sensor Event(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106079);	// ERR_MLIB_INVALID_SENSOR_TYPE
	}

	return ERR_MOTION_SUCCESS;
}

/**
 * Home, +/- 방향 Limit Switch Active시 동작할 신호 Level을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siType			: Sensor 종류, 0=Home, 1=Positive, 2=Negative
 * @param	*pbLevel		: 신호 Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  xx = INVALID SENSOR TYPE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetSensorLevel(short siAxis, short siType, BOOL *pbLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siLevel = DEF_LOW;
	short siBdNum;

	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		strLogMsg.Format(_T("MMC get Sensor Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pbLevel == NULL)
	{
		strLogMsg.Format(_T("MMC get Sensor Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	switch (siType)
	{
	case DEF_HOME_SENSOR :		// Home Sensor
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Home Sensor Active Level 설정 읽기 */
			if ((siResult = fget_home_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
			{
				strLogMsg.Format(_T("MMC get Sensor Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siLevel = DEF_LOW;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 Home Sensor Active Level 설정 읽기 */
			if ((siResult = get_home_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
			{
				strLogMsg.Format(_T("MMC get Sensor Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siLevel = DEF_LOW;
#endif
		}
		break;
	case DEF_POSITIVE_SENSOR :	// Positive Sensor
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Home Sensor Active Level 설정 읽기 */
			if ((siResult = fget_positive_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
			{
				strLogMsg.Format(_T("MMC get Sensor Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siLevel = DEF_LOW;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 Home Sensor Active Level 설정 읽기 */
			if ((siResult = get_positive_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
			{
				strLogMsg.Format(_T("MMC get Sensor Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siLevel = DEF_LOW;
#endif
		}
		break;
	case DEF_NEGATIVE_SENSOR :	// Negative Sensor
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Negative Sensor Active Level 설정 읽기 */
			if ((siResult = fget_negative_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
			{
				strLogMsg.Format(_T("MMC get Sensor Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siLevel = DEF_LOW;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 Negative Sensor Active Level 설정 읽기 */
			if ((siResult = get_negative_level(siAxis, &siLevel)) != ERR_MOTION_SUCCESS)
			{
				strLogMsg.Format(_T("MMC get Sensor Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siLevel = DEF_LOW;
#endif
		}
		break;
	default :
		strLogMsg.Format(_T("MMC get Sensor Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106079);	// ERR_MLIB_INVALID_SENSOR_TYPE
	}

	if (siLevel == DEF_LOW)
		*pbLevel = DEF_LOW;
	else
		*pbLevel = DEF_HIGH;

	return ERR_MOTION_SUCCESS;
}

/**
 * +/- 방향으로 Motor가 이동할 수 있는 제한 위치값과 그 위치값에 도달했을 때 적용할 Event를 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_positive_sw_limit(), fget_positive_sw_limit()
 *				 get_negative_sw_limit(), fget_negative_sw_limit()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bType			: 이동 방향, TRUE=Positive, FALSE=Negative
 * @param	*pdPosition		: 제한 위치값
 * @param	*psiLimit		: 적용할 Event
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetSWLimit(short siAxis, BOOL bType, double *pdPosition, short *psiLimit, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetSWLimit(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Switch Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdPosition == NULL)
	{
		//WriteErrorLog("GetSWLimit(): pdPosition Pointer is NULL");
		strLogMsg.Format(_T("MMC get Switch Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (psiLimit == NULL)
	{
		//WriteErrorLog("GetSWLimit(): psiLimit Pointer is NULL");
		strLogMsg.Format(_T("MMC get Switch Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** Positive S/W */
	if (bType == DEF_POSITIVE_SW)
	{
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Positive S/W Limit, 위치 설정 읽기 */
			if ((siResult = fget_positive_sw_limit(siAxis, pdPosition, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSWLimit(): fget_positive_sw_limit(get a positive S/W limit & event from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Switch Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*pdPosition = 0.0;
	*psiLimit = 0;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 Positive S/W Limit, 위치 설정 읽기 */
			if ((siResult = get_positive_sw_limit(siAxis, pdPosition, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSWLimit(): get_positive_sw_limit(get a positive S/W limit & event from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Switch Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*pdPosition = 0.0;
	*psiLimit = 0;
#endif
		}
	}
	/** Negative S/W */
	else
	{
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Positive S/W Limit, 위치 설정 읽기 */
			if ((siResult = fget_negative_sw_limit(siAxis, pdPosition, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSWLimit(): fget_negative_sw_limit(get a negative S/W limit & event from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Switch Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*pdPosition = 0.0;
	*psiLimit = 0;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 Positive S/W Limit, 위치 설정 읽기 */
			if ((siResult = get_negative_sw_limit(siAxis, pdPosition, psiLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetSWLimit(): get_negative_sw_limit(get a negative S/W limit & event from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Switch Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*pdPosition = 0.0;
	*psiLimit = 0;
#endif
		}
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축이 어떤 Motor로 제어하는 축으로 지정되어 있는지 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_stepper(), fget_stepper(), get_micro_stepper(), fget_micro_stepper()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiType		: Motor 종류, 0=속도형Servo, 1=일반Stepper, 2=MicroStepper 혹은 위치형Servo
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetMotorType(short siAxis, short *psiType, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetMotorType(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Motor Type(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiType == NULL)
	{
		//WriteErrorLog("GetMotorType(): psiType Pointer is NULL");
		strLogMsg.Format(_T("MMC get Motor Type(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 일반 Stepper Motor 설정인지 읽기 */
		if (fget_stepper(siAxis) == TRUE)
			*psiType = DEF_STEPPER;
		/** 축 Micro Stepper Motor 설정인지 읽기 */
		else if (fget_micro_stepper(siAxis) == TRUE)
			*psiType = DEF_MICRO_STEPPER;
		/** 축 Servo Motor 설정인지 읽기 */
		else
			*psiType = DEF_SERVO_MOTOR;
#else
	*psiType = DEF_MICRO_STEPPER;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 일반 Stepper Motor 설정인지 읽기 */
		if (get_stepper(siAxis) == TRUE)
			*psiType = DEF_STEPPER;
		/** 축 Micro Stepper Motor 설정인지 읽기 */
		else if (get_micro_stepper(siAxis) == TRUE)
			*psiType = DEF_MICRO_STEPPER;
		/** 축 Servo Motor 설정인지 읽기 */
		else
			*psiType = DEF_SERVO_MOTOR;
#else
	*psiType = DEF_MICRO_STEPPER;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축의 Feedback 장치와 Loop 형태를 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_feedback(), fget_feedback(), get_closed_loop(), fget_closed_loop()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiDevice		: Feedback 장치, 0=Encoder입력, 1=0~10volt입력, 2=-10~10volt입력
 * @param	*pbLoop			: Loop 형태, FALSE=Open Loop, TRUE=Closed Loop
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAxisProperty(short siAxis, short *psiDevice, BOOL *pbLoop, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siLoop = 0;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetAxisProperty(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Axis Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiDevice == NULL)
	{
		//WriteErrorLog("GetAxisProperty(): psiDevice Pointer is NULL");
		strLogMsg.Format(_T("MMC get Axis Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pbLoop == NULL)
	{
		//WriteErrorLog("GetAxisProperty(): pbLoop Pointer is NULL");
		strLogMsg.Format(_T("MMC get Axis Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 Feedback Device 설정 읽기 */
		if ((siResult = fget_feedback(siAxis, psiDevice)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAxisProperty(): fget_feedback(get an establishment of feedback device from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Axis Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 축 Loop 형태 설정 읽기 */
		if ((siResult = fget_closed_loop(siAxis, &siLoop)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAxisProperty(): fget_closed_loop(get 'Closed_Loop or Open_Loop' from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Axis Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiDevice = 0;
	siLoop = 0;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 Feedback Device 설정 읽기 */
		if ((siResult = get_feedback(siAxis, psiDevice)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAxisProperty(): get_feedback(get an establishment of feedback device from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Axis Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 축 Loop 형태 설정 읽기 */
		if ((siResult = get_closed_loop(siAxis, &siLoop)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAxisProperty(): get_closed_loop(get 'Closed_Loop or Open_Loop' from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Axis Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiDevice = 0;
	siLoop = 0;
#endif
	}

	if (siLoop == DEF_OPEN_LOOP)
		*pbLoop = DEF_OPEN_LOOP;
	else
		*pbLoop = DEF_CLOSED_LOOP;

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축의 Pulse 분주비와 전자기어비를 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_pulse_ratio(), fget_pulse_ratio(),
 *				 get_electric_gear(), fget_electric_gear()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiPgratio		: Pulse 분주비
 * @param	*pdEgratio		: 전자기어비
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetRatioProperty(short siAxis, short *psiPgratio, double *pdEgratio, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetRatioProperty(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Ratio Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiPgratio == NULL)
	{
		//WriteErrorLog("GetRatioProperty(): psiPgratio Pointer is NULL");
		strLogMsg.Format(_T("MMC get Ratio Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pdEgratio == NULL)
	{
		//WriteErrorLog("GetRatioProperty(): pdEgratio Pointer is NULL");
		strLogMsg.Format(_T("MMC get Ratio Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 펄스 분주비 설정 읽기 */
		if ((siResult = fget_pulse_ratio(siAxis, psiPgratio)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetRatioProperty(): fget_pulse_ratio(get a pulse ratio from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Ratio Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 축 전자기어비 설정 읽기 */
		if ((siResult = fget_electric_gear(siAxis, pdEgratio)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetRatioProperty(): fget_electric_gear(get an electric gear ratio from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Ratio Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiPgratio = 8;
	*pdEgratio = 1.0;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 펄스 분주비 설정 읽기 */
		if ((siResult = get_pulse_ratio(siAxis, psiPgratio)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetRatioProperty(): get_pulse_ratio(get a pulse ratio from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Ratio Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 축 전자기어비 설정 읽기 */
		if ((siResult = get_electric_gear(siAxis, pdEgratio)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetRatioProperty(): get_electric_gear(get an electric gear ratio from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Ratio Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiPgratio = 8;
	*pdEgratio = 1.0;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 속도형 Servo의 설정을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_control(), fget_control(), get_unipolar(), fget_unipolar()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbControl		: 제어모드, FALSE=속도제어, TRUE=위치제어
 * @param	*pbPolar		: Analog 출력 종류, TRUE=UNIPOLAR, FALSE=BIPOLER
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetVServoProperty(short siAxis, BOOL *pbControl, BOOL *pbPolar, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siControl = 0;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetVServoProperty(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Velocity Type Servo Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pbControl == NULL)
	{
		//WriteErrorLog("GetVServoProperty(): pbControl Pointer is NULL");
		strLogMsg.Format(_T("MMC get Velocity Type Servo Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pbPolar == NULL)
	{
		//WriteErrorLog("GetVServoProperty(): pbPolar Pointer is NULL");
		strLogMsg.Format(_T("MMC get Velocity Type Servo Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 제어모드 설정 읽기 */
		if ((siResult = fget_control(siAxis, &siControl)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetVServoProperty(): fget_control(get 'Velocity Control Mode or Torque Control Mode' from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Velocity Type Servo Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 축 Analog 출력 설정 읽기 */
		if (fget_unipolar(siAxis) == (short)DEF_BIPOLAR)
			*pbPolar = DEF_BIPOLAR;
		else
			*pbPolar = DEF_UNIPOLAR;
#else
	siControl = 0;
	*pbPolar = DEF_UNIPOLAR;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 제어모드 설정 읽기 */
		if ((siResult = get_control(siAxis, &siControl)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetVServoProperty(): get_control(get 'Velocity Control Mode or Torque Control Mode' from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Velocity Type Servo Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 축 Analog 출력 설정 읽기 */
		if (get_unipolar(siAxis) == (short)DEF_BIPOLAR)
			*pbPolar = DEF_BIPOLAR;
		else
			*pbPolar = DEF_UNIPOLAR;
#else
	siControl = 0;
	*pbPolar = DEF_UNIPOLAR;
#endif
	}

	if (siControl == DEF_V_CONTROL)
		*pbControl = DEF_V_CONTROL;
	else
		*pbControl = DEF_T_CONTROL;

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 Pulse 출력 형태를 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_step_mode(), fget_step_mode()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbMode			: Pulse 출력 형태, FALSE=Two Pulse(CW+CCW), TRUE=Sign+Pulse
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetStepMode(short siAxis, BOOL *pbMode, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siMode = DEF_TWO_PULSE;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetStepMode(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Step Mode(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pbMode == NULL)
	{
		//WriteErrorLog("GetStepMode(): pbMode Pointer is NULL");
		strLogMsg.Format(_T("MMC get Step Mode(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 Pulse 출력 형태 설정 읽기 */
		if ((siResult = fget_step_mode(siAxis, &siMode)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetStepMode(): fget_step_mode(get 'CW+CCW Mode or Sign+Pulse Mode' from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Step Mode(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siMode = 0;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 Pulse 출력 형태 설정 읽기 */
		if ((siResult = get_step_mode(siAxis, &siMode)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetStepMode(): get_step_mode(get 'CW+CCW Mode or Sign+Pulse Mode' from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Step Mode(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siMode = 0;
#endif
	}

	if (siMode == DEF_TWO_PULSE)
		*pbMode = DEF_TWO_PULSE;
	else
		*pbMode = DEF_SIGN_PULSE;

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 Encoder 입력 방향과 좌표 방향을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_encoder_direction(), fget_encoder_direction(),
 *				 get_coordinate_direction(), fget_coordinate_direction()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbEncDir		: Encoder 입력 방향, FALSE=ENCO_CW(시계방향, - Count)
 *												 TRUE =ENCO_CCW(반시계방향, + Count)
 * @param	*pbCoorDir		: 좌표방향, FALSE=CORD_CW(시계방향, + 좌표 이동)
 *										TRUE =CORD_CCW(반시계방향, - 좌표 이동)
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetEncoderDirection(short siAxis, BOOL *pbEncDir, BOOL *pbCoorDir, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siEncDir = 0;
	short siCoorDir = 0;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetEncoderDirection(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Encoder Direction(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}
	
	/** 인수 Pointer 오류 */
	if (pbEncDir == NULL)
	{
		//WriteErrorLog("GetEncoderDirection(): pbEncDir Pointer is NULL");
		strLogMsg.Format(_T("MMC get Encoder Direction(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pbCoorDir == NULL)
	{
		//WriteErrorLog("GetEncoderDirection(): pbCoorDir Pointer is NULL");
		strLogMsg.Format(_T("MMC get Encoder Direction(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축 Encoder 방향 설정 읽기 */
		if ((siResult = fget_encoder_direction(siAxis, &siEncDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetEncoderDirection(): fget_encoder_direction(get an encoder input direction from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Encoder Direction(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 축 좌표 방향 설정 읽기 */
		if ((siResult = fget_coordinate_direction(siAxis, &siCoorDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetEncoderDirection(): fget_coordinate_direction(get a coordinate direction from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Encoder Direction(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siEncDir = 0;
	siCoorDir = 0;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축 Encoder 방향 설정 읽기 */
		if ((siResult = get_encoder_direction(siAxis, &siEncDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetEncoderDirection(): get_encoder_direction(get an encoder input direction from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Encoder Direction(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 축 좌표 방향 설정 읽기 */
		if ((siResult = get_coordinate_direction(siAxis, &siCoorDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetEncoderDirection(): get_coordinate_direction(get a coordinate direction from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Encoder Direction(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	siEncDir = 0;
	siCoorDir = 0;
#endif
	}

	if (siEncDir == DEF_CORD_CW)
		*pbEncDir = DEF_CORD_CW;
	else
		*pbEncDir = DEF_CORD_CCW;

	if (siCoorDir == DEF_CORD_CW)
		*pbCoorDir = DEF_CORD_CW;
	else
		*pbCoorDir = DEF_CORD_CCW;

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정된 축의 STOP EVENT, ESTOP EVENT 수행 시 감속 시간을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_stop_rate(), fget_stop_rate(), get_e_stop_rate(), fget_e_stop_rate()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bType			: 정지 종류, FALSE=STOP, TRUE=E-STOP
 * @param	*psiRate		: 감속 시간
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetStopRate(short siAxis, BOOL bType, short *psiRate, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetStopRate(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Stop Rate(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiRate == NULL)
	{
		//WriteErrorLog("GetStopRate(): psiRate Pointer is NULL");
		strLogMsg.Format(_T("MMC get Stop Rate(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** STOP */
	if (bType == FALSE)
	{
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Stop Rate 설정 읽기 */
			if ((siResult = fget_stop_rate(siAxis, psiRate)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetStopRate(): fget_stop_rate(get a reduction of speed when Stop Event activates from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Stop Rate(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*psiRate = 0;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 Stop Rate 설정 읽기 */
			if ((siResult = get_stop_rate(siAxis, psiRate)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetStopRate(): get_stop_rate(get a reduction of speed when Stop Event activates from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Stop Rate(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*psiRate = 0;
#endif
		}
	}
	/** E-STOP */
	else
	{
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 E-Stop Rate 설정 읽기 */
			if ((siResult = fget_e_stop_rate(siAxis, psiRate)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetStopRate(): fget_e_stop_rate(get a reduction of speed when E-Stop Event activates from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Stop Rate(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*psiRate = 0;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축 E-Stop Rate 설정 읽기 */
			if ((siResult = get_e_stop_rate(siAxis, psiRate)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetStopRate(): get_e_stop_rate(get a reduction of speed when E-Stop Event activates from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Stop Rate(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*psiRate = 0;
#endif
		}
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 동기제어시 적용되는 보상 Gain값을 읽는다.
 *
 * MMC Library : get_sync_gain()
 *
 * @param	*plCoeff		: 보상 Gain 값
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetSyncGain(long *plCoeff)
{
	short siResult = ERR_MOTION_SUCCESS;
	CString strLogMsg;

	/** 인수 Pointer 오류 */
	if (plCoeff == NULL)
	{
		//WriteErrorLog("GetSyncGain(): plCoeff Pointer is NULL");
		SetErrorLevel(_T("MMC get Sync Gain"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** 동기제어시 보상 Gain 설정 읽기 */
	if ((siResult = get_sync_gain(plCoeff)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("GetSyncGain(): get_sync_gain(get a gain of synchronous control) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC get Sync Gain"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	*plCoeff = 0;
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축의 속도 또는 위치에 대한 PID & FF Gain값들을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_gain(), fget_gain(), get_v_gain(), fget_v_gain()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bVelType		: 위치/속도 종류 지정, FALSE=위치, TRUE=속도
 * @param	*plGain			: Gain 값 배열, 배열인수위치는 아래와 같다.
 *								0=GA_P, 1=GA_I, 2=GA_D, 3=GA_F, 4=GA_LIMIT, 5=GAIN_MUNBER
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetGain(short siAxis, BOOL bVelType, long *plGain, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetGain(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get PID and FF Gain(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (plGain == NULL)
	{
		strLogMsg.Format(_T("MMC get PID and FF Gain(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 위치 Gain */
	if (bVelType == FALSE)
	{
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** Gain 설정 읽기 */
			if ((siResult = fget_gain(siAxis, plGain)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetGain(): fget_gain(get a gain from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get PID and FF Gain(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*plGain = 0;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** Gain 설정 읽기 */
			if ((siResult = get_gain(siAxis, plGain)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetGain(): get_gain(get a gain from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get PID and FF Gain(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*plGain = 0;
#endif
		}
	}
	/** 속도 Gain */
	else
	{
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** Gain 설정 읽기 */
			if ((siResult = fget_v_gain(siAxis, plGain)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetGain(): fget_v_gain(get a velocity gain from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get PID and FF Gain(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*plGain = 0;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** Gain 설정 읽기 */
			if ((siResult = get_v_gain(siAxis, plGain)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetGain(): get_v_gain(get a velocity gain from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get PID and FF Gain(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	*plGain = 0;
#endif
		}
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축의 적분제어 시 적분제어 모드를 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_p_integration(), fget_p_integration(),
 *				 get_v_integration(), fget_v_integration()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bType			: 제어모드, FALSE=위치, TRUE=속도
 * @param	*pbMode			: 적분제어 모드, FALSE=정지시적용, TRUE=항상적용
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetIntegration(short siAxis, BOOL bType, BOOL *pbMode, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siMode = FALSE;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetIntegration(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Intergration Mode(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pbMode == NULL)
	{
		//WriteErrorLog("GetIntegration(): pbMode Pointer is NULL");
		strLogMsg.Format(_T("MMC get Intergration Mode(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 위치 */
	if (bType == FALSE)
	{
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축의 적분 제어 모드 설정 읽기 */
			if ((siResult = fget_p_integration(siAxis, &siMode)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetIntegration(): fget_p_integration(get an integral control mode of position loop from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Intergration Mode(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siMode = 0;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축의 적분 제어 모드 설정 읽기 */
			if ((siResult = get_p_integration(siAxis, &siMode)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetIntegration(): get_p_integration(get an integral control mode of position loop from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Intergration Mode(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siMode = 0;
#endif
		}
	}
	/** 속도 */
	else
	{
		/** boot file에서 축 설정 읽기 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축의 적분 제어 모드 설정 읽기 */
			if ((siResult = fget_v_integration(siAxis, &siMode)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetIntegration(): fget_v_integration(get an integral control mode of velocity loop from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Intergration Mode(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siMode = 0;
#endif
		}
		/** memory에서 축 설정 읽기 */
		else
		{
#ifndef SIMULATION
			/** 축의 적분 제어 모드 설정 읽기 */
			if ((siResult = get_v_integration(siAxis, &siMode)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("GetIntegration(): get_v_integration(get an integral control mode of velocity loop from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC get Intergration Mode(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#else
	siMode = 0;
#endif
		}
	}

	if (siMode == FALSE)
		*pbMode = FALSE;
	else
		*pbMode = TRUE;

	return ERR_MOTION_SUCCESS;
}
/**
 * 속도지령 혹은 토크 지령에 대해 Low Pass Filter 혹은 Notch Filter에 대한 Filter 값을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_position_lowpass_filter(), fget_position_lowpass_filter(),
 *				 get_position_notch_filter(), fget_position_notch_filter(),
 *				 get_velocity_lowpass_filter(), fget_velocity_lowpass_filter(),
 *				 get_velocity_notch_filter(), fget_velocity_notch_filter()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bCommandType	: 지령 종류, FALSE=속도(Position), TRUE=토크(Velocity)
 * @param	bFilterType		: Filter 종류, FALSE=LowPass, TRUE=Notch
 * @param	*pdFilter		: Filter 값
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetFilter(short siAxis, BOOL bCommandType, BOOL bFilterType, double *pdFilter, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetFilter(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Filter Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdFilter == NULL)
	{
		//WriteErrorLog("GetFilter(): pdFilter Pointer is NULL");
		strLogMsg.Format(_T("MMC get Filter Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 속도(Position) */
	if (bCommandType == FALSE)
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
			/** Low Pass */
			if (bFilterType == FALSE)
			{
#ifndef SIMULATION
				/** Posittion Low Pass Filter 설정 */
				if ((siResult = fget_position_lowpass_filter(siAxis, pdFilter)) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("GetFilter(): fget_position_lowpass_filter(from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC get Filter Properties(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#else
	*pdFilter = 0.0;
#endif
			}
			/** Notch */
			else
			{
#ifndef SIMULATION
				/** Posittion Notch Filter 설정 */
				if ((siResult = fget_position_notch_filter(siAxis, pdFilter)) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("GetFilter(): fget_position_notch_filter(from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC get Filter Properties(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#else
	*pdFilter = 0.0;
#endif
			}
		}
		/** memory에 설정 */
		else
		{
			/** Low Pass */
			if (bFilterType == FALSE)
			{
#ifndef SIMULATION
				/** Posittion Low Pass Filter 설정 */
				if ((siResult = get_position_lowpass_filter(siAxis, pdFilter)) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("GetFilter(): get_position_lowpass_filter(from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC get Filter Properties(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#else
	*pdFilter = 0.0;
#endif
			}
			/** Notch */
			else
			{
#ifndef SIMULATION
				/** Posittion Notch Filter 설정 */
				if ((siResult = get_position_notch_filter(siAxis, pdFilter)) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("GetFilter(): get_position_notch_filter(from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC get Filter Properties(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#else
	*pdFilter = 0.0;
#endif
			}
		}
	}
	/** 토크(Velocity) */
	else
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
			/** Low Pass */
			if (bFilterType == FALSE)
			{
#ifndef SIMULATION
				/** Posittion Low Pass Filter 설정 */
				if ((siResult = fget_velocity_lowpass_filter(siAxis, pdFilter)) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("GetFilter(): fget_velocity_lowpass_filter(from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC get Filter Properties(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#else
	*pdFilter = 0.0;
#endif
			}
			/** Notch */
			else
			{
#ifndef SIMULATION
				/** Posittion Notch Filter 설정 */
				if ((siResult = fget_velocity_notch_filter(siAxis, pdFilter)) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("GetFilter(): fget_velocity_notch_filter(from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC get Filter Properties(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#else
	*pdFilter = 0.0;
#endif
			}
		}
		/** memory에 설정 */
		else
		{
			/** Low Pass */
			if (bFilterType == FALSE)
			{
#ifndef SIMULATION
				/** Posittion Low Pass Filter 설정 */
				if ((siResult = get_velocity_lowpass_filter(siAxis, pdFilter)) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("GetFilter(): get_velocity_lowpass_filter(from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC get Filter Properties(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#else
	*pdFilter = 0.0;
#endif
			}
			/** Notch */
			else
			{
#ifndef SIMULATION
				/** Posittion Notch Filter 설정 */
				if ((siResult = get_velocity_notch_filter(siAxis, pdFilter)) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("GetFilter(): get_velocity_notch_filter(from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC get Filter Properties(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#else
	*pdFilter = 0.0;
#endif
			}
		}
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축의 동작 중 속도를 읽는다. (명령 값과 실제 값)
 *
 * MMC Library : get_act_velocity(), get_com_velocity()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bType			: 속도 종류, FALSE=실제속도값, TRUE=속도명령값
 * @param	*psiPulse		: 속도의 Pulse값
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetVelocity(short siAxis, BOOL bType, short *psiPulse)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetVelocity(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Velocity(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiPulse == NULL)
	{
		//WriteErrorLog("GetVelocity(): psiPulse Pointer is NULL");
		strLogMsg.Format(_T("MMC get Velocity(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 실제 속도 */
	if (bType == FALSE)
	{
#ifndef SIMULATION
		/** 축의 실제 속도 읽기 */
		*psiPulse = get_act_velocity(siAxis);
#else
	*psiPulse = 0;
#endif
	}
	/** 명령 속도 */
	else
	{
#ifndef SIMULATION
		/** 축의 명령 속도 읽기 */
		*psiPulse = get_com_velocity(siAxis);
#else
	*psiPulse = 0;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정된 Board의 축별 동작여부를 읽는다.
 *
 *		b7	b6	b5	b4	b3	b2	b1	b0
 *		축8	축7	축6	축5	축4	축3	축2	축1
 *
 *		bit = TRUE : 동작 금지
 *		bit = FALSE : 동작 가능
 *
 * MMC Library : get_axis_runstop()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	*psiState		: 축별 동작 여부, bit가 한 축 (b0=축1, b1=축2, ...), TRUE=정지, FALSE=동작
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAxisRunStop(short siBdNum, short *psiState)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("GetAxisRunStop(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC check Axis Run(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

	/** 인수 Pointer 오류 */
	if (psiState == NULL)
	{
		//WriteErrorLog("GetAxisRunStop(): psiState Pointer is NULL");
		strLogMsg.Format(_T("MMC check Axis Run(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** 축의 동작여부 읽기 */
	if ((siResult = get_axis_runstop(siBdNum, psiState)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("GetAxisRunStop(): get_axis_runstop(get 'Run or Stop') Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC check Axis Run(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	*psiState = 0;
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 실제위치 및 목표위치를 읽는다.
 *
 * MMC Library : get_command(), get_position()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bCommandType	: 위치 종류, FALSE=실제위치, TRUE=목표위치
 * @param	*pdPosition		: bType=FALSE이면, 지정할 실제위치(Encoder)
 *							  bType=TRUE 이면, 지정할 목표위치(Command)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetPosition(short siAxis, BOOL bCommandType, double *pdPosition)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;


	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetPosition(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Position(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdPosition == NULL)
	{
		//WriteErrorLog("GetPosition(): pdPosition Pointer is NULL");
		strLogMsg.Format(_T("MMC get Position(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 실제위치(Encoder) */
	if (bCommandType == FALSE)
	{
#ifndef SIMULATION
		/** 축의 실제위치 읽기 */
		if ((siResult = get_position(siAxis, pdPosition)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetPosition(): get_position(get a current position) Fail[AxisNo=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Position(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*pdPosition = 0.0;
#endif
	}
	/** 목표위치(Command) */
	else
	{
#ifndef SIMULATION
		/** 축의 목표위치 읽기 */
		if ((siResult = get_command(siAxis, pdPosition)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetPosition(): get_command(get a target position) Fail[AxisNo=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Position(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*pdPosition = 0.0;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * Motor의 지령치 RPM이나 실제 RPM을 읽는다.
 *
 * MMC Library : get_command_rpm(), get_encoder_rpm()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bType			: RMP 종류, FALSE=실제RPM, TRUE=지령치RPM
 * @param	*psiRpm			: RPM값
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetRpm(short siAxis, BOOL bType, short *psiRpm)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetRpm(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC read RPM(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiRpm == NULL)
	{
		//WriteErrorLog("GetRpm(): psiRpm Pointer is NULL");
		strLogMsg.Format(_T("MMC read RPM(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 실제 RPM */
	if (bType == FALSE)
	{
#ifndef SIMULATION
		/** 축의 실제 RPM 읽기 */
		if ((siResult = get_encoder_rpm(siAxis, psiRpm)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetRpm(): get_encoder_rpm(get a current encoder RPM) Fail[AxisNo=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC read RPM(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiRpm = 0;
#endif
	}
	/** 지령치 RPM */
	else
	{
#ifndef SIMULATION
		/** 축의 지령치 RPM 읽기 */
		if ((siResult = get_command_rpm(siAxis, psiRpm)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetRpm(): get_command_rpm(get a command encoder RPM) Fail[AxisNo=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC read RPM(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiRpm = 0;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * Board별 Sampling Rate를 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_control_timer(), fget_control_timer()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	*psiTime		: Sampling Rate, msec단위 (1=4msec, 2=2msec, 3=1msec만 지원)
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetControlTimer(short siBdNum, short *psiTime, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("GetControlTimer(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC read Sampling Rate(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

	/** 인수 Pointer 오류 */
	if (psiTime == NULL)
	{
		//WriteErrorLog("GetControlTimer(): psiTime Pointer is NULL");
		strLogMsg.Format(_T("MMC read Sampling Rate(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** Board의 Sampling Rate 읽기 */
		if ((siResult = fget_control_timer(siBdNum, psiTime)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetControlTimer(): fget_control_timer(get a sampling rate from boot file) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC read Sampling Rate(BoradNo=%d)"), siBdNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiTime = 0;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** Board의 Sampling Rate 읽기 */
		if ((siResult = get_control_timer(siBdNum, psiTime)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetControlTimer(): get_control_timer(get a sampling rate from memory) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC read Sampling Rate(BoradNo=%d)"), siBdNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiTime = 0;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 목표위치와 실제위치의 차이값인 위치오차를 읽는다.
 *
 * MMC Library : get_error()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pdError		: 위치오차, (목표위치-실제위치)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetError(short siAxis, double *pdError)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;


	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetError(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Position Error(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdError == NULL)
	{
		//WriteErrorLog("GetError(): pdError Pointer is NULL");
		strLogMsg.Format(_T("MMC get Position Error(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** 축의 위치오차 읽기 */
	if ((siResult = get_error(siAxis, pdError)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("GetError(): get_error(get a differnce between current position & target position) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Position Error(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	*pdError = 0.0;
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 특정 축의 Encoder Feedback Data를 빠르게 읽어들일 때 사용 (50usec 주기 Update)
 *
 * MMC Library : get_fast_read_encoder()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbStatus		: 설정 여부
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetFastReadEncoder(short siAxis, BOOL *pbStatus)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siStatus = FALSE;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetFastReadEncoder(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Fast Encoder Feedback Data(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pbStatus == NULL)
	{
		//WriteErrorLog("GetFastReadEncoder(): pbStatus Pointer is NULL");
		strLogMsg.Format(_T("MMC get Fast Encoder Feedback Data(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** 축의 위치오차 읽기 */
	if ((siResult = get_fast_read_encoder(siAxis, &siStatus)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("GetFastReadEncoder(): get_fast_read_encoder(get whether fast read encoder is enable or not) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Fast Encoder Feedback Data(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	siStatus = 0;
#endif

	if (siStatus == FALSE)
		*pbStatus = FALSE;
	else
		*pbStatus = FALSE;

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축의 Analog Offset 값을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * MMC Library : get_analog_offset(), fget_analog_offset()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiOffset		: Analog Offer, +/-2048, +/-32767
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAnalogOffset(short siAxis, short *psiOffset, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("GetAnalogOffset(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Analog Offset(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (psiOffset == NULL)
	{
		//WriteErrorLog("GetAnalogOffset(): psiOffset Pointer is NULL");
		strLogMsg.Format(_T("MMC get Analog Offset(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** boot file에서 축 설정 읽기 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축의 Analog Offset 설정 읽기 */
		if ((siResult = fget_analog_offset(siAxis, psiOffset)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAnalogOffset(): fget_analog_offset(get an analog offset from boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Analog Offset(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiOffset = 0;
#endif
	}
	/** memory에서 축 설정 읽기 */
	else
	{
#ifndef SIMULATION
		/** 축의 Analog Offset 설정 읽기 */
		if ((siResult = get_analog_offset(siAxis, psiOffset)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAnalogOffset(): get_analog_offset(get an analog offset from memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get Analog Offset(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*psiOffset = 0;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 입, 출력 Port의 32bit Data를 읽는다.
 *
 * MMC Library : get_io(), get_out_io()
 *
 * @param	siPort			: 입, 출력 Port 번호 (0 ~ 3, Board 구성 개수에 따라 변동)
 * @param	bType			: 입, 출력 종류, FALSE=입력, TRUE=출력
 * @param	*plValue		: 32bit Data
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID IO PORT ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetIO(short siPort, BOOL bType, long *plValue)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** I/O Port ID 범위 오류 */
	if ((siPort < DEF_MIN_IO_PORT) || (siPort > (siBdNum - 1)))
	{
		//strLogMsg.Format(_T("GetIO(): Invalid I/O Port ID(IOPortID=%d is out of range)"), siPort);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get IO Port Data(IOPortID=%d)"), siPort);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106099);	// ERR_MLIB_INVALID_IO_PORT_ID
	}

	/** 인수 Pointer 오류 */
	if (plValue == NULL)
	{
		//WriteErrorLog("GetIO(): plValue Pointer is NULL");
		strLogMsg.Format(_T("MMC get IO Port Data(IOPortID=%d)"), siPort);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 입력 Port */
	if (bType == DEF_IO_TYPE_IN)
	{
#ifndef SIMULATION
		/** Board의 입력 Port에서 32 bit I/O 읽기 */
		if ((siResult = get_io(siPort, plValue)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetIO(): get_io(get 32-bit data of input port) Fail[IOPortID=%d] - Error# is %d"), siPort, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get IO Port Data(IOPortID=%d)"), siPort);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*plValue = 0;
#endif
	}
	/** 출력 Port */
	else
	{
#ifndef SIMULATION
		/** Board의 출력 Port에서 32 bit I/O 읽기 */
		if ((siResult = get_out_io(siPort, plValue)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetIO(): get_out_io(get 32-bit data of onput port) Fail[IOPortID=%d] - Error# is %d"), siPort, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC get IO Port Data(IOPortID=%d)"), siPort);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
	*plValue = 0;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정된 Analog 입/출력의 12/16bit Data 값을 읽는다.
 *
 * MMC Library : get_analog(), get_dac_output()
 *
 * @param	siChannel		: Analog 입력 채널 수(0 ~ 3) 혹은 출력 축 ID(0 ~ 63)
 * @param	bType			: 입, 출력 종류, FALSE=입력, TRUE=출력
 * @param	*psiValue		: bType=FALSE이면 Analog 입력 값, -2048 ~ +2047
 *							  bType=TRUE이면 Analog 출력 값, +/-2048, +/-32767
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID ANALOG INPUT CHANNEL ID (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetAnalog(short siChannel, BOOL bType, short *psiValue)
{
	short siResult = ERR_MOTION_SUCCESS;
	CString strLogMsg;

	/** 인수 Pointer 오류 */
	if (psiValue == NULL)
	{
		//WriteErrorLog("GetAnalog(): psiValue Pointer is NULL");
		SetErrorLevel(_T("MMC get IO Analog Data"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** Analog 입력 */
	if (bType == DEF_IO_TYPE_IN)
	{
		/** Analog Input Channel ID 범위 오류 */
		if ((siChannel < DEF_MIN_ANALOG_CH) || (siChannel > (DEF_MAX_ANALOG_CH - 1)))
		{
			//strLogMsg.Format(_T("GetAnalog(): Invalid Analog Input Channel ID(ChannelID=%d is out of range)"), siChannel);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC get IO Analog Data"),3, __FILE__, __LINE__);
			return generateErrorCode(106111);	// ERR_MLIB_INVALID_ANALOG_INPUT_CHANNEL_ID
		}

#ifndef SIMULATION
		/** Analog Input 읽기 */
		if ((siResult = get_analog(siChannel, psiValue)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAnalog(): get_analog(get an analog input) Fail[ChannelID=%d] - Error# is %d"), siChannel, siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC get IO Analog Data"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
		*psiValue = 0;
#endif
	}
	/** Analog 출력 */
	else
	{
		/** Analog Output Channel ID 범위 오류 */
		if ((siChannel < DEF_MIN_ANALOG_CH) || (siChannel > (DEF_MAX_ANALOG_CH - 1)))
		{
			//strLogMsg.Format(_T("GetAnalog(): Invalid Analog Output Channel ID(ChannelID=%d is out of range)"), siChannel);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC get IO Analog Data"),3, __FILE__, __LINE__);
			return generateErrorCode(106111);	// ERR_MLIB_INVALID_ANALOG_INPUT_CHANNEL_ID
		}

#ifndef SIMULATION
		/** Analog Output 읽기 */
		if ((siResult = get_dac_output(siChannel, psiValue)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("GetAnalog(): get_dac_output(get an analog output) Fail[ChannelID=%d] - Error# is %d"), siChannel, siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC get IO Analog Data"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#else
		*psiValue = 0;
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * Board의 충돌방지 기능의 사용여부를 읽는다.
 *
 * MMC Library : get_collision_prevent_flag()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	*pbMode			: 사용여부, TRUE=사용
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetCollisionPreventFlag(short siBdNum, BOOL *pbMode)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siMode = FALSE;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("GetCollisionPreventFlag(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Collision Prevent Flag(BoradNo=%d"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

	/** 인수 Pointer 오류 */
	if (pbMode == NULL)
	{
		//WriteErrorLog("GetCollisionPreventFlag(): pbMode Pointer is NULL");
		strLogMsg.Format(_T("MMC get Collision Prevent Flag(BoradNo=%d"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** 충돌 방지 기능 사용여부 읽기 */
	if ((siResult = get_collision_prevent_flag(siBdNum, &siMode)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("GetCollisionPreventFlag(): get_collision_prevent_flag Fail[BoradNo=%d] - Error# is %d"), siBdNum, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC get Collision Prevent Flag(BoradNo=%d"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	siMode = 0;
#endif

	if (siMode == FALSE)
		*pbMode = FALSE;
	else
		*pbMode = TRUE;

	return ERR_MOTION_SUCCESS;
}
/**
 * 동기제어 여부를 읽는다.
 *
 * MMC Library : get_sync_control()
 *
 * @param	*pbState		: 지정 여부, TRUE=지정
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetSyncControl(BOOL *pbState)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siState = FALSE;
	CString strLogMsg;

	/** 인수 Pointer 오류 */
	if (pbState == NULL)
	{
		//WriteErrorLog("GetSyncControl(): pbState Pointer is NULL");
		SetErrorLevel(_T("MMC check Sync Control"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** 동기제어 여부 읽기 */
	if ((siResult = get_sync_control(&siState)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("GetSyncControl(): get_sync_control(whether use or not) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC check Sync Control"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	siState = 0;
#endif

	if (siState == FALSE)
		*pbState = FALSE;
	else
		*pbState = TRUE;

	return ERR_MOTION_SUCCESS;
}
/**
 * Master축과 Slave축의 실제위치를 읽는다.
 *
 * MMC Library : get_sync_position()
 *
 * @param	*pdMasterPos	: Master 축 위치
 * @param	*pdSlavePos		: Slave 축 위치
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetSyncPosition(double *pdMasterPos, double *pdSlavePos)
{
	short	siResult = ERR_MOTION_SUCCESS;
	CString	strLogMsg;

	/** 인수 Pointer 오류 */
	if (pdMasterPos == NULL)
	{
		//WriteErrorLog("GetSyncPosition(): pdMasterPos Pointer is NULL");
		SetErrorLevel(_T("MMC get Position(Master and Slave Axis"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pdSlavePos == NULL)
	{
		//WriteErrorLog("GetSyncPosition(): pdSlavePos Pointer is NULL");
		SetErrorLevel(_T("MMC get Position(Master and Slave Axis"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** Master축과 Slave 축의 실제위치 읽기 */
	if ((siResult = get_sync_position(pdMasterPos, pdSlavePos)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("GetSyncPosition(): get_sync_position(get positions of Master Axis and Slave Axis) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC get Position(Master and Slave Axis"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	*pdMasterPos = 0.0;
	*pdSlavePos = 0.0;
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 보드별로 I/O Interrupt를 Enable/Diable하거나, I/O Interrupt 발생 시
 * STOP-EVENT나 E-STOP-EVENT를 지정축에 발생할지 여부를 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : io_interrupt_enable(), fio_interrupt_enable(),
 *				 io_interrupt_on_e_stop(), fio_interrupt_on_e_stop(),
 *				 io_interrupt_on_stop(), fio_interrupt_on_stop()
 *
 * @param	siID			: Board (0 ~ 7) 혹은 축 ID (0 ~ 63)
 * @param	siType			: 종류, 0=Board Enable/Disable, 1=STOP EVENT지정, 2=ESTOP EVENT지정
 * @param	bState			: 설정, TRUE =Enable지정,  STOP EVENT/ESTOP EVENT지정,
 *									FALSE=Disable지정, STOP EVENT/ESTOP EVENT미지정
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID IO INTTERUPT TYPE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::IOInterrupt(short siID, short siType, BOOL bState, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** I/O Interrupt 종류 */
	switch (siType)
	{
	case DEF_BOARD_ENABLE_MODE :		// Board Enable/Disable
		/** Board ID 범위 오류 */
		if ((siID < DEF_NON_MOTION_BD) || (siID > (siBdNum - 1)))
		{
			//strLogMsg.Format(_T("IOInterrupt(): Invalid Board Number(BoradNo=%d is out of range)"), siID);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set IO Interrupt(BoardNo=%d)"), siID);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
		}

		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** Board의 Intterupt Enable 설정 */
			if ((siResult = fio_interrupt_enable(siID, (short)bState)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("IOInterrupt(): fio_interrupt_enable(set I/O Interrupt possiblity and save in boot file) Fail[BoradNo=%d] - Error# is %d"), siID, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set IO Interrupt(BoardNo=%d)"), siID);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** Board의 Intterupt Enable 설정 */
			if ((siResult = io_interrupt_enable(siID, (short)bState)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("IOInterrupt(): io_interrupt_enable(set I/O Interrupt possiblity and save in memory) Fail[BoradNo=%d] - Error# is %d"), siID, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set IO Interrupt(BoardNo=%d)"), siID);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_STOP_EVENT_MODE :			// Stop Event 지정
		/** 축 ID 범위 오류 */
		if ((siID < DEF_AXIS_NON_NO) || (siID > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		{
			//strLogMsg.Format(_T("IOInterrupt(): Invalid Axis ID(AxisID=%d is out of range)"), siID);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set IO Interrupt(BoardNo=%d)"), siID);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}

		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축의 Intterupt 시 Stop Event 설정 */
			if ((siResult = fio_interrupt_on_stop(siID, (short)bState)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("IOInterrupt(): fio_interrupt_on_stop(set whether activate STOP Event or not when I/O Interrupt occurs, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siID, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set IO Interrupt(BoardNo=%d)"), siID);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축의 Intterupt 시 Stop Event 설정 */
			if ((siResult = io_interrupt_on_stop(siID, (short)bState)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("IOInterrupt(): io_interrupt_on_stop(set whether activate STOP Event or not when I/O Interrupt occurs, and save in memory) Fail[AxisID=%d] - Error# is %d"), siID, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set IO Interrupt(BoardNo=%d)"), siID);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_ESTOP_EVENT_MODE :			// E-Stop Event 지정
		/** 축 ID 범위 오류 */
		if ((siID < DEF_AXIS_NON_NO) || (siID > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		{
			//strLogMsg.Format(_T("IOInterrupt(): Invalid Axis ID(AxisID=%d is out of range)"), siID);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set IO Interrupt(BoardNo=%d)"), siID);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}

		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축의 Intterupt 시 E-Stop Event 설정 */
			if ((siResult = fio_interrupt_on_e_stop(siID, (short)bState)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("IOInterrupt(): fio_interrupt_on_e_stop(set whether activate E-STOP Event or not when I/O Interrupt occurs, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siID, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set IO Interrupt(BoardNo=%d)"), siID);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축의 Intterupt 시 E-Stop Event 설정 */
			if ((siResult = io_interrupt_on_e_stop(siID, (short)bState)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("IOInterrupt(): io_interrupt_on_e_stop(set whether activate E-STOP Event or not when I/O Interrupt occurs, and save in memory) Fail[AxisID=%d] - Error# is %d"), siID, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set IO Interrupt(BoardNo=%d)"), siID);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	default :
		//strLogMsg.Format(_T("IOInterrupt(): Invalid Interrupt Type[AxisID=%d]"), siID);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set IO Interrupt(BoardNo=%d)"), siID);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106100);	// ERR_MLIB_INVALID_IO_INTTERUPT_TYPE
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * I/O Interrupt 발생 시 PC쪽으로 Interrupt를 발생시킬지 여부를 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : io_interrupt_pcirq(), fio_interrupt_pcirq()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	bState			: 발생 여부, TRUE=발생
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::IOInterruptPCIRQ(short siBdNum, BOOL bState, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("IOInterruptPCIRQ(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set PC Interrupt Required(BoardNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** PC쪽으로 Intterupt 발생 여부 설정 */
		if ((siResult = fio_interrupt_pcirq(siBdNum, (short)bState)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("IOInterruptPCIRQ(): fio_interrupt_pcirq(set whether activate Interrupt to PC or not when I/O Interrupt occurs, and save in boot file) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set PC Interrupt Required(BoardNo=%d)"), siBdNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** PC쪽으로 Intterupt 발생 여부 설정 */
		if ((siResult = io_interrupt_pcirq(siBdNum, (short)bState)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("IOInterruptPCIRQ(): io_interrupt_pcirq(set whether activate Interrupt to PC or not when I/O Interrupt occurs, and save in memory) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set PC Interrupt Required(BoardNo=%d)"), siBdNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * PC Interrupt 발생 시 end of interrupt 신호를 발생시킨다.
 *
 * MMC Library : io_interrupt_pcirq_eoi()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::IOInterruptPCIRQ_EOI(short siBdNum)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("IOInterruptPCIRQ_EOI(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC make End of Interrupt Signal(BoardNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

#ifndef SIMULATION
	/** Intterupt 발생 시 EOI 발생 여부 설정 */
	if ((siResult = io_interrupt_pcirq_eoi(siBdNum)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("IOInterruptPCIRQ_EOI(): io_interrupt_pcirq_eoi(set whether activate EQI or not when PC I/O Interrupt occurs) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC make End of Interrupt Signal(BoardNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 PID 제어 여부를 지정한다.
 *
 * MMC Library : controller_idle(), controller_run()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bState			: PID 제어 여부, FALSE=PID제어 미실시, Analog 출력 0volt,
 *											 TRUE =PID제어 실시
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetController(short siAxis, BOOL bState)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetController(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set PID Control(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** PID 미실시 */
	if (bState == FALSE)
	{
#ifndef SIMULATION
		/** 축의 PID 제어 미실시 설정 */
		if ((siResult = controller_idle(siAxis)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetController(): controller_idle(disable PID) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set PID Control(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** PID 실시 */
	else
	{
#ifndef SIMULATION
		/** 축의 PID 제어 실시 설정 */
		if ((siResult = controller_run(siAxis)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetController(): controller_run(enable PID) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set PID Control(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * AMP Disable/Enable 상태를 설정한다.
 *
 * MMC Library : set_amp_enable()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bState			: AMP Enable 상태, TRUE=Enable
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAmpEnable(short siAxis, BOOL bState)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetAmpEnable(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Amp Enable(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

#ifndef SIMULATION
	/** 축의 AMP Enable/Disable 설정 */
	if ((siResult = set_amp_enable(siAxis, (short)bState)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetAmpEnable(): set_amp_enable(enable or disable AMP) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Amp Enable(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 이동 최고속도와 가,감속 구간값의 Limit를 지정한다. (boot file에 자동 저장)
 *
 * MMC Library : set_accel_limit(), set_vel_limit()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	dVelocity		: 이동속도, 1 ~ 2047000 count/rev
 * @param	siAccel			: 가,감속구간값, 1 ~ 200, 10msec단위
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID VELOCITY VALUE (MOTIONLIB)
 *							  xx = INVALID ACCELERATE VALUE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetVelLimit(short siAxis, double dVelocity, short siAccel)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetVelLimit(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Velocity Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 이동속도 범위 오류 */
	if ((dVelocity < 0.0) || (dVelocity > DEF_VEL_LIMIT))
	{
		//strLogMsg.Format(_T("SetVelLimit(): Invalid Velocity(Vel=%f is out of range)"), dVelocity);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Velocity Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106076);	// ERR_MLIB_INVALID_VELOCITY_VALUE
	}

	/** 이동 가,감속도 범위 오류 */
	if ((siAccel < 0) || (siAccel > DEF_ACCEL_LIMIT))
	{
		//strLogMsg.Format(_T("SetVelLimit(): Invalid Accelerate Velocity(Accel=%d is out of range)"), siAccel);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Velocity Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106112);	// ERR_MLIB_INVALID_ACCELERATE_VALUE
	}

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

#ifndef SIMULATION
	/** 축의 이동 최고 속도 설정 */
	if ((siResult = set_vel_limit(siAxis, motionRoundValue(dVelocity))) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetVelLimit(): set_vel_limit(set velocity limit) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Velocity Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}

	/** 축의 이동 최고 가,감속도 구간 설정 */
	if ((siResult = set_accel_limit(siAxis, siAccel)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetVelLimit(): set_accel_limit(set accelerate limit) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Velocity Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * AMP Drive에 Fault 발생 시 동작할 Event를 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_amp_fault(), fset_amp_fault()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siAction		: 동작할 Event, NO EVENT, STOP EVENT, ESTOP EVENT, ABORT EVENT
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID EVENT VALUE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAmpFaultEvent(short siAxis, short siAction, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetAmpFaultEvent(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Amp Fault Event(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** Event 범위 오류 */
	if ((siAction < DEF_NO_EVENT) || (siAction > DEF_ABORT_EVENT))
	{
		//strLogMsg.Format(_T("SetAmpFaultEvent(): Invalid Event(Event=%d is out of range)"), siAction);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Amp Fault Event(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106105);	// ERR_MLIB_INVALID_EVENT_VALUE
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축의 AMP Driver에 Fault 발생 시 동작할 Event 설정 */
		if ((siResult = fset_amp_fault(siAxis, siAction)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAmpFaultEvent(): fset_amp_fault(set AMP Fault Event and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Amp Fault Event(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 축의 AMP Driver에 Fault 발생 시 동작할 Event 설정 */
		if ((siResult = set_amp_fault(siAxis, siAction)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAmpFaultEvent(): set_amp_fault(set AMP Fault Event and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Amp Fault Event(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * AMP Enable의 Active Level을 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_amp_enable_level(), fset_amp_enable_level()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bLevel			: Enable Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAmpEnableLevel(short siAxis, BOOL bLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetAmpEnableLevel(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Amp Enable Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축의 AMP Driver에 Enable의 Active Level 설정 */
		if ((siResult = fset_amp_enable_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAmpEnableLevel(): fset_amp_enable_level(set AMP Enable Level and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Amp Enable Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 축의 AMP Driver에 Enable의 Active Level 설정 */
		if ((siResult = set_amp_enable_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAmpEnableLevel(): set_amp_enable_level(set AMP Enable Level and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Amp Enable Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * AMP Fault의 Active Level을 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_amp_fault_level(), fset_amp_fault_level()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bLevel			: Fault Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAmpFaultLevel(short siAxis, BOOL bLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetAmpFaultLevel(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Amp Fault Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축의 AMP Driver에 Fault의 Active Level 설정 */
		if ((siResult = fset_amp_fault_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAmpFaultLevel(): fset_amp_fault_level(set AMP Fault Level and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Amp Fault Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 축의 AMP Driver에 Fault의 Active Level 설정 */
		if ((siResult = set_amp_fault_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAmpFaultLevel(): set_amp_fault_level(set AMP Fault Level and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Amp Fault Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * AMP Reset의 Active Level을 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_amp_reset_level(), fset_amp_reset_level()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bLevel			: Reset Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAmpResetLevel(short siAxis, BOOL bLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetAmpResetLevel(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Amp Reset Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축의 AMP Driver에 Reset의 Active Level 설정 */
		if ((siResult = fset_amp_reset_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAmpResetLevel(): fset_amp_reset_level(set AMP Reset Level and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Amp Reset Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 축의 AMP Driver에 Reset의 Active Level 설정 */
		if ((siResult = set_amp_reset_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAmpResetLevel(): set_amp_reset_level(set AMP Reset Level and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Amp Reset Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 AMP Drive의 Resolution을 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_amp_resolution(), fset_amp_resolution()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siResolution	: AMP Resolution, default=2500 pulse/rev
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID RESOLUTION NUMBER (<0) (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAmpResolution(short siAxis, short siResolution, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetAmpResolution(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Amp Resolution(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** Resuolution 범위 오류 */
/*	if (siResolution < 0)
	{
		strLogMsg.Format(_T("SetAmpResolution(): Invalid Resolution(Resolution=%d is out of range)", siResolution);
		WriteErrorLog(strLogMsg);
		return generateErrorCode(106081);	// ERR_MLIB_INVALID_RESOLUTION_NUMBER
	}
*/
	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축의 AMP Driver에 Resolution 설정 */
		if ((siResult = fset_amp_resolution(siAxis, siResolution)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAmpResolution(): fset_amp_resolution(set AMP Resolution and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Amp Resolution(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 축의 AMP Driver에 Resolution 설정 */
		if ((siResult = set_amp_resolution(siAxis, siResolution)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAmpResolution(): set_amp_resolution(set AMP Resolution and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Amp Resolution(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 분주비에 대한 분자값, 분모값을 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_encoder_ratioa(), fset_encoder_ratioa(),
 *				 set_encoder_ratiob(), fset_encoder_ratiob()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siRatioA		: Encoder 분주비 분자값
 * @param	siRatioB		: Encoder 분주비 분모값
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID DENOMINATOR (<1) (MOTIONLIB)
 *							  xx = INVALID MOLECULE (<1) (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetEncoderRatio(short siAxis, short siRatioA, short siRatioB, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetEncoderRatio(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Encoder Ratio(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 분자값 범위 오류 */
	if (siRatioA < 1)
	{
		//strLogMsg.Format(_T("SetEncoderRatio(): Invalid Numerator(Numerator=%d is out of range)"), siRatioA);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Encoder Ratio(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106098);	// ERR_MLIB_INVALID_MOLECULE
	}

	/** 분모값 범위 오류 */
	if (siRatioB < 1)
	{
		//strLogMsg.Format(_T("SetEncoderRatio(): Invalid Denominator(Denominator=%d is out of range)"), siRatioB);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Encoder Ratio(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106106);	// ERR_MLIB_INVALID_DENOMINATOR
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 분주비 분자값 설정 */
		if ((siResult = fset_encoder_ratioa(siAxis, siRatioA)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetEncoderRatio(): set_encoder_ratioa(set a numerator of an encoder ratio and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Encoder Ratio(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 분주비 분모값 설정 */
		if ((siResult = fset_encoder_ratiob(siAxis, siRatioB)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetEncoderRatio(): set_encoder_ratiob(set a denominator of an encoder ratio and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Encoder Ratio(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 분주비 분자값 설정 */
		if ((siResult = set_encoder_ratioa(siAxis, siRatioA)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetEncoderRatio(): set_encoder_ratioa(set a numerator of an encoder ratio and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Encoder Ratio(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 분주비 분모값 설정 */
		if ((siResult = set_encoder_ratiob(siAxis, siRatioB)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetEncoderRatio(): set_encoder_ratiob(set a denominator of an encoder ratio and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Encoder Ratio(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축을 회전/직선운동하는 무한회전 축으로 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_endless_linearax(), fset_endless_linearax(),
 *				 set_endless_rotationax(), fset_endless_rotationax()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bStatus			: 무한회전 축 설정여부
 * @param	siResolution	: Motor 1회전당 Pulse수
 * @param	bType			: 운동 종류, FALSE=직선, TRUE=회전
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID RESOLUTION NUMBER (<0) (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetEndlessAx(short siAxis, BOOL bStatus, short siResolution, BOOL bType, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetEndlessAx(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Endless Axis(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** Resuolution 범위 오류 */
	if (siResolution < 0)
	{
		//strLogMsg.Format(_T("SetEndlessAx(): Invalid Resolution(Resolution=%d is out of range)"), siResolution);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Endless Axis(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106081);	// ERR_MLIB_INVALID_RESOLUTION_NUMBER
	}

	/** 직선 운동 */
	if (bType == FALSE)
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 직선운동하는 무한회전축 설정 */
			if ((siResult = fset_endless_linearax(siAxis, bStatus, siResolution)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetEndlessAx(): fset_endless_linearax(set endless linear rotation and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Endless Axis(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 직선운동하는 무한회전축 설정 */
			if ((siResult = set_endless_linearax(siAxis, bStatus, siResolution)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetEndlessAx(): set_endless_linearax(set endless linear rotation and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Endless Axis(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
	}
	/** 회전 운동 */
	else
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 회전운동하는 무한회전축 설정 */
			if ((siResult = fset_endless_rotationax(siAxis, bStatus, siResolution)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetEndlessAx(): fset_endless_rotationax(set endless rotation and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Endless Axis(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 회전운동하는 무한회전축 설정 */
			if ((siResult = set_endless_rotationax(siAxis, bStatus, siResolution)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetEndlessAx(): set_endless_rotationax(set endless rotation and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Endless Axis(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 무한회전 축의 움직이는 영역을 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_endless_range(), fset_endless_range()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	dRange			: 이동 영역
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetEndlessRange(short siAxis, double dRange, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetEndlessRange(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Endless Axis Range(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 무한회전 영역 설정 */
		if ((siResult = fset_endless_range(siAxis, motionRoundValue(dRange))) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetEndlessRange(): fset_endless_range(set endless rotation range and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Endless Axis Range(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 무한회전 영역 설정 */
		if ((siResult = set_endless_range(siAxis, motionRoundValue(dRange))) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetEndlessRange(): set_endless_range(set endless rotation range and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Endless Axis Range(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 원점 복귀 시 Encoder의 C상 펄스 이용 여부를 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_index_required(), fset_index_required()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bIndexReq		: C상 펄스 사용 여부, TRUE =Home Sensor와 Encoder의 Index Pulse를 동시 검출,
 *												  FALSE=Home Sensor만 검출
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetIndexRequired(short siAxis, BOOL bIndexReq, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetIndexRequired(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Encoder C Phase Pulse Required(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** C상 펄스 사용여부 설정 */
		if ((siResult = fset_index_required(siAxis, (short)bIndexReq)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetIndexRequired(): fset_index_required(set C pulse and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Encoder C Phase Pulse Required(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** C상 펄스 사용여부 설정 */
		if ((siResult = set_index_required(siAxis, (short)bIndexReq)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetIndexRequired(): set_index_required(set C pulse and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Encoder C Phase Pulse Required(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축을 해당 Motor 종류로 제어하는 축으로 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_servo(), fset_servo(),
 *				 set_stepper(), fset_stepper(),
 *				 set_micro_stepper(), fset_micro_stepper()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siType			: Motor 종류, 0=속도형Servo, 1=일반Stepper, 2=MicroStepper 혹은 위치형Servo
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID MOTOR TYPE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetMotorType(short siAxis, short siType, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetMotorType(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Motor Type(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** Motor 종류에 따라 */
	switch (siType)
	{
	case DEF_SERVO_MOTOR :		// 속도형 Servo
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Servo Motor 설정인지 읽기 */
			if ((siResult = fset_servo(siAxis)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetMotorType(): fset_servo(set the axis which controls Servo Motor, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Motor Type(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축 Servo Motor 설정인지 읽기 */
			if ((siResult = set_servo(siAxis)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetMotorType(): set_servo(set the axis which controls Servo Motor, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Motor Type(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_STEPPER :			// 일반 Stepper
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 일반 Stepper Motor 설정인지 읽기 */
			if ((siResult = fset_stepper(siAxis)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetMotorType(): fset_stepper(set the axis which controls Stepper, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Motor Type(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축 일반 Stepper Motor 설정인지 읽기 */
			if ((siResult = set_stepper(siAxis)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetMotorType(): set_stepper(set the axis which controls Stepper, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Motor Type(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_MICRO_STEPPER :	// Micro Stepper 혹은 위치형 Servo
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Micro Stepper Motor 설정인지 읽기 */
			if ((siResult = fset_micro_stepper(siAxis)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetMotorType(): fset_micro_stepper(set the axis which controls Micro Stepper or Positio Type Servo, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Motor Type(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축 Micro Stepper Motor 설정인지 읽기 */
			if ((siResult = set_micro_stepper(siAxis)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetMotorType(): set_micro_stepper(set the axis which controls Micro Stepper or Positio Type Servo, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Motor Type(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	default :
		//strLogMsg.Format(_T("SetMotorType(): Invalid Motor Type[AxisID=%d]"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Motor Type(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106092);	// ERR_MLIB_INVALID_MOVE_TYPE
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축의 Feedback 장치와 Loop 형태를 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_feedback(), fset_feedback(),
 *				 set_closed_loop(), fset_closed_loop()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siDevice		: Feedback 장치, 0=ENCODER, 1=0~10volt입력, 2=-10~10volt입력
 * @param	bLoop			: Loop 형태, FALSE=Open Loop, TRUE=Closed Loop
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID MOTOR FEEDBACK DEVICE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAxisProperty(short siAxis, short siDevice, BOOL bLoop, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetAxisProperty(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Axis Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** Feedback Device 범위 오류 */
	if ((siDevice < DEF_FB_ENCODER) || (siDevice > DEF_FB_BIPOLAR))
	{
		//strLogMsg.Format(_T("SetAxisProperty(): Invalid Feedback Device (Device=%d is out of range)"), siDevice);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Axis Device Range(Device=%d)"), siDevice);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106095);	// ERR_MLIB_INVALID_MOTOR_FEEDBACK_DEVICE
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** Motor Feedback Divece 설정 */
		if ((siResult = fset_feedback(siAxis, siDevice)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAxisProperty(): fset_feedback(set feedback device and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Motor Feedback Device(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** Loop 형태 설정 */
		if ((siResult = fset_closed_loop(siAxis, (short)bLoop)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAxisProperty(): fset_closed_loop(set 'Closed_Loop or Open_Loop' and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Loop Type(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** Motor Feedback Divece 설정 */
		if ((siResult = set_feedback(siAxis, siDevice)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAxisProperty(): set_feedback(set feedback device and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Motor Feedback Device(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** Loop 형태 설정 */
		if ((siResult = set_closed_loop(siAxis, (short)bLoop)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAxisProperty(): set_closed_loop(set 'Closed_Loop or Open_Loop' and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Loop Type(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축의 분주비와 전자기어비를 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_pulse_ratio(), fset_pulse_ratio(),
 *				 set_electric_gear(), fset_electric_gear()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siPgratio		: Pulse 분주비, default=8
 * @param	dEgratio		: 전자기어비, default=1.0
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetRatioProperty(short siAxis, short siPgratio, double dEgratio, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetRatioProperty(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Ratio Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 펄스 분주비 설정 */
		if ((siResult = fset_pulse_ratio(siAxis, siPgratio)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetRatioProperty(): fset_pulse_ratio(set a pulse ratio and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Ratio Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 전자기어비 설정 */
		if ((siResult = fset_electric_gear(siAxis, motionRoundValue(dEgratio))) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetRatioProperty(): fset_electric_gear(set an electric gear ratio and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Ratio Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 펄스 분주비 설정 */
		if ((siResult = set_pulse_ratio(siAxis, siPgratio)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetRatioProperty(): set_pulse_ratio(set a pulse ratio and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Ratio Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 전자기어비 설정 */
		if ((siResult = set_electric_gear(siAxis, motionRoundValue(dEgratio))) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetRatioProperty(): set_electric_gear(set an electric gear ratio and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Ratio Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 속도형 Servo의 설정을 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_control(), fset_control(), set_unipolar(), fset_unipolar()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bControl		: 제어모드, FALSE=속도제어, TRUE=토크제어
 * @param	bPolar			: Analog 출력 종류,  TRUE=UNIPOLAR, FALSE=BIPOLER
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetVServoProperty(short siAxis, BOOL bControl, BOOL bPolar, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetVServoProperty(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Servo Properties(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 제어모드 설정 */
		if ((siResult = fset_control(siAxis, (short)bControl)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetVServoProperty(): fset_control(set 'Velocity Control Mode or Torque Control Mode' and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Servo Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** Analog 출력 종류 설정 */
		if ((siResult = fset_unipolar(siAxis, (short)bPolar)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetVServoProperty(): fset_unipolar(set an analog output UNIPOLAR and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Servo Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 제어모드 설정 */
		if ((siResult = set_control(siAxis, (short)bControl)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetVServoProperty(): set_control(set 'Velocity Control Mode or Torque Control Mode' and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Servo Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** Analog 출력 종류 설정 */
		if ((siResult = set_unipolar(siAxis, (short)bPolar)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetVServoProperty(): set_unipolar(set an analog output UNIPOLAR and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Servo Properties(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 Pulse 출력 형태를 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_step_mode(), fset_step_mode()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bMode			: Pulse 출력 형태, FALSE=Two Pulse(CW+CCW), TRUE=Sign+Pulse
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetStepMode(short siAxis, BOOL bMode, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetStepMode(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Step Pulse Type(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** Pulse 출력 형태 설정 */
		if ((siResult = fset_step_mode(siAxis, (short)bMode)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetStepMode(): fset_step_mode(set a pulse output 'CW+CCW Mode or Sign+Pulse Mode' and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Step Pulse Type(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** Pulse 출력 형태 설정 */
		if ((siResult = set_step_mode(siAxis, (short)bMode)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetStepMode(): set_step_mode(set a pulse output 'CW+CCW Mode or Sign+Pulse Mode' and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Step Pulse Type(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 Encoder 입력 방향과 좌표 방향을 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_encoder_direction(), fset_encoder_direction(),
 *				 set_coordinate_direction(), fset_coordinate_direction()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bEncDir			: Encoder 입력 방향, FALSE=ENCO_CW(시계방향, - count),
 *												 TRUE =ENCO_CCW(반시계방향, + count)
 * @param	bCoorDir		: 좌표방향, FALSE=CORD_CW(시계방향, +좌표이동),
 *										TRUE =CORD_CCW(반시계방향, -좌표이동)
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetEncoderDirection(short siAxis, BOOL bEncDir, BOOL bCoorDir, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetEncoderDirection(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Encoder Direction(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** Encoder 입력 방향 설정 */
		if ((siResult = fset_encoder_direction(siAxis, (short)bEncDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetEncoderDirection(): fset_encoder_direction(set an encoder input direction and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Encoder Direction(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 좌표 방향 설정 */
		if ((siResult = fset_coordinate_direction(siAxis, (short)bCoorDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetEncoderDirection(): fset_coordinate_direction(set a coordinate direction and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Encoder Direction(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** Encoder 입력 방향 설정 */
		if ((siResult = set_encoder_direction(siAxis, (short)bEncDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetEncoderDirection(): set_encoder_direction(set an encoder input direction and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Encoder Direction(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 좌표 방향 설정 */
		if ((siResult = set_coordinate_direction(siAxis, (short)bCoorDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetEncoderDirection(): set_coordinate_direction(set a coordinate direction and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Encoder Direction(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * I/O 8점에 대한  입,출력 모드를 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_io_mode(), fset_io_mode()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	bMode			: 입, 출력 모드, TRUE=출력, FALSE=입력
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetIOMode(short siBdNum, BOOL bMode, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("SetIOMode(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set IO Mode(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** I/O 입,출력 모드 설정 */
		if ((siResult = fset_io_mode(siBdNum, (short)bMode)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetIOMode(): fset_io_mode(set an I/O mode and save in boot file) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set IO Mode(BoradNo=%d)"), siBdNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** I/O 입,출력 모드 설정 */
		if ((siResult = set_io_mode(siBdNum, (short)bMode)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetIOMode(): set_io_mode(set an I/O mode and save in memory) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set IO Mode(BoradNo=%d)"), siBdNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}

/**
 * 축의 위치결정 완료값과 위치결정 시 신호 Level을 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_in_position(), fset_in_position(),
 *				 set_inposition_level(), fset_inposition_level()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	dInPosition		: 위치 결정값
 * @param	bLevel			: 신호 Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetInPosition(short siAxis, double dInPosition, BOOL bLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetInPosition(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Decision Value and Signal Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/**축의 위치결정 완료값 설정 */
		if ((siResult = fset_in_position(siAxis, motionRoundValue(dInPosition))) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetInPosition(): fset_in_position(set 'in_position' value and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Position Decision Value(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 축의 위치 결정 시 신호 Level 설정 */
		if ((siResult = fset_inposition_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetInPosition(): fset_inposition_level(set 'in_position' level and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Position Decision Signal Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/**축의 위치결정 완료값 설정 */
		if ((siResult = set_in_position(siAxis, motionRoundValue(dInPosition))) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetInPosition(): set_in_position(set 'in_position' value and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Position Decision Value(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

		/** 축의 위치 결정 시 신호 Level 설정 */
		if ((siResult = set_inposition_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetInPosition(): set_inposition_level(set 'in_position' level and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Position Decision Signal Level(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 InPosition 신호 사용여부를 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_inposition_required(), fset_inposition_required()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bReq			: 사용 여부, TRUE=사용
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetInpositionRequired(short siAxis, BOOL bReq, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetInpositionRequired(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set In-Position Signal Reauired(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** In-Position 신호 사용 여부 설정 */
		if ((siResult = fset_inposition_required(siAxis, (short)bReq)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetInpositionRequired(): fset_inposition_required(enable or disable 'in_position' and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set In-Position Signal Reauired(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** In-Position 신호 사용 여부 설정 */
		if ((siResult = set_inposition_required(siAxis, (short)bReq)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetInpositionRequired(): set_inposition_required(enable or disable 'in_position' and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set In-Position Signal Reauired(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 위치오차 Limit값과 Event를 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_error_limit(), fset_error_limit()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	dLimit			: 위치오차 Limit값, 최대 35000 count
 * @param	siAction		: 위치오차 Event, NO EVENT, STOP EVENT, ESTOP EVENT
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetErrorLimit(short siAxis, double dLimit, short siAction, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetErrorLimit(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Error Limit and Event(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}
	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축의 위치오차 Limit값과 Event 설정 */
		if ((siResult = fset_error_limit(siAxis, motionRoundValue(dLimit), siAction)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetErrorLimit(): fset_error_limit(set an error limit and event, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Position Error Limit and Event(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 축의 위치오차 Limit값과 Event 설정 */
		if ((siResult = set_error_limit(siAxis, motionRoundValue(dLimit), siAction)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetErrorLimit(): set_error_limit(set an error limit and event, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Position Error Limit and Event(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정된 축의 STOP EVENT, ESTOP EVENT 수행 시 감속 시간을 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_stop_rate(), fset_stop_rate(), set_e_stop_rate(), fset_e_stop_rate()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bType			: 정지 종류, FALSE=STOP, TRUE=ESTOP
 * @param	siRate			: 감속 시간, default=10
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetStopRate(short siAxis, BOOL bType, short siRate, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetStopRate(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Stop Rate(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** STOP Rate 설정 */
	if (bType == FALSE)
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** STOP Rate 설정 */
			if ((siResult = fset_stop_rate(siAxis, siRate)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetStopRate(): fset_stop_rate(set a reduction of speed when Stop Event activates, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Stop Rate(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** STOP Rate 설정 */
			if ((siResult = set_stop_rate(siAxis, siRate)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetStopRate(): set_stop_rate(set a reduction of speed when Stop Event activates, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Stop Rate(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
	}
	/** E-STOP Rate 설정 */
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** E-STOP Rate 설정 */
			if ((siResult = fset_e_stop_rate(siAxis, siRate)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetStopRate(): fset_e_stop_rate(set a reduction of speed when E-Stop Event activates, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Stop Rate(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** E-STOP Rate 설정 */
			if ((siResult = set_e_stop_rate(siAxis, siRate)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetStopRate(): set_e_stop_rate(set a reduction of speed when E-Stop Event activates, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Stop Rate(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * Home, +/- 방향 Limit Switch Active시 동작할 Event와 신호 Level을 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_home_level(), fset_home_level(),
 *				 set_home(), fset_home(),
 *				 set_positive_level(), fset_positive_level(),
 *				 set_positive_limit(), fset_positive_limit(),
 *				 set_negative_level(), fset_negative_level(),
 *				 set_negative_limit(), fset_negative_limit()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siType			: Sensor 종류, 0=Home, 1=Positive, 2=Negative
 * @param	siLimit			: 동작할 Event
 * @param	bLevel			: 신호 Level, TRUE=HIGH, FLASE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID SENSOR TYPE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetSensorLimit(short siAxis, short siType, short siLimit, BOOL bLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetSensorLimit(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	switch (siType)
	{
	case DEF_HOME_SENSOR :		// Home Sensor
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Home Sensor Active Level 설정 */
			if ((siResult = fset_home_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLimit(): fset_home_level(set an Active Level of home sensor and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}

			/** 축 Home Sensor Event 설정 */
			if ((siResult = fset_home(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLimit(): fset_home(set aan event when an axis arrives at home sensor, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축 Home Sensor Active Level 설정 */
			if ((siResult = set_home_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLimit(): set_home_level(set an Active Level of home sensor and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}

			/** 축 Home Sensor Event 설정 */
			if ((siResult = set_home(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLimit(): set_home(set aan event when an axis arrives at home sensor, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_POSITIVE_SENSOR :	// Positive Sensor
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Positive Sensor Active Level 설정 */
			if ((siResult = fset_positive_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLimit(): fset_positive_level(set an Active Status of positive sensor and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}

			/** 축 Positive Sensor Event 설정 */
			if ((siResult = fset_positive_limit(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLimit(): fset_positive_limit(set an event when positive sensor is Active, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축 Positive Sensor Active Level 설정 */
			if ((siResult = set_positive_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLimit(): set_positive_level(set an Active Status of positive sensor and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}

			/** 축 Positive Sensor Event 설정 */
			if ((siResult = set_positive_limit(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLimit(): set_positive_limit(set an event when positive sensor is Active, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_NEGATIVE_SENSOR :	// Negative Sensor
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Negative Sensor Active Level 설정 */
			if ((siResult = fset_negative_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLimit(): fset_negative_level(set an Active Status of negative sensor and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}

			/** 축 Negative Sensor Event 설정 */
			if ((siResult = fset_negative_limit(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLimit(): fset_negative_limit(set an event when negative sensor is Active, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축 Negative Sensor Active Level 설정 */
			if ((siResult = set_negative_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLimit(): set_negative_level(set an Active Status of negative sensor and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}

			/** 축 Negative Sensor Event 설정 */
			if ((siResult = set_negative_limit(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLimit(): set_negative_limit(set an event when negative sensor is Active, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Limit(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	default :
		return generateErrorCode(106079);	// ERR_MLIB_INVALID_SENSOR_TYPE
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * Home, +/- 방향 Limit Switch Active시 동작할 Event를 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siType			: Sensor 종류, 0=Home, 1=Positive, 2=Negative
 * @param	siLimit			: 동작할 Event
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID SENSOR TYPE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetSensorEvent(short siAxis, short siType, short siLimit, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	short siLevel = 10;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetSensorEvent(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Sensor Event(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	switch (siType)
	{
	case DEF_HOME_SENSOR :		// Home Sensor
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Home Sensor Event 설정 */
			if ((siResult = fset_home(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorEvent(): fset_home(set an event when an axis arrives at home sensor, and save in boot file) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Event(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축 Home Sensor Event 설정 */
			if ((siResult = set_home(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorEvent(): set_home(set an event when an axis arrives at home sensor, and save in memory) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Event(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_POSITIVE_SENSOR :	// Positive Sensor
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Positive Sensor Event 설정 */
			if ((siResult = fset_positive_limit(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorEvent(): fset_positive_limit(set an event when positive sensor is Active, and save in boot file) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Event(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축 Positive Sensor Event 설정 */
			if ((siResult = set_positive_limit(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorEvent(): set_positive_limit(set an event when positive sensor is Active, and save in memory) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Event(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_NEGATIVE_SENSOR :	// Negative Sensor
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Negative Sensor Event 설정 */
			if ((siResult = fset_negative_limit(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorEvent(): fset_negative_limit(set an event when negative sensor is Active, and save in boot file) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Event(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축 Negative Sensor Event 설정 */
			if ((siResult = set_negative_limit(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorEvent(): set_negative_limit(set an event when negative sensor is Active, and save in memory) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Event(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	default :
		//strLogMsg.Format(_T("SetSensorEvent(): Invalid Sensor Type[AxisID=%d]"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Sensor Event(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106079);	// ERR_MLIB_INVALID_SENSOR_TYPE
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * Home, +/- 방향 Limit Switch Active시 동작할 신호 Level을 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siType			: Sensor 종류, 0=Home, 1=Positive, 2=Negative
 * @param	bLevel			: 신호 Level, TRUE=HIGH, FLASE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID SENSOR TYPE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetSensorLevel(short siAxis, short siType, BOOL bLevel, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetSensorLevel(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Sensor Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	switch (siType)
	{
	case DEF_HOME_SENSOR :		// Home Sensor
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Home Sensor Active Level 설정 */
			if ((siResult = fset_home_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLevel(): fset_home_level(set an Active Level of home sensor, and save in boot file) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축 Home Sensor Active Level 설정 */
			if ((siResult = set_home_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLevel(): set_home_level(set an Active Level of home sensor, and save in memory) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_POSITIVE_SENSOR :	// Positive Sensor
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Positive Sensor Active Level 설정 */
			if ((siResult = fset_positive_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLevel(): fset_positive_level(set an Active Level of positive sensor, and save in boot file) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축 Positive Sensor Active Level 설정 */
			if ((siResult = set_positive_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLevel(): set_positive_level(set an Active Level of positive sensor, and save in memory) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_NEGATIVE_SENSOR :	// Negative Sensor
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축 Negative Sensor Active Level 설정 */
			if ((siResult = fset_negative_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLevel(): fset_negative_level(set an Active Level of negative sensor, and save in boot file) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축 Negative Sensor Active Level 설정 */
			if ((siResult = set_negative_level(siAxis, (short)bLevel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSensorLevel(): set_negative_level(set an Active Level of negative sensor, and save in memory) Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Sensor Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	default :
		//strLogMsg.Format(_T("SetSensorLevel(): Invalid Sensor Type[AxisID=%d]"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Sensor Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106079);	// ERR_MLIB_INVALID_SENSOR_TYPE
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * +/- 방향으로 Motor가 이동할 수 있는 Limit 위치값과 그 위치값에 도달했을 때 적용될 Event를 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_positive_sw_limit(), fset_positive_sw_limit(),
 *				 set_negative_sw_limit(), fset_negative_sw_limit()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bType			: 방향, FALSE=Negative, TRUE=Positive
 * @param	dPosition		: 제한 위치값, +/-2147483647
 * @param	siLimit			: 적용될 Event
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetSWLimit(short siAxis, BOOL bType, double dPosition, short siLimit, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetSWLimit(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Switch Level(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** Positive S/W 설정 */
	if (bType == DEF_POSITIVE_SW)
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** Positive 설정 */
			if ((siResult = fset_positive_sw_limit(siAxis, motionRoundValue(dPosition), siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSWLimit(): fset_positive_sw_limit(set a positive S/W limit and event, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Switch Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** Positive 설정 */
			if ((siResult = set_positive_sw_limit(siAxis, motionRoundValue(dPosition), siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSWLimit(): set_positive_sw_limit(set a positive S/W limit & event, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Switch Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
	}
	/** Negative S/W 설정 */
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** Negative 설정 */
			if ((siResult = fset_negative_sw_limit(siAxis, motionRoundValue(dPosition), siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSWLimit(): fset_negative_sw_limit(set a negative S/W limit & event, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Switch Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** Negative 설정 */
			if ((siResult = set_negative_sw_limit(siAxis, motionRoundValue(dPosition), siLimit)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetSWLimit(): set_negative_sw_limit(set a negative S/W limit & event, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Switch Level(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축의 속도 또는 위치에 대한 PID & FF Gain 값들을 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_gain(), fset_gain(), set_v_gain(), fset_v_gain()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bVelType		: 위치/속도 종류 지정, FALSE=위치, TRUE=속도
 * @param	*plGain			: Gain 값 배열, 배열인수 위치는 아래와 같다.
 *								0=GA_P, 1=GA_I, 2=GA_D, 3=GA_F, 4=GA_ILIMIT, 5=GAIN_NUMBER
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetGain(short siAxis, BOOL bVelType, long *plGain, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetGain(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set PID and FF Gain(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 위치 Gain */
	if (bVelType == FALSE)
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** Gain 설정 */
			if ((siResult = fset_gain(siAxis, plGain)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetGain(): fset_gain(set a gain and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set PID and FF Gain(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** Gain 설정 */
			if ((siResult = set_gain(siAxis, plGain)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetGain(): set_gain(set a gain and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set PID and FF Gain(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
	}
	/** 속도 Gain */
	else
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** Gain 설정 */
			if ((siResult = fset_v_gain(siAxis, plGain)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetGain(): fset_v_gain(set a velocity gain and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set PID and FF Gain(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** Gain 설정 */
			if ((siResult = set_v_gain(siAxis, plGain)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetGain(): set_v_gain(set a velocity gain and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set PID and FF Gain(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축의 적분 제어 시 적분 제어 모드를 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_p_integration(), fset_p_integration(),
 *				 set_v_integration(), fset_v_integration()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bType			: 제어모드, FALSE=위치, TRUE=속도
 * @param	bMode			: 적분제어 모드, FALSE=항상적용, TRUE=정지시적용
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetIntegration(short siAxis, BOOL bType, BOOL bMode, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetIntegration(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Intergration Mode(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 위치 */
	if (bType == FALSE)
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축의 적분 제어 모드 설정 */
			if ((siResult = fset_p_integration(siAxis, (short)bMode)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetIntegration(): fset_p_integration(set an integral control mode of position loop, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Intergration Mode(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축의 적분 제어 모드 설정 */
			if ((siResult = set_p_integration(siAxis, (short)bMode)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetIntegration(): set_p_integration(set an integral control mode of position loop, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Intergration Mode(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
	}
	/** 속도 */
	else
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
#ifndef SIMULATION
			/** 축의 적분 제어 모드 설정 */
			if ((siResult = fset_v_integration(siAxis, (short)bMode)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetIntegration(): fset_v_integration(set an integral control mode of velocity loop, and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Intergration Mode(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** memory에 설정 */
		else
		{
#ifndef SIMULATION
			/** 축의 적분 제어 모드 설정 */
			if ((siResult = set_v_integration(siAxis, (short)bMode)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("SetIntegration(): set_v_integration(set an integral control mode of velocity loop, and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC set Intergration Mode(AxisID=%d)"), siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 속도지령 혹은 토크 지령에 대해 Low Pass Filter 혹은 Notch Filter에 대한 Filter 값을 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_position_lowpass_filter(), fset_position_lowpass_filter(),
 *				 set_position_notch_filter(), fset_position_notch_filter(),
 *				 set_velocity_lowpass_filter(), fset_velocity_lowpass_filter(),
 *				 set_velocity_notch_filter(), fset_velocity_notch_filter()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bCommandType	: 지령 종류, FALSE=속도(Position), TRUE=토크(Velocity)
 * @param	bFilterType		: Filter 종류, FALSE=LowPass, TRUE=Notch
 * @param	dFilter			: Filter 값
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetFilter(short siAxis, BOOL bCommandType, BOOL bFilterType, double dFilter, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetFilter(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Filter(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 속도(Position) */
	if (bCommandType == FALSE)
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
			/** Low Pass */
			if (bFilterType == FALSE)
			{
#ifndef SIMULATION
				/** Posittion Low Pass Filter 설정 */
				if ((siResult = fset_position_lowpass_filter(siAxis, motionRoundValue(dFilter))) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("SetFilter(): fset_position_lowpass_filter(and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC set Filter(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#endif
			}
			/** Notch */
			else
			{
#ifndef SIMULATION
				/** Posittion Notch Filter 설정 */
				if ((siResult = fset_position_notch_filter(siAxis, motionRoundValue(dFilter))) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("SetFilter(): fset_position_notch_filter(and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC set Filter(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#endif
			}
		}
		/** memory에 설정 */
		else
		{
			/** Low Pass */
			if (bFilterType == FALSE)
			{
#ifndef SIMULATION
				/** Posittion Low Pass Filter 설정 */
				if ((siResult = set_position_lowpass_filter(siAxis, motionRoundValue(dFilter))) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("SetFilter(): set_position_lowpass_filter(and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC set Filter(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#endif
			}
			/** Notch */
			else
			{
#ifndef SIMULATION
				/** Posittion Notch Filter 설정 */
				if ((siResult = set_position_notch_filter(siAxis, motionRoundValue(dFilter))) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("SetFilter(): set_position_notch_filter(and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC set Filter(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#endif
			}
		}
	}
	/** 토크(Velocity) */
	else
	{
		/** boot file에 설정 */
		if (bBootOpt == TRUE)
		{
			/** Low Pass */
			if (bFilterType == FALSE)
			{
#ifndef SIMULATION
				/** Posittion Low Pass Filter 설정 */
				if ((siResult = fset_velocity_lowpass_filter(siAxis, motionRoundValue(dFilter))) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("SetFilter(): fset_velocity_lowpass_filter(and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC set Filter(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#endif
			}
			/** Notch */
			else
			{
#ifndef SIMULATION
				/** Posittion Notch Filter 설정 */
				if ((siResult = fset_velocity_notch_filter(siAxis, motionRoundValue(dFilter))) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("SetFilter(): fset_velocity_notch_filter(and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC set Filter(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#endif
			}
		}
		/** memory에 설정 */
		else
		{
			/** Low Pass */
			if (bFilterType == FALSE)
			{
#ifndef SIMULATION
				/** Posittion Low Pass Filter 설정 */
				if ((siResult = set_velocity_lowpass_filter(siAxis, motionRoundValue(dFilter))) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("SetFilter(): set_velocity_lowpass_filter(and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC set Filter(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#endif
			}
			/** Notch */
			else
			{
#ifndef SIMULATION
				/** Posittion Notch Filter 설정 */
				if ((siResult = set_velocity_notch_filter(siAxis, motionRoundValue(dFilter))) != ERR_MOTION_SUCCESS)
				{
					//strLogMsg.Format(_T("SetFilter(): set_velocity_notch_filter(and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
					//WriteErrorLog(strLogMsg);
					strLogMsg.Format(_T("MMC set Filter(AxisID=%d)"), siAxis);
					SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
					return makeMMCError((int)siResult);
				}
#endif
			}
		}
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정된 Board의 축별 동작 여부를 설정한다.
 *
 *		b7	b6	b5	b4	b3	b2	b1	b0
 *		축8	축7	축6	축5	축4	축3	축2	축1
 *
 *		bit = TRUE : 동작 금지
 *		bit = FALSE : 동작 가능
 *
 * MMC Library : set_axis_runstop()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	siState			: 축별 동작 여부, bit가 한 축 (b0=축1, b1=축2, ...), TRUE=정지, FALSE=동작
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAxisRunStop(short siBdNum, short siState)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("SetAxisRunStop(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Axis Run or Stop(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

#ifndef SIMULATION
	/** 축의 동작여부 설정 */
	if ((siResult = set_axis_runstop(siBdNum, siState)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetAxisRunStop(): set_axis_runstop(set 'Run or Stop') Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Axis Run or Stop(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 I/O bit를 HIGH(1)/LOW(0) 상태로 만든다.
 *
 *		 Board수	  I/O Bit 범위
 *			1			0  ~ 31
 *			2			32 ~ 63
 *			3			64 ~ 95
 *			4			96 ~ 127
 *
 * MMC Library : set_bit(), reset_bit()
 *
 * @param	siBitNo			: 지정할 I/O Bit 번호 (장착된 Board의 수량에 따라 달라짐)
 * @param	bValue			: 지정할 값, (TRUE, FALSE)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID IO BIT NUMBER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetBit(short siBitNo, BOOL bValue)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** I/O Bit 번호 범위 오류 */
	if ((siBitNo < DEF_MIN_IO_BIT) || (siBitNo > ((DEF_MAX_IO_PER_BOARD * siBdNum) - 1)))
	{
		//strLogMsg.Format(_T("SetBit(): Invalid I/O Bit Number(BitNo=%d is out of range)"), siBitNo);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Bit(BitNo=%d)"), siBitNo);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106101);	// ERR_MLIB_INVALID_IO_BIT_NUMBER
	}

	/** I/O Bit 설정 */
	if (bValue == TRUE)
	{
#ifndef SIMULATION
		if ((siResult = set_bit(siBitNo)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetBit(): set_bit(set bit HIGH Status) Fail[BitNo=%d] - Error# is %d"), siBitNo, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Bit(BitNo=%d)"), siBitNo);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** I/O Bit 해제 */
	else
	{
#ifndef SIMULATION
		if ((siResult = reset_bit(siBitNo)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetBit(): set_bit(set bit LOW Status) Fail[BitNo=%d] - Error# is %d"), siBitNo, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Bit(BitNo=%d)"), siBitNo);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 32bit의 I/O Data를 출력 Port를 통해 내보낸다.
 *
 * MMC Library : set_io()
 *
 * @param	siPort			: 출력 Port 번호 (0 ~ 7, Board 구성 개수에 따라 변동)
 * @param	lValue			: 출력 값
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID IO PORT ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetIO(short siPort, long lValue)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** I/O Port ID 범위 오류 */
	if ((siPort < DEF_MIN_IO_PORT) || (siPort > (siBdNum - 1)))
	{
		//strLogMsg.Format(_T("SetIO(): Invalid I/O Port ID(IOPortID=%d is out of range)"), siPort);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set IO Data(IOPortID=%d)"), siPort);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106099);	// ERR_MLIB_INVALID_IO_PORT_ID
	}

#ifndef SIMULATION
	/** Board의 출력 Port에 32 bit I/O 쓰기 */
	if ((siResult = set_io(siPort, lValue)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetIO(): set_io(set 32-bit data of output port) Fail[PortNo=%d] - Error# is %d"), siPort, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set IO Data(IOPortID=%d)"), siPort);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 12/16 bit Analog 출력전압을 내보낸다.
 *
 * MMC Library : set_dac_output()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siValue			: 출력할 전압 값, +/-2048, +/-32767
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetDacOut(short siAxis, short siValue)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetDacOut(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Analog Output(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

#ifndef SIMULATION
	/** Analog Output 출력 */
	if ((siResult = set_dac_output(siAxis, siValue)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetDacOut(): set_dac_output(set an analog output) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Analog Output(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 축의 Analog Offset값을 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_analog_offset(), fset_analog_offset()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siOffset		: Analog OFfset, +/-2048, +/-32767
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAnalogOffset(short siAxis, short siOffset, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetAnalogOffset(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Analog Offset(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축의 Analog Offset 설정 */
		if ((siResult = fset_analog_offset(siAxis, siOffset)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAnalogOffset(): fset_analog_offset(set an analog offset and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Analog Offset(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 축의 Analog Offset 설정 */
		if ((siResult = set_analog_offset(siAxis, siOffset)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAnalogOffset(): set_analog_offset(set an analog offset and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Analog Offset(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 축의 출력전압의 범위를 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_analog_limit(), fset_analog_limit()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siLimit			: A출력 전압 범위, 0 ~ 32767
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAnalogLimit(short siAxis, short siLimit, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetAnalogLimit(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Analog Limit(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 축의 Analog Limit 설정 */
		if ((siResult = fset_analog_limit(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAnalogLimit(): fset_analog_limit(set an analog limit and save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Analog Limit(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 축의 Analog Limit 설정 */
		if ((siResult = set_analog_limit(siAxis, siLimit)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetAnalogLimit(): set_analog_limit(set an analog limit and save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Analog Limit(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 축의 실제 위치 및 목표 위치를 지정한다. (AMP Disable 상태에서 수행하는게 좋다.)
 *
 * MMC Library : set_command(), set_position()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bType			: 위치 종류, FALSE=실제위치, TRUE=목표위치
 * @param	dPosition		: bType=FALSE이면 지정할 실제위치, bType=TRUE이면 지정할 목표위치
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetPosition(short siAxis, BOOL bType, double dPosition)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetPosition(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Axis Position(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 실제위치 설정 */
	if (bType == FALSE)
	{
#ifndef SIMULATION
		/** 축의 실제위치 설정 */
		if ((siResult = set_position(siAxis, motionRoundValue(dPosition / 4.0))) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetPosition(): set_position(set a current position) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Axis Position(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** 목표위치 설정 */
	else
	{
#ifndef SIMULATION
		/** 축의 목표위치 설정 */
		if ((siResult = set_command(siAxis, motionRoundValue(dPosition))) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetPosition(): set_command(set a target position) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Axis Position(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 특정 축의 Encoder Feedback Data를 빠르게 읽어들일 때 사용 (50usec 주기 Update)
 *
 * MMC Library : set_fast_read_encoder()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bStatus			: 설정 여부, TRUE=설정
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetFastReadEncoder(short siAxis, BOOL bStatus)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetFastReadEncoder(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC fast read Feedback Data(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

#ifndef SIMULATION
	/** Encoder Fast Read 설정 */
	if ((siResult = set_fast_read_encoder(siAxis, (short)bStatus)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetFastReadEncoder(): set_fast_read_encoder(enalbe or disable fast read encoder) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC fast read Feedback Data(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 사용자가 Motion 관련 S/W를 자체 개발하여 시스템을 동작시킬 수 있도록 지원해주는 기능
 *
 * MMC Library : set_interpolation()
 *
 * @param	siLen			: 제어대상 축 수, Board의 제어 축수와 일치시킨다. 8축 Board => 8, 4축 Board => 4
 * @param	*psiAxes		: 제어대상 축 ID를 배열구조로 설정
 * @param	*plDelt			: 매 Sampling Time(10msec)당 위치증가분 Data
 * @param	siFlag			: 속도 Profile의 시작과 끝을 알려주는데 사용, 1=동작시작, 2=동작중, 3=동작완료
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID AXIS NUMBER (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  xx = INVALID INTERPOLATION FLAG TYPE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetInterpolation(short siLen, short *psiAxes, long *plDelt, short siFlag)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 개수 범위 오류 */
	if (siLen != DEF_AXIS_NO_PER_BRD)
	{
		//strLogMsg.Format(_T("SetInterpolation(): Invalid Axis Number(AxisNo=%d is out of range)"), siLen);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set Interpolation"),3, __FILE__, __LINE__);
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER
	}

	/** 인수 Pointer 오류 */
	if (psiAxes == NULL)
	{
		//WriteErrorLog("SetInterpolation(): psiAxes Pointer is NULL");
		SetErrorLevel(_T("MMC set Interpolation"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (plDelt == NULL)
	{
		SetErrorLevel(_T("MMC set Interpolation"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 동작 시점 범위 오류 */
	if ((siFlag < DEF_START_MOVE) || (siFlag > DEF_END_MOVE))
	{
		//strLogMsg.Format(_T("SetInterpolation(): Invalid Action Point of Time(Time=%d is out of range)"), siFlag);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set Interpolation"),3, __FILE__, __LINE__);
		return generateErrorCode(106102);	// ERR_MLIB_INVALID_INTERPOLATION_FLAG_TYPE
	}

	/** 축 ID 범위 오류 */
	for (int i = 0; i < siLen; i++)
	{
		if ((psiAxes[i] < DEF_AXIS_NON_NO) || (psiAxes[i] > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		{
			//strLogMsg.Format(_T("SetInterpolation(): Invalid Axis ID(AxisID=%d is out of range)"), psiAxes[i]);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC set Interpolation"),3, __FILE__, __LINE__);
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}
	}

#ifndef SIMULATION
	/** Interpolation 설정 */
	if ((siResult = set_interpolation(siLen, psiAxes, plDelt, siFlag)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetInterpolation(): set_interpolation(enalbe or disable interpolation) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set Interpolation"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}

//**1222 충돌 방지 기능을 위해 MMC Library의 set_collision_prevent_ax()를 사용한다.
//** 기존 코딩은 set_collision_prevent()를 사용하는 것으로 되어 있었으나 이것을 수정한다. 
/**
 * 충돌방지 기능을 사용할 Mastr/Slave축 및 충돌방지 거리 및 조건 (+, -, >, <)을 설정한다.
 *
 * MMC Library : set_collision_prevent_ax()
 *
 * @param	siMasterAx		: Master 축 ID (0 ~ 63)
 * @param	siSlaveAx		: Slave 축 ID (0 ~ 63)
 * @param	bAddSub			: 오차 계산, FALSE=(Master현재위치-Slave현재위치),
 *										 TRUE=(Master현재위치+Slave현재위치)
 * @param	bNonEqual		: 비교, FALSE=(dPosition < bAddSub결과치),
 *									TRUE=(dPosition > bAddSub결과치)
 * @param	dPosition		: 충돌 방지 거리
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
// ** 1201
int MMMCLib::SetCollisionPrevent(short siMasterAx, short siSlaveAx,
								  BOOL bAddSub, BOOL bNonEqual, double dPosition, BOOL bState)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siMasterAx < DEF_AXIS_NON_NO) || (siMasterAx > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetCollisionPrevent(): Invalid Axis ID(AxisID=%d is out of range)"), siMasterAx);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set Collision Prevent"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 축 ID 범위 오류 */
	if ((siSlaveAx < DEF_AXIS_NON_NO) || (siSlaveAx > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetCollisionPrevent(): Invalid Axis ID(AxisID=%d is out of range)"), siSlaveAx);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set Collision Prevent"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

#ifndef SIMULATION
	if(bState)
	{
		/** 충돌방지 설정 */
		/*
		if ((siResult = set_collision_prevent(siMasterAx, siSlaveAx, (short)bAddSub, (short)bNonEqual, dPosition)) != ERR_MOTION_SUCCESS)
		{
			strLogMsg.Format(_T("SetCollisionPrevent(): set_collision_prevent(set axes, distance, condition) Fail[MasterAxID=%d, SlaveAxID=%d] - Error# is %d"), siMasterAx, siSlaveAx, siResult);
			WriteErrorLog(strLogMsg);
			return makeMMCError((int)siResult);
		}
		*/
		if ((siResult = set_collision_prevent_ax(siMasterAx, 1, siSlaveAx, 0, 0, dPosition, 1))  != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetCollisionPrevent(): set_collision_prevent(set axes, distance, condition) Fail[MasterAxID=%d, SlaveAxID=%d] - Error# is %d"), siMasterAx, siSlaveAx, siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC set Collision Prevent"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
	}
	else
	{
		if ((siResult = set_collision_prevent_ax(siMasterAx, 0, siSlaveAx, 0, 0, dPosition, 1))  != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetCollisionPrevent(): set_collision_prevent(set axes, distance, condition) Fail[MasterAxID=%d, SlaveAxID=%d] - Error# is %d"), siMasterAx, siSlaveAx, siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC set Collision Prevent"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
	}
#endif

	return ERR_MOTION_SUCCESS;
}

/**
 * 충돌방지 기능의 사용여부를 설정한다.
 *
 * MMC Library : set_collision_prevent_flag()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	bMode			: 사용 여부, TRUE=사용
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetCollisionPreventFlag(short siBdNum, BOOL bMode)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("SetCollisionPreventFlag(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Collision Prevent Flag(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

#ifndef SIMULATION
	/** 충돌방지 사용여부 설정 */
	if ((siResult = set_collision_prevent_flag(siBdNum, (short)bMode)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetCollisionPreventFlag(): set_collision_prevent_flag Fail[BoardNo%d] - Error# is %d"), siBdNum, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Collision Prevent Flag(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * Board DPRAM Address를 설정한다.
 *
 * MMC Library : set_dpram_addr()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	lAddr			: DPRAM Address
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetDpramAddress(short siBdNum, long lAddr)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	long rglAddr[8];
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber, rglAddr);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("SetDpramAddress(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set DPRAM Address(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

	/** DPRAM Address 설정 */
	if ((siResult = set_dpram_addr(siBdNum, lAddr)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetDpramAddress(): set_dpram_addr Fail[BoardNo%d] - Error# is %d"), siBdNum, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set DPRAM Address(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}

#ifndef SIMULATION
	/** Board 구성 설정 */
	rglAddr[siBdNum] = lAddr;
	if ((siResult = m_pBoardConfig->SetBoardNum(siBdNumber, rglAddr)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetDpramAddress(): SetBoardNum Fail[BoardNo%d] - Error# is %d"), siBdNum, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set DPRAM Address(BoradNo=%d)"), siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 절대치 Motor의 Type을 지정한다.
 *
 * MMC Library : set_abs_encoder_type()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siType			: Motor 종류, 1=삼성CSDJ, CSDJ+SERVO DRIVE, 2=YASKAWA SERVO DRIVE
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID ABS MOTOR TYPE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAbsEncoderType(short siAxis, short siType)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetAbsEncoderType(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Absolute Motor Type(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 절대치 Motor 종류 범위 오류 */
	if ((siType < DEF_SAMSUNGCSDJ) || (siType > DEF_YASKAWA_S3_SERVO_DRIVE))
	{
		//strLogMsg.Format(_T("SetAbsEncoderType(): Invalid Motor Type(Type=%d is out of range)"), siType);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Absolute Motor Type(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106113);	// ERR_MLIB_INVALID_ABS_MOTOR_TYPE
	}

#ifndef SIMULATION
	/** 절대치 Motor 종류 설정 */
	if ((siResult = set_abs_encoder_type(siAxis, siType)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetAbsEncoderType(): set_abs_encoder_type(set a type of an absolute motor) Fail[AxisID%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Absolute Motor Type(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 절대치 Motor를 설정한다.
 *
 * MMC Library : set_abs_encoder()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetAbsEncoder(short siAxis)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetAbsEncoder(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Absolute Motor(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

#ifndef SIMULATION
	/** 절대치 Motor 설정 */
	if ((siResult = set_abs_encoder(siAxis)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetAbsEncoderType(): set_abs_encoder(set an absolute motor) Fail[AxisID%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Absolute Motor(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * Servo Linear Flag 상태를 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_servo_linear_flag(), fset_servo_linear_flag()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siFlag			: Servo Linear Flag 상태
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetServoLinearFlag(short siAxis, short siFlag, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetServoLinearFlag(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Servo Linear Flag(AxisID=%d)"), siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** Servo Linear Flag 설정 */
		if ((siResult = fset_servo_linear_flag(siAxis, siFlag)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetServoLinearFlag(): fset_servo_linear_flag(save in boot file) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Servo Linear Flag(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** Servo Linear Flag 설정 */
		if ((siResult = set_servo_linear_flag(siAxis, siFlag)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetServoLinearFlag(): set_servo_linear_flag(save in memory) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Servo Linear Flag(AxisID=%d)"), siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;

}
/**
 * 동기제어 여부를 지정한다.
 *
 * MMC Library : set_sync_control()
 *
 * @param	bState			: 지정 여부, TRUE=동기제어 실행
 * @return	Error Code		: 0 = SUCCESS
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetSyncControl(BOOL bState)
{
	short siResult = ERR_MOTION_SUCCESS;
	CString strLogMsg;

#ifndef SIMULATION
	/** 동기제어 여부 설정 */
	if ((siResult = set_sync_control((short)bState)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetSyncControl(): set_sync_control(set whether use or not) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set Sync Control"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 동기제어할 Master축과 Slave축을 지정한다.
 *
 * MMC Library : set_sync_map_axes()
 *
 * @param	siMasterAx		: Master 축 ID (0 ~ 63)
 * @param	siSlaveAx		: Slave 축 ID (0 ~ 63)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetSyncMapAxes(short siMasterAx, short siSlaveAx)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siMasterAx < DEF_AXIS_NON_NO) || (siMasterAx > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetSyncMapAxes(): Invalid Axis ID(AxisID=%d is out of range)"), siMasterAx);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Sync Control(Mastr & Slave)(AxisID=%d)"),siMasterAx);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 축 ID 범위 오류 */
	if ((siSlaveAx < DEF_AXIS_NON_NO) || (siSlaveAx > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetSyncMapAxes(): Invalid Axis ID(AxisID=%d is out of range)"), siSlaveAx);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Sync Control(Mastr & Slave)(AxisID=%d)"),siMasterAx);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

#ifndef SIMULATION
	/** 동기제어 축 설정 */
	if ((siResult = set_sync_map_axes(siMasterAx, siSlaveAx)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetSyncMapAxes(): set_sync_map_axes(set master and slave axes) Fail[MasterAxID=%d, SlaveAxID=%d] - Error# is %d"), siMasterAx, siSlaveAx, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Sync Control(Mastr & Slave)(AxisID=%d)"),siMasterAx);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 동기제어시 적용되는 보상 Gain값을 지정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_sync_gain(), fset_sync_gain()
 *
 * @param	siCoeff			: 보상 Gain 값
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetSyncGain(short siCoeff, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	CString strLogMsg;

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** 보상 Gain 설정 */
		if ((siResult = fset_sync_gain(siCoeff)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetSyncGain(): fset_sync_gain(set a gain of synchronous control, and save in boot file) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC set Sync Control Gain"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** 보상 Gain 설정 */
		if ((siResult = set_sync_gain(siCoeff)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetSyncGain(): set_sync_gain(set a gain of synchronous control, and save in memory) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC set Sync Control Gain"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * Board별 Sampling Rate를 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * MMC Library : set_control_timer(), fset_control_timer()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	siTime			: Sampling Time(msec 단위) (1=4msec, 2=2msec, 3=1msec만 지원)
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  xx = INVALID SAMPLING RATE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetControlTimer(short siBdNum, short siTime, BOOL bBootOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("SetControlTimer(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Control Timer.(BoradNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

	/** Sampling Rate 범위 오류 */
	if ((siTime < DEF_SAMPLING_4MSEC) || (siTime > DEF_SAMPLING_1MSEC))
	{
		//strLogMsg.Format(_T("SetControlTimer(): Invalid Sampling Rate(Rate=%d is out of range)"), siTime);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Control Timer.(BoradNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106080);	// ERR_MLIB_INVALID_SAMPLING_RATE
	}

	/** boot file에 설정 */
	if (bBootOpt == TRUE)
	{
#ifndef SIMULATION
		/** Board의 Sampling Rate 설정 */
		if ((siResult = fset_control_timer(siBdNum, siTime)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetControlTimer(): fset_control_timer(set a sampling rate and save in boot file) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Control Timer.(BoradNo=%d)"),siBdNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}
	/** memory에 설정 */
	else
	{
#ifndef SIMULATION
		/** Board의 Sampling Rate 설정 */
		if ((siResult = set_control_timer(siBdNum, siTime)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetControlTimer(): set_control_timer(set a sampling rate and save in memory) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Control Timer.(BoradNo=%d)"),siBdNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 직선 동작 혹은 직선, 원, 원호등의 동작 시 속도와 가,감속도를 지정한다.
 *
 * MMC Library : set_move_accel(), set_move_speed()
 *
 * @param	dVelocity		: 속도
 * @param	siAccel			: 가,감속도
 * @return	Error Code		: 0 = SUCCESS
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetMoveSpeed(double dVelocity, short siAccel)
{
	short siResult = ERR_MOTION_SUCCESS;
	CString strLogMsg;

	/** 속도 설정 */
	if ((siResult = set_move_speed(motionRoundValue(dVelocity))) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetMoveSpeed(): set_move_speed(velocity) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set Move Speed."),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

#ifndef SIMULATION
	/** 가,감속도 설정 */
	if ((siResult = set_move_accel(siAccel)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetMoveSpeed(): set_move_accel(accelerate velocity) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set Move Speed."),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 자동 가,감속 기능의 사용여부를 지정한다.
 *
 * MMC Library : set_spl_auto_off()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	bState			: 사용여부, FALSE=사용
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetSplAutoOff(short siBdNum, BOOL bState)
{
	short siResult = ERR_MOTION_SUCCESS;
	SMotionBoard	mBd;
	CString strLogMsg;

	/** Board 설정 읽기 */
	if ((siResult = m_pBoardConfig->GetBoardConfig(&mBd)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetSplAutoOff(): GetBoardConfig Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Auto Acc/Decel Use or Unuse(BoardNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (mBd.iMaxBoardNo - 1)))
	{
		//strLogMsg.Format(_T("SetSplAutoOff(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Auto Acc/Decel Use or Unuse(BoardNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}

#ifndef SIMULATION
	/** 자동 가,감속 기능 사용여부 설정 */
	if ((siResult = set_spl_auto_off(siBdNum, (short)bState)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetMoveSpeed(): set_move_accel(accelerate velocity) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Auto Acc/Decel Use or Unuse(BoardNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	/** 자동 가,감속 기능 사용여부 설정 읽기 */
	mBd.rgbAutoCP[siBdNum] = bState;

	/** Board 설정 */
	if ((siResult = m_pBoardConfig->SetBoardConfig(mBd)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetSplAutoOff(): SetBoardConfig Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Auto Acc/Decel Use or Unuse(BoardNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 자동 가,감속 기능의 사용여부를 읽는다.
 * Library에 제공되는 함수가 없는 관계로 설정 Data에서 읽어온다.
 *
 * MMC Library : 
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	*pbState		: 사용여부, TURE=사용
 * @return	Error Code		: ERR_MOTION_SUCCESS = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::GetSplAutoOff(short siBdNum, BOOL *pbState)
{
	short siResult = ERR_MOTION_SUCCESS;
	SMotionBoard	mBd;
	CString strLogMsg;

	/** Board 설정 읽기 */
	if ((siResult = m_pBoardConfig->GetBoardConfig(&mBd)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("GetSplAutoOff(): GetBoardConfig Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC read Auto Acc/Decel Use or Unuse(BoardNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (mBd.iMaxBoardNo - 1)))
	{
		//strLogMsg.Format(_T("GetSplAutoOff(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC read Auto Acc/Decel Use or Unuse(BoardNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}

	/** 인수 Pointer 오류 */
	if (pbState == NULL)
	{
		//WriteErrorLog("GetSplAutoOff(): pbState Pointer is NULL");
		strLogMsg.Format(_T("MMC read Auto Acc/Decel Use or Unuse(BoardNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 자동 가,감속 기능 사용여부 설정 읽기 */
	*pbState = mBd.rgbAutoCP[siBdNum];

	return ERR_MOTION_SUCCESS;
}

/*
 * 축 이동 정지 (V-Stop) 이벤트를 날린다. 
 */
int MMMCLib::SetStopEvent(short siAxis)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;
	MTickTimer m_Timer;
	
	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);
	
	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetStop(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Vertical Move Stop(AxisID=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}
	
	/** Stop 설정 */
	if ((siResult = v_move_stop(siAxis)) != ERR_MOTION_SUCCESS)
	{
		clear_status(siAxis);
		//strLogMsg.Format(_T("SetStop(): set_stop(generate STOP Event and stop the movement of an axis) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Vertical Move Stop(AxisID=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
	
	clear_status(siAxis);

	return siResult;
}

/**
 * 축 이동을 정지한다.
 * 일반정지, 비상정지, 속도이동정지를 제공한다.
 *
 * MMC Library : set_stop(), set_e_stop(), v_move_stop()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siType			: 정지 종류, 0=STOP, 1=ESTOP, 2=VSTOP
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID STOP TYPE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetStop(short siAxis, short siType)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;
	MTickTimer m_Timer;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SetStop(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Axis Stop(AxisID=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** STOP 종류에 따라 */
	switch (siType)
	{
	case DEF_STOP :		// STOP
#ifndef SIMULATION
		/** Stop 설정 */
		if ((siResult = set_stop(siAxis)) != ERR_MOTION_SUCCESS)
		{
			clear_status(siAxis);
			//strLogMsg.Format(_T("SetStop(): set_stop(generate STOP Event and stop the movement of an axis) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Axis Stop(AxisID=%d)"),siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

//		MTickTimer m_Timer;
		m_Timer.StartTimer();
		while(!axis_done(siAxis)) 
		{
			if(m_Timer.MoreThan(10))
			{
				clear_status(siAxis);
				strLogMsg.Format(_T("MMC set Axis Stop(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return generateErrorCode(106121);
			}

			Sleep(5);
		}
		clear_status(siAxis);
#endif
		break;
	case DEF_ESTOP :	// E-STOP
#ifndef SIMULATION
		/** E-Stop 설정 */
		if ((siResult = set_e_stop(siAxis)) != ERR_MOTION_SUCCESS)
		{
			clear_status(siAxis);
			//strLogMsg.Format(_T("SetStop(): set_e_stop(generate E-STOP Event and stop the movement of an axis) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Axis Stop(AxisID=%d)"),siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}

//		MTickTimer m_Timer;
		m_Timer.StartTimer();
		while(!axis_done(siAxis)) 
		{
			if(m_Timer.MoreThan(10))
			{
				clear_status(siAxis);
				strLogMsg.Format(_T("MMC set Axis Stop(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return generateErrorCode(106121);
			}
			
			Sleep(3);
		}
		clear_status(siAxis);
#endif
		break;
	case DEF_VSTOP :	// V-STOP
#ifndef SIMULATION
		/** V-Stop 설정 */
		if ((siResult = v_move_stop(siAxis)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SetStop(): v_move_stop(stop the velocity movement of an axis) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Axis Stop(AxisID=%d)"),siAxis);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	default :
		//strLogMsg.Format(_T("SetStop(): Invalid Stop Type[AxisID=%d]"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Axis Stop(AxisID=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106077);	// ERR_MLIB_INVALID_STOP_TYPE
	}

// ljh0411	V-Stop에서는 해줄 필요 없음.
//	//20060405 KSM (add to clear_status, Referenced by P-1)
//#ifndef SIMULATION
//	MTickTimer m_Timer;
//	m_Timer.StartTimer();
//	while(!axis_done(siAxis)) 
//	{
//		if(m_Timer.MoreThan(10))
//			return generateErrorCode(106121);
//		Sleep(1);
//	}
//	clear_status(siAxis);
//#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 1축 속도 Profile 이동 (축 1개 단위만 이동 가능함)
 *
 * MMC Library : move(), start_move(),
 *				 s_move(), start_s_move(),
 *				 r_move(), start_r_move(),
 *				 rs_move(), start_rs_move(),
 *				 t_move(), start_t_move(),
 *				 ts_move(), start_ts_move(),
 *				 tr_move(), start_tr_move(),
 *				 trs_move(), start_trs_move()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	dPosition		: 이동할 위치, 혹은 상대거리
 * @param	dVelocity		: 이동 속도
 * @param	siAccel			: 이동 가속도
 * @param	siDecel			: 이동 감속도 (비대칭(t) Type만 적용)
 * @param	siType			: 이동 Type, 0=사다리꼴 속도 Profile, 절대좌표 이동
 *										 1=S-Curve 속도 Profile, 절대좌표 이동
 *										 2=사다리꼴 속도 Profile, 상대거리 이동
 *										 3=S-Curve 속도 Profile, 상대거리 이동
 *										 4=비대칭 사다리꼴 속도 Profile, 절대좌표 이동
 *										 5=비대칭 S-Curve 속도 Profile, 절대좌표 이동
 *										 6=비대칭 사다리꼴 속도 Profile, 상대거리 이동
 *										 7=비대칭 S-Curve 속도 Profile, 상대거리 이동
 * @param	bWaitOpt		: (OPTION=FALSE) 이동 완료 대기 여부, TRUE=이동완료될때까지대기
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID MOVE TYPE (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::Move(short siAxis, double dPosition, double dVelocity, short siAccel,
				   short siDecel, short siType, BOOL bWaitOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("Move(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	siDecel = (short)siDecel/4;

	// **050112
	if(siAccel <= 0) siAccel = 1;
	if(siDecel <= 0) siDecel = 1;

	/** 이동 종류에 따라 */
	switch (siType)
	{
	case DEF_MOVE_POSITION :		// 사다리꼴 속도 Profile, 절대좌표 이동
		/** 이동완료 대기 */
		if (bWaitOpt == TRUE)
		{
#ifndef SIMULATION
			/** move */
			if ((siResult = move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): move(trapezoid velocity profile, absolute coordinates, wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** 이동완료 미대기 */
		else
		{
#ifndef SIMULATION
			/** start_move */
			if ((siResult = start_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): start_move(trapezoid velocity profile, absolute coordinates, no wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_SMOVE_POSITION :		// S-Curve 속도 Profile, 절대좌표 이동
		/** 이동완료 대기 */
		if (bWaitOpt == TRUE)
		{
#ifndef SIMULATION
			/** s_move */
			if ((siResult = s_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): s_move(S-Curve velocity profile, absolute coordinates, wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** 이동완료 미대기 */
		else
		{
#ifndef SIMULATION
			/** start_s_move */
			if ((siResult = start_s_move(siAxis, dPosition, dVelocity, siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): start_s_move(S-Curve velocity profile, absolute coordinates, no wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_MOVE_DISTANCE :		// 사다리꼴 속도 Profile, 상대거리 이동
		/** 이동완료 대기 */
		if (bWaitOpt == TRUE)
		{
#ifndef SIMULATION
			/** r_move */
			if ((siResult = r_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): r_move(trapezoid velocity profile, relative coordinates, wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** 이동완료 미대기 */
		else
		{
#ifndef SIMULATION
			/** start_r_move */
			if ((siResult = start_r_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): start_r_move(trapezoid velocity profile, relative coordinates, no wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_SMOVE_DISTANCE :		// S-Curve 속도 Profile, 상대거리 이동
		/** 이동완료 대기 */
		if (bWaitOpt == TRUE)
		{
#ifndef SIMULATION
			/** rs_move */
			if ((siResult = rs_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): rs_move(S-Curve velocity profile, relative coordinates, wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** 이동완료 미대기 */
		else
		{
#ifndef SIMULATION
			/** start_rs_move */
			if ((siResult = start_rs_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): start_rs_move(S-Curve velocity profile, relative coordinates, no wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_TMOVE_POSITION :		// 비대칭 사다리꼴 속도 Profile, 절대좌표 이동
		/** 이동완료 대기 */
		if (bWaitOpt == TRUE)
		{
#ifndef SIMULATION
			/** t_move */
			if ((siResult = t_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel, siDecel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): t_move(asymmetry trapezoid velocity profile, absolute coordinates, wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** 이동완료 미대기 */
		else
		{
#ifndef SIMULATION
			/** start_t_move */
			if ((siResult = start_t_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel, siDecel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): start_t_move(asymmetry trapezoid velocity profile, absolute coordinates, no wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_TSMOVE_POSITION :		// 비대칭 S-Curve 속도 Profile, 절대좌표 이동
		/** 이동완료 대기 */
		if (bWaitOpt == TRUE)
		{
#ifndef SIMULATION
			/** ts_move */
			if ((siResult = ts_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel, siDecel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): ts_move(asymmetry S-Curve velocity profile, absolute coordinates, wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** 이동완료 미대기 */
		else
		{
#ifndef SIMULATION
			/** start_ts_move */
			if ((siResult = start_ts_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel, siDecel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): start_ts_move(asymmetry S-Curve velocity profile, absolute coordinates, no wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_TMOVE_DISTANCE :		// 비대칭 사다리꼴 속도 Profile, 상대거리 이동
		/** 이동완료 대기 */
		if (bWaitOpt == TRUE)
		{
#ifndef SIMULATION
			/** tr_move */
			if ((siResult = tr_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel, siDecel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): t_move(asymmetry trapezoid velocity profile, relative coordinates, wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** 이동완료 미대기 */
		else
		{
#ifndef SIMULATION
			/** start_tr_move */
			if ((siResult = start_tr_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel, siDecel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): t_move(asymmetry trapezoid velocity profile, relative coordinates, no wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_TSMOVE_DISTANCE :		// 비대칭 S-Curve 속도 Profile, 상대거리 이동
		/** 이동완료 대기 */
		if (bWaitOpt == TRUE)
		{
#ifndef SIMULATION
			/** trs_move */
			if ((siResult = trs_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel, siDecel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): trs_move(asymmetry S-Curve velocity profile, relative coordinates, wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** 이동완료 미대기 */
		else
		{
#ifndef SIMULATION
			/** start_trs_move */
			if ((siResult = start_trs_move(siAxis, motionRoundValue(dPosition), motionRoundValue(dVelocity), siAccel, siDecel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("Move(): start_trs_move(asymmetry S-Curve velocity profile, relative coordinates, no wait) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	default :
		//strLogMsg.Format(_T("Move(): Invalid Move Type[AxisID=%d]"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC move 1 Axis(AxisID=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106092);	// ERR_MLIB_INVALID_MOVE_TYPE
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 다축 속도 Profile 동시 이동 (상대거리 이동은 지원하지 않는다.)
 *
 *		|----------------> siLen = n <----------------|
 *		+---------+---------+---------+-----+---------+
 *		| 축 ID#1 | 축 ID#2 | 축 ID#3 | ... | 축 ID#n |
 *		+---------+---------+---------+-----+---------+
 *		| 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+-----+---------+
 *		| 속도 #1 | 속도 #2 | 속도 #3 | ... | 속도 #n |
 *		+---------+---------+---------+-----+---------+
 *		| 가속 #1 | 가속 #2 | 가속 #3 | ... | 가속 #n |
 *		+---------+---------+---------+-----+---------+
 *		| 감속 #1 | 감속 #2 | 감속 #3 | ... | 감속 #n |
 *		+---------+---------+---------+-----+---------+
 *
 * MMC Library : move_all(), start_move_all(),
 *				 s_move_all(), start_s_move_all(),
 *				 t_move_all(), start_t_move_all(),
 *				 ts_move_all(), start_ts_move_all(),
 *
 * @param	siLen			: 축 수, >0
 * @param	*psiAxis		: 축 ID (축 수 만큼 존재)
 * @param	*pdPosition		: 이동할 위치, 혹은 상대거리 (축 수 만큼 존재)
 * @param	*pdVelocity		: 이동 속도 (축 수 만큼 존재)
 * @param	*psiAccel		: 이동 가속도 (축 수 만큼 존재)
 * @param	*psiDecel		: 이동 감속도 (축 수 만큼 존재)
 * @param	siType			: 이동 Type, 0=사다리꼴 속도 Profile, 절대좌표 이동
 *										 1=S-Curve 속도 Profile, 절대좌표 이동
 *										 4=비대칭 사다리꼴 속도 Profile, 절대좌표 이동
 *										 5=비대칭 S-Curve 속도 Profile, 절대좌표 이동
 * @param	bWaitOpt		: (OPTION=FALSE) 이동 완료 대기 여부, TRUE=이동완료될때까지대기
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID AXIS NUMBER (MOTIONLIB)
 *							  xx = INVALID MOVE TYPE (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::MoveAll(short siLen, short *psiAxes, double *pdPosition, double *pdVelocity,
					  short *psiAccel, short *psiDecel, short siType, BOOL bWaitOpt)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	double rgdVel[DEF_MAX_AXIS_NO];
	double rgdPos[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 개수 범위 오류 */
	if (siLen <= DEF_AXIS_NON_NO)
	{
		//strLogMsg.Format(_T("MoveAll(): Invalid Axis Number(AxisNo=%d is out of range)"), siLen);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER
	}

	/** 인수 Pointer 오류 */
	if (psiAxes == NULL)
	{
		//WriteErrorLog("MoveAll(): psiAxes Pointer is NULL");
		SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 축 ID 범위 오류 */
	for (int i = 0; i < siLen; i++)
	{
		if ((psiAxes[i] < DEF_AXIS_NON_NO) || (psiAxes[i] > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		{
			//strLogMsg.Format(_T("MoveAll(): Invalid Axis ID(AxisID=%d is out of range)"), psiAxes[i]);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}
	}

	/** 인수 Pointer 오류 */
	if (pdPosition == NULL)
	{
		//WriteErrorLog("MoveAll(): pdPosition Pointer is NULL");
		SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pdVelocity == NULL)
	{
		//WriteErrorLog("MoveAll(): pdVelocity Pointer is NULL");
		SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (psiAccel == NULL)
	{
		//WriteErrorLog("MoveAll(): psiAccel Pointer is NULL");
		SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	for (int i=0; i<siLen; i++)
	{
		rgdPos[i] = motionRoundValue(*(pdPosition + i));
		rgdVel[i] = motionRoundValue(*(pdVelocity + i));
	}

	// **1202 -> msec 단위로 수정
	short *psiTempAccel;
	short *psiTempDecel;

	psiTempAccel = new short[siLen];
	psiTempDecel = new short[siLen];

	for (int i=0; i<siLen; i++)
	{
		psiTempAccel[i] = (short)psiAccel[i]/4;
		psiTempDecel[i] = (short)psiDecel[i]/4;
	}

	/** 이동 종류에 따라 */
	switch (siType)
	{
	case DEF_MOVE_POSITION :		// 사다리꼴 속도 Profile, 절대좌표 이동
		/** 이동완료 대기 */
		if (bWaitOpt == TRUE)
		{
#ifndef SIMULATION
			/** move_all */
			if ((siResult = move_all(siLen, psiAxes, pdPosition, pdVelocity, psiTempAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveAll(): move_all(trapezoid velocity profile, absolute coordinates, wait) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
				delete[] psiTempAccel;
				delete[] psiTempDecel;
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** 이동완료 미대기 */
		else
		{
#ifndef SIMULATION
			/** start_move_all */
			if ((siResult = start_move_all(siLen, psiAxes, pdPosition, pdVelocity, psiTempAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveAll(): start_move_all(trapezoid velocity profile, absolute coordinates, no wait) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
				delete[] psiTempAccel;
				delete[] psiTempDecel;
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_SMOVE_POSITION :		// S-Curve 속도 Profile, 절대좌표 이동
		/** 이동완료 대기 */
		if (bWaitOpt == TRUE)
		{
#ifndef SIMULATION
			/** s_move_all */
			if ((siResult = s_move_all(siLen, psiAxes, pdPosition, pdVelocity, psiTempAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveAll(): s_move_all(S-Curve velocity profile, absolute coordinates, wait) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
				delete[] psiTempAccel;
				delete[] psiTempDecel;
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** 이동완료 미대기 */
		else
		{
#ifndef SIMULATION
			/** start_s_move_all */
			if ((siResult = start_s_move_all(siLen, psiAxes, pdPosition, pdVelocity, psiTempAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveAll(): start_s_move_all(S-Curve velocity profile, absolute coordinates, no wait) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
				delete[] psiTempAccel;
				delete[] psiTempDecel;
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_TMOVE_POSITION :		// 비대칭 사다리꼴 속도 Profile, 절대좌표 이동
		/** 인수 Pointer 오류 */
		if (psiDecel == NULL)
		{
			//WriteErrorLog("MoveAll(): psiDecel Pointer is NULL");
			SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
			delete[] psiTempAccel;
			delete[] psiTempDecel;
			return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
		}

		/** 이동완료 대기 */
		if (bWaitOpt == TRUE)
		{
#ifndef SIMULATION
			/** t_move_all */
			if ((siResult = t_move_all(siLen, psiAxes, pdPosition, pdVelocity, psiTempAccel, psiTempDecel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveAll(): t_move_all(asymmetry trapezoid velocity profile, absolute coordinates, wait) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
				delete[] psiTempAccel;
				delete[] psiTempDecel;
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** 이동완료 미대기 */
		else
		{
#ifndef SIMULATION
			/** start_t_move_all */
			if ((siResult = start_t_move_all(siLen, psiAxes, pdPosition, pdVelocity, psiTempAccel, psiTempDecel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveAll(): start_t_move_all(asymmetry trapezoid velocity profile, absolute coordinates, no wait) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
				delete[] psiTempAccel;
				delete[] psiTempDecel;
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	case DEF_TSMOVE_POSITION :		// 비대칭 S-Curve 속도 Profile, 절대좌표 이동
		/** 인수 Pointer 오류 */
		if (psiDecel == NULL)
		{
			//WriteErrorLog("MoveAll(): psiDecel Pointer is NULL");
			SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
			delete[] psiTempAccel;
			delete[] psiTempDecel;
			return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
		}

		/** 이동완료 대기 */
		if (bWaitOpt == TRUE)
		{
#ifndef SIMULATION
			/** ts_move_all */
			if ((siResult = ts_move_all(siLen, psiAxes, pdPosition, pdVelocity, psiTempAccel, psiTempDecel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveAll(): ts_move_all(asymmetry S-Curve velocity profile, absolute coordinates, wait) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
				delete[] psiTempAccel;
				delete[] psiTempDecel;
				return makeMMCError((int)siResult);
			}
#endif
		}
		/** 이동완료 미대기 */
		else
		{
#ifndef SIMULATION
			/** start_ts_move_all */
			if ((siResult = start_ts_move_all(siLen, psiAxes, pdPosition, pdVelocity, psiTempAccel, psiTempDecel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveAll(): start_ts_move_all(asymmetry S-Curve velocity profile, absolute coordinates, no wait) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
				delete[] psiTempAccel;
				delete[] psiTempDecel;
				return makeMMCError((int)siResult);
			}
#endif
		}
		break;
	default :
		//WriteErrorLog("MoveAll(): Invalid Move Type");
		SetErrorLevel(_T("MMC move All Axis"),3, __FILE__, __LINE__);
		delete[] psiTempAccel;
		delete[] psiTempDecel;
		return generateErrorCode(106092);	// ERR_MLIB_INVALID_MOVE_TYPE
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정된 n축이 주어진 좌표값만큼 직선이동을 한다. (다른 Board의 축 사용 불가)
 *  MapAxes(), SetMoveSpeed()에서 지정된 축들이 이동한다.
 *
 *		|----------------> siLen = n <----------------|
 *		+---------+---------+---------+-----+---------+
 *		| 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+-----+---------+
 *
 * MMC Library : move_2(), move_3(), move_4(), move_n(),
 *				 smove_2(), smove_3(), smove_4(), smove_n()
 *
 * @param	siLen			: 축 수, 2 <= siLen <= 8
 * @param	*pdPosition		: 이동할 좌표값 (축 수 만큼 존재)
 * @param	siType			: 이동 Type, 0=사다리꼴 속도 Profile, 절대좌표 이동
 *										 1=S-Curve 속도 Profile, 절대좌표 이동
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS NUMBER (MOTIONLIB)
 *							  xx = INVALID MOVE TYPE (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::MoveN(short siLen, double *pdPosition, short siType)
{
	short siResult = ERR_MOTION_SUCCESS;
	double rgdPos[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 축 개수 범위 오류 */
	if ((siLen < (DEF_AXIS_NON_NO + 2)) || (siLen > DEF_AXIS_NO_PER_BRD))
	{
		//strLogMsg.Format(_T("MoveN(): Invalid Axis Number(AxisNo=%d is out of range)"), siLen);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC move %d Axis"),siLen);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER
	}

	/** 인수 Pointer 오류 */
	if (pdPosition == NULL)
	{
		//WriteErrorLog("MoveN(): pdPosition Pointer is NULL");
		strLogMsg.Format(_T("MMC move %d Axis"),siLen);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	for (int i=0; i<siLen; i++)
		rgdPos[i] = motionRoundValue(*(pdPosition + i));

	/** 이동 종류에 따라 */
	switch (siType)
	{
	case DEF_MOVE_POSITION :		// 사다리꼴 속도 Profile, 절대좌표 이동
		/** 축 수에 따라 */
		switch (siLen)
		{
		case DEF_2AXIS_MOVE :
#ifndef SIMULATION
			/** move_2 */
			if ((siResult = move_2(pdPosition[0], pdPosition[1])) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveN(): move_2(2 axes, trapezoid velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		case DEF_3AXIS_MOVE :
#ifndef SIMULATION
			/** move_3 */
			if ((siResult = move_3(pdPosition[0], pdPosition[1], pdPosition[2])) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveN(): move_3(3 axes, trapezoid velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		case DEF_4AXIS_MOVE :
#ifndef SIMULATION
			/** move_4 */
			if ((siResult = move_4(pdPosition[0], pdPosition[1], pdPosition[3], pdPosition[4])) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveN(): move_4(4 axes, trapezoid velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		default :
#ifndef SIMULATION
			/** move_n */
			if ((siResult = move_n(pdPosition)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveN(): move_n(n axes, trapezoid velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		}
		break;
	case DEF_SMOVE_POSITION :		// S-Curve 속도 Profile, 절대좌표 이동
		/** 축 수에 따라 */
		switch (siLen)
		{
		case DEF_2AXIS_MOVE :
#ifndef SIMULATION
			/** smove_2 */
			if ((siResult = smove_2(pdPosition[0], pdPosition[1])) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveN(): smove_2(2 axes, S-Curve velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		case DEF_3AXIS_MOVE :
#ifndef SIMULATION
			/** smove_3 */
			if ((siResult = smove_3(pdPosition[0], pdPosition[1], pdPosition[2])) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveN(): smove_3(3 axes, S-Curve velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		case DEF_4AXIS_MOVE :
#ifndef SIMULATION
			/** smove_4 */
			if ((siResult = smove_4(pdPosition[0], pdPosition[1], pdPosition[3], pdPosition[4])) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveN(): smove_4(4 axes, S-Curve velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		default :
#ifndef SIMULATION
			/** smove_n */
			if ((siResult = smove_n(pdPosition)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveN(): smove_n(n axes, S-Curve velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		}
		break;
	default :
		//WriteErrorLog("MoveN(): Invalid Move Type");
		strLogMsg.Format(_T("MMC move %d Axis"),siLen);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106092);	// ERR_MLIB_INVALID_MOVE_TYPE

	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정된 n축이 주어진 좌표값만큼 직선이동을 한다. (다른 Board의 축 사용 가능)
 *
 *		|-------------------> siLen <-----------------|
 *		+---------+---------+---------+-----+---------+
 *		| 축 ID#1 | 축 ID#2 | 축 ID#3 | ... | 축 ID#n |
 *		+---------+---------+---------+-----+---------+
 *		| 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+-----+---------+
 *		+------+--------+
 *		| 속도 | 가속도 |
 *		+------+--------+
 *
 * MMC Library : move_2ax(), move_3ax(), move_4ax(), move_nax()
 *				 smove_2ax(), smove_3ax(), smove_4ax(), smove_nax()
 *
 * @param	siLen			: 축 수, >=2
 * @param	*psiAxes		: 축 ID 배열
 * @param	*pdPosition		: 이동할 좌표값 (축 수 만큼 존재)
 * @param	siType			: 이동 Type, 0=사다리꼴 속도 Profile, 절대좌표 이동
 *										 1=S-Curve 속도 Profile, 절대좌표 이동
 * @param	dVelocity		: 이동 속도
 * @param	siAccel			: 이동 가속도
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS NUMBER (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID MOVE TYPE (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::MoveNAx(short siLen, short *psiAxes, double *pdPosition, short siType,
					  double dVelocity, short siAccel)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	double rgdPos[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 개수 범위 오류 */
	if (siLen < (DEF_AXIS_NON_NO + 2))
	{
		//strLogMsg.Format(_T("MoveNAx(): Invalid Axis Number(AxisNo=%d is out of range)"), siLen);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC move %d Axis"),siLen);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER
	}

	/** 인수 Pointer 오류 */
	if (psiAxes == NULL)
	{
		//WriteErrorLog("MoveNAx(): psiAxes Pointer is NULL");
		strLogMsg.Format(_T("MMC move %d Axis"),siLen);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 축 ID 범위 오류 */
	for (int i = 0; i < siLen; i++)
	{
		if ((psiAxes[i] < DEF_AXIS_NON_NO) || (psiAxes[i] > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		{
			//strLogMsg.Format(_T("MoveNAx(): Invalid Axis ID(AxisID=%d is out of range)"), psiAxes[i]);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC move %d Axis"),siLen);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}
	}

	/** 인수 Pointer 오류 */
	if (pdPosition == NULL)
	{
		//WriteErrorLog("MoveNAx(): pdPosition Pointer is NULL");
		strLogMsg.Format(_T("MMC move %d Axis"),siLen);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	for (int i=0; i<siLen; i++)
		rgdPos[i] = motionRoundValue(*(pdPosition + i));

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

	/** 이동 종류에 따라 */
	switch (siType)
	{
	case DEF_MOVE_POSITION :		// 사다리꼴 속도 Profile, 절대좌표 이동
		/** 축 수에 따라 */
		switch (siLen)
		{
		case DEF_2AXIS_MOVE :
#ifndef SIMULATION
			/** move_2ax */
			if ((siResult = move_2ax(psiAxes[0], psiAxes[1], pdPosition[0], pdPosition[1], motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAx(): move_2ax(2 axes, trapezoid velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		case DEF_3AXIS_MOVE :
#ifndef SIMULATION
			/** move_3ax */
			if ((siResult = move_3ax(psiAxes[0], psiAxes[1], psiAxes[2], pdPosition[0], pdPosition[1], pdPosition[2], motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAx(): move_3ax(3 axes, trapezoid velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		case DEF_4AXIS_MOVE :
#ifndef SIMULATION
			/** move_4ax */
			if ((siResult = move_4ax(psiAxes[0], psiAxes[1], psiAxes[2], psiAxes[3], pdPosition[0], pdPosition[1], pdPosition[2], pdPosition[3], motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAx(): move_4ax(4 axes, trapezoid velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		default :
#ifndef SIMULATION
			/** move_nax */
			if ((siResult = move_nax(siLen, psiAxes, pdPosition, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAx(): move_nax(n axes, trapezoid velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		}
		break;
	case DEF_SMOVE_POSITION :		// S-Curve 속도 Profile, 절대좌표 이동
		/** 축 수에 따라 */
		switch (siLen)
		{
		case DEF_2AXIS_MOVE :
#ifndef SIMULATION
			/** smove_2ax */
			if ((siResult = smove_2ax(psiAxes[0], psiAxes[1], pdPosition[0], pdPosition[1], motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAx(): smove_2ax(2 axes, S-Curve velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		case DEF_3AXIS_MOVE :
#ifndef SIMULATION
			/** smove_3ax */
			if ((siResult = smove_3ax(psiAxes[0], psiAxes[1], psiAxes[2], pdPosition[0], pdPosition[1], pdPosition[2], motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAx(): smove_3ax(3 axes, S-Curve velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		case DEF_4AXIS_MOVE :
#ifndef SIMULATION
			/** smove_4ax */
			if ((siResult = smove_4ax(psiAxes[0], psiAxes[1], psiAxes[2], psiAxes[3], pdPosition[0], pdPosition[1], pdPosition[2], pdPosition[3], motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAx(): smove_4ax(4 axes, S-Curve velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		default :
#ifndef SIMULATION
			/** smove_nax */
			if ((siResult = smove_nax(siLen, psiAxes, pdPosition, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAx(): smove_nax(n axes, S-Curve velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move %d Axis"),siLen);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		}
		break;
	default :
		//WriteErrorLog("MoveNAx(): Invalid Move Type");
		strLogMsg.Format(_T("MMC move %d Axis"),siLen);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106092);	// ERR_MLIB_INVALID_MOVE_TYPE
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정된 그룹의 축들이 주어진 좌표값만큼 직선이동을 한다.
 *
 *		|----------------> siLen = n <----------------|
 *		+---------+---------+---------+-----+---------+
 *		| 축 ID#1 | 축 ID#2 | 축 ID#3 | ... | 축 ID#n |
 *		+---------+---------+---------+-----+---------+
 *		| 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+-----+---------+
 *		+------+--------+
 *		| 속도 | 가속도 |
 *		+------+--------+
 *
 * MMC Library : move_2axgr(), move_3axgr(), move_4axgr(),
 *				 smove_2axgr(), smove_3axgr(), smove_4axgr()
 *
 * @param	siGrpNum		: Group 번호, 1 ~ 4
 * @param	siLen			: 축 수, 2 <= siLen <= 4
 * @param	*psiAxes		: 축 ID 배열 (축 수 만큼 존재)
 * @param	*pdPosition		: 이동할 좌표값 (축 수 만큼 존재)
 * @param	siType			: 이동 Type, 0=사다리꼴 속도 Profile, 절대좌표 이동
 *										 1=S-Curve 속도 Profile, 절대좌표 이동
 * @param	dVelocity		: 이동 속도
 * @param	siAccel			: 이동 가속도
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID GROUP NUMBER (MOTIONLIB)
 *							  xx = INVALID AXIS NUMBER (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID MOVE TYPE (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::MoveNAxGr(short siGrpNum, short siLen, short *psiAxes, double *pdPosition,
						short siType, double dVelocity, short siAccel)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	double rgdPos[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 그룹 번호 범위 오류 */
	if ((siGrpNum < DEF_MIN_GROUP_NO) || (siGrpNum > DEF_MAX_GROUP_NO))
	{
		//strLogMsg.Format(_T("MoveNAxGr(): Invalid Group Number(GroupNo=%d is out of range)"), siGrpNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106104);	// ERR_MLIB_INVALID_GROUP_NUMBER
	}

	/** 축 개수 범위 오류 */
	if ((siLen < 2) || (siLen > 4))
	{
		//strLogMsg.Format(_T("MoveNAxGr(): Invalid Axis Number(AxisNo=%d is out of range)"), siLen);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER
	}

	/** 인수 Pointer 오류 */
	if (psiAxes == NULL)
	{
		//WriteErrorLog("MoveNAxGr(): psiAxes Pointer is NULL");
		strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 축 ID 범위 오류 */
	for (int i = 0; i < siLen; i++)
	{
		if ((psiAxes[i] < DEF_AXIS_NON_NO) || (psiAxes[i] > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		{
			//strLogMsg.Format(_T("MoveNAxGr(): Invalid Axis ID(AxisID=%d is out of range)"), psiAxes[i]);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}
	}

	/** 인수 Pointer 오류 */
	if (pdPosition == NULL)
	{
		//WriteErrorLog("MoveNAxGr(): pdPosition Pointer is NULL");
		strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	for (int i=0; i<siLen; i++)
		rgdPos[i] = motionRoundValue(*(pdPosition + i));

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

	/** 이동 종류에 따라 */
	switch (siType)
	{
	case DEF_MOVE_POSITION :		// 사다리꼴 속도 Profile, 절대좌표 이동
		/** 축 수에 따라 */
		switch (siLen)
		{
		case DEF_2AXIS_MOVE :
#ifndef SIMULATION
			/** move_2axgr */
			if ((siResult = move_2axgr(siGrpNum, psiAxes[0], psiAxes[1], pdPosition[0], pdPosition[1], motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAxGr(): move_2axgr(2 axes, trapezoid velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		case DEF_3AXIS_MOVE :
#ifndef SIMULATION
			/** move_3axgr */
			if ((siResult = move_3axgr(siGrpNum, psiAxes[0], psiAxes[1], psiAxes[2], pdPosition[0], pdPosition[1], pdPosition[2], motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAxGr(): move_3axgr(3 axes, trapezoid velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		case DEF_4AXIS_MOVE :
#ifndef SIMULATION
			/** move_4axgr */
			if ((siResult = move_4axgr(siGrpNum, psiAxes[0], psiAxes[1], psiAxes[2], psiAxes[3], pdPosition[0], pdPosition[1], pdPosition[2], pdPosition[3], motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAxGr(): move_4axgr(4 axes, trapezoid velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		default :
			//WriteErrorLog("MoveNAxGr(): Invalid Move Axis Number");
			strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return generateErrorCode(106115);	// ERR_MLIB_INVALID_MOVE_AXIS_NUMBER
		}
		break;
	case DEF_SMOVE_POSITION :		// S-Curve 속도 Profile, 절대좌표 이동
		/** 축 수에 따라 */
		switch (siLen)
		{
		case DEF_2AXIS_MOVE :
#ifndef SIMULATION
			/** smove_2axgr */
			if ((siResult = smove_2axgr(siGrpNum, psiAxes[0], psiAxes[1], pdPosition[0], pdPosition[1], motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAxGr(): smove_2axgr(2 axes, S-Curve velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		case DEF_3AXIS_MOVE :
#ifndef SIMULATION
			/** smove_3axgr */
			if ((siResult = smove_3axgr(siGrpNum, psiAxes[0], psiAxes[1], psiAxes[2], pdPosition[0], pdPosition[1], pdPosition[2], motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAxGr(): smove_3axgr(3 axes, S-Curve velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		case DEF_4AXIS_MOVE :
#ifndef SIMULATION
			/** smove_4axgr */
			if ((siResult = smove_4axgr(siGrpNum, psiAxes[0], psiAxes[1], psiAxes[2], psiAxes[3], pdPosition[0], pdPosition[1], pdPosition[2], pdPosition[3], motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
			{
				//strLogMsg.Format(_T("MoveNAxGr(): smove_4axgr(4 axes, S-Curve velocity profile, absolute coordinates) Fail - Error# is %d"), siResult);
				//WriteErrorLog(strLogMsg);
				strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
				SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
				return makeMMCError((int)siResult);
			}
#endif
			break;
		default :
			//WriteErrorLog("MoveNAxGr(): Invalid Move Axis Number");
			strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return generateErrorCode(106115);	// ERR_MLIB_INVALID_MOVE_AXIS_NUMBER
		}
		break;
	default :
		//WriteErrorLog("MoveNAxGr(): Invalid Move Type");
		strLogMsg.Format(_T("MMC move Axis Group(GroupNo=%d)"),siGrpNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106092);	// ERR_MLIB_INVALID_MOVE_TYPE
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 가속 후 등속 이동한다. (축 1개 단위로만 동작 가능하다.)
 *
 * MMC Library : v_move()
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	dVelocity		: 이동 속도
 * @param	siAccel			: 이동 가속도
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::VMove(short siAxis, double dVelocity, short siAccel)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("VMove(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC move Uniform Velocity after Acceleration(AxisID=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

#ifndef SIMULATION
	/** v_move */
	if ((siResult = v_move(siAxis, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("VMove(): v_move(uniform velocity after acceleration) Fail[AxisID=%d] - Error# is %d"), siAxis, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC move Uniform Velocity after Acceleration(AxisID=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 현재 위치에서 주어진 2/3차원 평면상의 좌표점까지 가,감속하면서 원호 CP Motion으로 이동한다.
 *  (다른 Board의 축 사용 불가)
 *  MapAxes(), SetMoveSpped()에서 지정된 축들이 이동한다.
 *
 *		|---------------> siAxNum = n <---------------|
 *		+---------+---------+---------+-----+---------+
 *		| 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+-----+---------+
 *		+-----------+-----------+------+--------+----------+
 *		| 회전중심X | 회전중심Y | 속도 | 가속도 | 회전방향 |
 *		+-----------+-----------+------+--------+----------+
 *
 * MMC Library : spl_arc_move2(), spl_arc_move3()
 *
 * @param	siAxNum			: 축 수, 2=2축, 3=3축
 * @param	dCenterX		: 회전 중심 X좌표
 * @param	dCenterY		: 회전 중심 Y좌표
 * @param	*pdPoint		: 이동할 좌표, 2축이면 2차원배열, 3축이면 3차원배열
 * @param	dVelocity		: 이동 속도 (0.0=SetMoveSpeed()에서 지정한 속도 사용)
 * @param	siAccel			: 이동 가속도 (0=SetMoveSpeed()에서 지정한 가,감속도 사용)
 * @param	bDir			: 회전방향, FALSE=CIR_CW(시계방향), TRUE=CIR_CCW(반시계방향)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS NUMBER (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SplArcMove(short siAxNum, double dCenterX, double dCenterY,
						  double *pdPoint, double dVelocity, short siAccel, BOOL bDir)
{
	short siResult = ERR_MOTION_SUCCESS;
	double rgdPoint[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 축 개수 범위 오류 */
	if ((siAxNum < 2) || (siAxNum > 3))
	{
		//strLogMsg.Format(_T("SplArcMove(): Invalid Axis Number(AxisNo=%d is out of range)"), siAxNum);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC move Spline or Arc(2D/3D)"),3, __FILE__, __LINE__);
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER
	}

	/** 인수 Pointer 오류 */
	if (pdPoint == NULL)
	{
		//WriteErrorLog("SplArcMove(): pdPoint Pointer is NULL");
		SetErrorLevel(_T("MMC move Spline or Arc(2D/3D)"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	for (int i=0; i<siAxNum; i++)
		rgdPoint[i] = motionRoundValue(*(pdPoint + i));

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

	/** 사용 축 수에 따라 */
	switch (siAxNum)
	{
	/** spl_arc_move2 */
	case DEF_2AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_arc_move2(motionRoundValue(dCenterX), motionRoundValue(dCenterY), pdPoint, motionRoundValue(dVelocity), siAccel, bDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplArcMove(): spl_arc_move2(2 axes, circular arc CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Spline or Arc(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	/** spl_arc_move3 */
	case DEF_3AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_arc_move3(motionRoundValue(dCenterX), motionRoundValue(dCenterY), pdPoint, motionRoundValue(dVelocity), siAccel, bDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplArcMove(): spl_arc_move3(3 axes, circular arc CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Spline or Arc(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	default :
		//WriteErrorLog("SplArcMove(): Invalid Move Axis Number");
		SetErrorLevel(_T("MMC move Spline or Arc(2D/3D)"),3, __FILE__, __LINE__);
		return generateErrorCode(106115);	// ERR_MLIB_INVALID_MOVE_AXIS_NUMBER
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 현재 위치에서 주어진 좌표점까지 가,감속하면서 원호 CP Motion으로 이동한다.
 *  (다른 Board의 축 사용 가능)
 *
 *		|----------------> siLen = n <----------------|
 *		+---------+---------+---------+-----+---------+
 *		| 축 ID#1 | 축 ID#2 | 축 ID#3 | ... | 축 ID#n |
 *		+---------+---------+---------+-----+---------+
 *		| 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+-----+---------+
 *		+-----------+-----------+------+--------+----------+
 *		| 회전중심X | 회전중심Y | 속도 | 가속도 | 회전방향 |
 *		+-----------+-----------+------+--------+----------+
 *
 * MMC Library : spl_arc_move2ax(), spl_arc_move3ax(), spl_arc_movenax()
 *
 * @param	siLen			: 축 수 (>= 2)
 * @param	*psiAxes		: 축 ID 배열 (축 수만큼 존재)
 * @param	siCenterX		: 회전 중심 X좌표
 * @param	siCenterY		: 회전 중심 Y좌표
 * @param	*pdPoint		: 이동할 좌표 (축 수 만큼 존재)
 * @param	dVelocity		: 이동 속도 (0.0=SetMoveSpeed()에서 지정한 속도 사용)
 * @param	siAccel			: 이동 가속도 (0=SetMoveSpeed()에서 지정한 가,감속도 사용)
 * @param	bDir			: 회전방향, FALSE=CIR_CW(시계방향), TRUE=CIR_CCW(반시계방향)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS NUMBER (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SplArcMoveNax(short siLen, short *psiAxes, double dCenterX, double dCenterY,
							double *pdPoint, double dVelocity, short siAccel, BOOL bDir)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	double rgdPoint[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 개수 범위 오류 */
	if (siLen < 2)
	{
		//strLogMsg.Format(_T("SplArcMoveNax(): Invalid Axis Number(AxisNo=%d is out of range)"), siLen);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER
	}

	/** 인수 Pointer 오류 */
	if (psiAxes == NULL)
	{
		//WriteErrorLog("SplArcMoveNax(): psiAxes Pointer is NULL");
		SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 축 ID 범위 오류 */
	for (int i = 0; i < siLen; i++)
	{
		if ((psiAxes[i] < DEF_AXIS_NON_NO) || (psiAxes[i] > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		{
			//strLogMsg.Format(_T("SplArcMoveNax(): Invalid Axis ID(AxisID=%d is out of range)"), psiAxes[i]);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}
	}

	
	// **1202 -> msec 단위로 변경
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

	/** 인수 Pointer 오류 */
	if (pdPoint == NULL)
	{
		//WriteErrorLog("SplArcMoveNax(): pdPoint Pointer is NULL");
		SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	for (int i=0; i<siLen; i++)
		rgdPoint[i] = motionRoundValue(*(pdPoint+i));

	/** 사용 축 수에 따라 */
	switch (siLen)
	{
	/** spl_arc_moveax2 */
	case DEF_2AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_arc_move2ax(psiAxes[0], psiAxes[1], motionRoundValue(dCenterX), motionRoundValue(dCenterY), pdPoint, motionRoundValue(dVelocity), siAccel, bDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplArcMoveNax(): spl_arc_move2ax(2 axes, circular arc CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	/** spl_arc_move3ax */
	case DEF_3AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_arc_move3ax(psiAxes[0], psiAxes[1], psiAxes[2], motionRoundValue(dCenterX), motionRoundValue(dCenterY), pdPoint, motionRoundValue(dVelocity), siAccel, bDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplArcMoveNax(): spl_arc_move3ax(3 axes, circular arc CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	/** spl_arc_movenax */
	default :
#ifndef SIMULATION
		if ((siResult = spl_arc_movenax(siLen, psiAxes, motionRoundValue(dCenterX), motionRoundValue(dCenterY), pdPoint, motionRoundValue(dVelocity), siAccel, bDir)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplArcMoveNax(): spl_arc_movenax(n axes, circular arc CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 현재 위치에서 주어진 좌표점까지 가,감속하면서 원호 CP Motion으로 이동한다.
 *  (다른 Board의 축 사용 가능)
 *
 *		|----------------> siLen = n <----------------|
 *		+---------+---------+---------+-----+---------+
 *		| 축 ID#1 | 축 ID#2 | 축 ID#3 | ... | 축 ID#n |
 *		+---------+---------+---------+-----+---------+
 *		| 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+-----+---------+
 *		+-----------+-----------+------+--------+----------+
 *		| 회전중심X | 회전중심Y | 속도 | 가속도 | 회전방향 |
 *		+-----------+-----------+------+--------+----------+
 *
 * MMC Library : spl_auto_arc_move2ax(), spl_auto_arc_move3ax(), spl_auto_arc_movenax()
 *
 * @param	siLen			: 축 수 (>= 2)
 * @param	*psiAxes		: 축 ID 배열 (축 수만큼 존재)
 * @param	siCenterX		: 회전 중심 X좌표
 * @param	siCenterY		: 회전 중심 Y좌표
 * @param	*pdPoint		: 이동할 좌표 (축 수 만큼 존재)
 * @param	dVelocity		: 이동 속도 (0.0=SetMoveSpeed()에서 지정한 속도 사용)
 * @param	siAccel			: 이동 가속도 (0=SetMoveSpeed()에서 지정한 가,감속도 사용)
 * @param	bDir			: 회전방향, FALSE=CIR_CW(시계방향), TRUE=CIR_CCW(반시계방향)
 * @param	bAutoFlag		: 자동 Auto CP, FALSE=Auto CP 안함, TRUE=Auto CP 함
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS NUMBER (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SplAutoArcMoveNax(short siLen, short *psiAxes, double dCenterX, double dCenterY,
							  double *pdPoint, double dVelocity, short siAccel, BOOL bDir, BOOL bAutoFlag)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	double rgdPoint[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 개수 범위 오류 */
	if (siLen < 2)
	{
		//strLogMsg.Format(_T("SplAutoArcMoveNax(): Invalid siLen (siLen=%d is out of range)"), siLen);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER
	}

	/** 인수 Pointer 오류 */
	if (psiAxes == NULL)
	{
		//WriteErrorLog("SplAutoArcMoveNax(): psiAxes Pointer is NULL");
		SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 축 ID 범위 오류 */
	for (int i = 0; i < siLen; i++)
	{
		if ((psiAxes[i] < DEF_AXIS_NON_NO) || (psiAxes[i] > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		{
			//strLogMsg.Format(_T("SplAutoArcMoveNax(): Invalid psiAxes[%d] (psiAxes[%d]=%d is out of range)"),i,i, psiAxes[i]);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}
	}

	/** 인수 Pointer 오류 */
	if (pdPoint == NULL)
	{
		//WriteErrorLog("SplAutoArcMoveNax(): pdPoint Pointer is NULL");
		SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	for (int i=0; i<siLen; i++)
		rgdPoint[i] = motionRoundValue(*(pdPoint+i));

	/** 사용 축 수에 따라 */
	switch (siLen)
	{
	/** spl_arc_moveax2 */
	case DEF_2AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_auto_arc_move2ax(psiAxes[0], psiAxes[1], motionRoundValue(dCenterX), motionRoundValue(dCenterY), pdPoint, motionRoundValue(dVelocity), siAccel, bDir, bAutoFlag)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplAutoArcMoveNax(): spl_auto_arc_move2ax(2 axes) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	/** spl_arc_move3ax */
	case DEF_3AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_auto_arc_move3ax(psiAxes[0], psiAxes[1], psiAxes[2], motionRoundValue(dCenterX), motionRoundValue(dCenterY), pdPoint, motionRoundValue(dVelocity), siAccel, bDir, bAutoFlag)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplAutoArcMoveNax(): spl_auto_arc_move3ax(3 axes) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	/** spl_arc_movenax */
	default :
#ifndef SIMULATION
		if ((siResult = spl_auto_arc_movenax(siLen, psiAxes, motionRoundValue(dCenterX), motionRoundValue(dCenterY), pdPoint, motionRoundValue(dVelocity), siAccel, bDir, bAutoFlag)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplAutoArcMoveNax(): spl_auto_arc_movenax() Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Spline or Arc"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 현재 위치에서 주어진 2/3차원 평면상의 좌표점까지 가,감속하면서 직선 CP Motion으로 이동한다.
 *  (다른 Board의 축 사용 불가)
 *  MapAxes(), SetMoveSpeed()에서 지정된 축들이 이동한다.
 *
 *		|---------------> siAxNum = n <---------------|
 *		+---------+---------+---------+-----+---------+
 *		| 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+-----+---------+
 *		+------+--------+
 *		| 속도 | 가속도 |
 *		+------+--------+
 *
 * MMC Library : spl_line_move1(), spl_line_move2(), spl_line_move3()
 *
 * @param	siAxNum			: 축 수, 1=1축, 2=2축, 3=3축
 * @param	*pdPoint		: 이동할 좌표, 1축이면 1차원배열, 2축이면 2차원배열, 3축이면 3차원배열
 * @param	dVelocity		: 이동 속도 (0.0=SetMoveSpeed()에서 지정한 속도 사용)
 * @param	siAccel			: 이동 가속도 (0=SetMoveSpeed()에서 지정한 가,감속도 사용)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS NUMBER (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SplLineMoveN(short siAxNum, double *pdPoint, double dVelocity, short siAccel)
{
	short siResult = ERR_MOTION_SUCCESS;
	double rgdPoint[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 축 개수 범위 오류 */
	if ((siAxNum < 1) || (siAxNum > 3))
	{
		//strLogMsg.Format(_T("SplLineMoveN(): Invalid Axis Number(AxisNo=%d is out of range)"), siAxNum);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER
	}

	/** 인수 Pointer 오류 */
	if (pdPoint == NULL)
	{
		//WriteErrorLog("SplLineMoveN(): pdPoint Pointer is NULL");
		SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	for (int i=0; i<siAxNum; i++)
		rgdPoint[i] = motionRoundValue(*(pdPoint + i));

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

	/** 사용 축 수에 따라 */
	switch (siAxNum)
	{
	/** spl_line_move1 */
	case DEF_1AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_line_move1(pdPoint, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplLineMoveN(): spl_line_move1(1 axes, linear CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	/** spl_line_move2 */
	case DEF_2AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_line_move2(pdPoint, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplLineMoveN(): spl_line_move2(2 axes, linear CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	/** spl_line_move3 */
	case DEF_3AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_line_move3(pdPoint, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplLineMoveN(): spl_line_move3(3 axes, linear CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	default :
		//WriteErrorLog("SplLineMoveN(): Invalid Move Type");
		SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
		return generateErrorCode(106115);	// ERR_MLIB_INVALID_MOVE_AXIS_NUMBER
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 현재 위치에서 주어진 좌표점까지 가,감속하면서 직선 CP Motion으로 이동한다.
 *  (다른 Board의 축 사용 가능)
 *
 *		|----------------> siLen = n <----------------|
 *		+---------+---------+---------+-----+---------+
 *		| 축 ID#1 | 축 ID#2 | 축 ID#3 | ... | 축 ID#n |
 *		+---------+---------+---------+-----+---------+
 *		| 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+-----+---------+
 *		+------+--------+
 *		| 속도 | 가속도 |
 *		+------+--------+
 *
 * MMC Library : spl_line_move1ax(), spl_line_move2ax(), spl_line_move3ax(), spl_line_movenax()
 *
 * @param	siLen			: 축 수 (>= 1)
 * @param	*psiAxes		: 축 ID 배열 (축 수 만큼 존재)
 * @param	*pdPoint		: 이동할 좌표 (축 수 만큼 존재)
 * @param	dVelocity		: 이동 속도 (0.0=SetMoveSpeed()에서 지정한 속도 사용)
 * @param	siAccel			: 이동 가속도 (0=SetMoveSpeed()에서 지정한 가,감속도 사용)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS NUMBER (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SplLineMoveNax(short siLen, short *psiAxes, double *pdPoint, double dVelocity, short siAccel)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	double rgdPoint[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 개수 범위 오류 */
	if (siLen < 1)
	{
		//strLogMsg.Format(_T("SplLineMoveNax(): Invalid Axis Number(AxisNo=%d is out of range)"), siLen);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER
	}

	/** 인수 Pointer 오류 */
	if (psiAxes == NULL)
	{
		//WriteErrorLog("SplLineMoveNax(): psiAxes Pointer is NULL");
		SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 축 ID 범위 오류 */
	for (int i = 0; i < siLen; i++)
	{
		if ((psiAxes[i] < DEF_AXIS_NON_NO) || (psiAxes[i] > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		{
			//strLogMsg.Format(_T("SplLineMoveNax(): Invalid Axis ID(AxisID=%d is out of range)"), psiAxes[i]);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}
	}

	/** 인수 Pointer 오류 */
	if (pdPoint == NULL)
	{
		//WriteErrorLog("SplLineMoveNax(): pdPoint Pointer is NULL");
		SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	for (int i=0; i<siLen; i++)
		rgdPoint[i] = motionRoundValue(*(pdPoint + i));

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

	/** 사용 축 수에 따라 */
	switch (siLen)
	{
	/** spl_line_move1ax */
	case DEF_1AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_line_move1ax(psiAxes[0], pdPoint, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplLineMoveNax(): spl_line_move1ax(1 axes, linear CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	case DEF_2AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_line_move2ax(psiAxes[0], psiAxes[1], pdPoint, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplLineMoveNax(): spl_line_move2ax(2 axes, linear CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	/** spl_line_move3ax */
	case DEF_3AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_line_move3ax(psiAxes[0], psiAxes[1], psiAxes[2], pdPoint, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplLineMoveNax(): spl_line_move3ax(3 axes, linear CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	/** spl_line_movenax */
	default :
#ifndef SIMULATION
		if ((siResult = spl_line_movenax(siLen, psiAxes, pdPoint, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplLineMoveNax(): spl_line_movenax(n axes, linear CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 현재 위치에서 주어진 좌표점까지 자동 가,감속 여부를 인자로 설정받아서 직선 CP Motion으로 이동한다.
 *  (다른 Board의 축 사용 가능)
 *
 *		|----------------> siLen = n <----------------|
 *		+---------+---------+---------+-----+---------+
 *		| 축 ID#1 | 축 ID#2 | 축 ID#3 | ... | 축 ID#n |
 *		+---------+---------+---------+-----+---------+
 *		| 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+-----+---------+
 *		+------+--------+
 *		| 속도 | 가속도 |
 *		+------+--------+
 *
 * @param	siLen			: 축 수
 * @param	*psiAxes		: 축 ID 배열
 * @param	*pdPoint		: 이동할 좌표 (축 수 만큼 존재)
 * @param	dVelocity		: 이동 속도, 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도, 0=기지정된 가속도로 이동
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMMCLib::SplAutoLineMoveNax(short siLen, short *psiAxes, double *pdPoint, double dVelocity, short siAccel, BOOL bAutoFlag)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	double rgdPoint[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 개수 범위 오류 */
	if (siLen < 1)
	{
		//strLogMsg.Format(_T("SplAutoLineMoveNax(): Invalid Axis Number(AxisNo=%d is out of range)"), siLen);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC auto move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
		return generateErrorCode(106108);	// ERR_MLIB_INVALID_AXIS_NUMBER
	}

	/** 인수 Pointer 오류 */
	if (psiAxes == NULL)
	{
		//WriteErrorLog("SplAutoLineMoveNax(): psiAxes Pointer is NULL");
		SetErrorLevel(_T("MMC auto move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 축 ID 범위 오류 */
	for (int i = 0; i < siLen; i++)
	{
		if ((psiAxes[i] < DEF_AXIS_NON_NO) || (psiAxes[i] > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		{
			//strLogMsg.Format(_T("SplAutoLineMoveNax(): Invalid Axis ID(AxisID=%d is out of range)"), psiAxes[i]);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC auto move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}
	}

	/** 인수 Pointer 오류 */
	if (pdPoint == NULL)
	{
		//WriteErrorLog("SplLineMoveNax(): pdPoint Pointer is NULL");
		SetErrorLevel(_T("MMC auto move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}
	for (int i=0; i<siLen; i++)
		rgdPoint[i] = motionRoundValue(*(pdPoint + i));

	/** 사용 축 수에 따라 */
	switch (siLen)
	{
	/** spl_line_move1ax */
	case DEF_1AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_auto_line_move1ax(psiAxes[0], pdPoint, motionRoundValue(dVelocity), siAccel, bAutoFlag)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplAutoLineMoveNax(): spl_auto_line_move1ax(1 axes, linear CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC auto move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	case DEF_2AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_auto_line_move2ax(psiAxes[0], psiAxes[1], pdPoint, motionRoundValue(dVelocity), siAccel, bAutoFlag)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplAutoLineMoveNax(): spl_auto_line_move2ax(2 axes, linear CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC auto move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	/** spl_line_move3ax */
	case DEF_3AXIS_MOVE :
#ifndef SIMULATION
		if ((siResult = spl_auto_line_move3ax(psiAxes[0], psiAxes[1], psiAxes[2], pdPoint, motionRoundValue(dVelocity), siAccel, bAutoFlag)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplAutoLineMoveNax(): spl_auto_line_move3ax(3 axes, linear CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC auto move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	/** spl_line_movenax */
	default :
#ifndef SIMULATION
		if ((siResult = spl_auto_line_movenax(siLen, psiAxes, pdPoint, motionRoundValue(dVelocity), siAccel, bAutoFlag)) != ERR_MOTION_SUCCESS)
		{
			//strLogMsg.Format(_T("SplAutoLineMoveNax(): spl_auto_line_movenax(n axes, linear CP motion) Fail - Error# is %d"), siResult);
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("MMC auto move Straight CP Motion(2D/3D)"),3, __FILE__, __LINE__);
			return makeMMCError((int)siResult);
		}
#endif
		break;
	}

	return ERR_MOTION_SUCCESS;
}
/**
 * 원, 원호 이동 시 원주속도를 지정한다.
 *
 * MMC Library : set_arc_division()
 *
 * @param	dDegree			: 원주속도, 0 < dDegree < 1000.0
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID ARC DIVISION DEGREE NUMBER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SetArcDivision(double dDegree)
{
	short siResult = ERR_MOTION_SUCCESS;
	CString strLogMsg;

	/** 원주속도 범위 오류 */
	if ((dDegree <= 0.0) || (dDegree >= DEF_DEGREE))
	{
		//strLogMsg.Format(_T("SetArcDivision(): Invalid Degree(Degree=%f is out of range)"), dDegree);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set Arc Velocity"),3, __FILE__, __LINE__);
		return generateErrorCode(106110);	// ERR_MLIB_INVALID_ARC_DIVISION_DEGREE_NUMBER
	}

#ifndef SIMULATION
	/** 원주속도 설정 */
	if ((siResult = set_arc_division(motionRoundValue(dDegree))) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SetArcDivision(): set_arc_division(set circumference degree) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set Arc Velocity"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 주어진 중심에서 지정된 각도만큼 원호를 그리며 동작을 수행한다.
 *  (다른 Board의 축 사용 불가)
 *  MapAxes(), SetMoveSpeed()에서 지정된 축들이 이동한다.
 *
 * MMC Library : arc_2()
 *
 * @param	siCenterX		: 회전 중심 X좌표
 * @param	siCenterY		: 회전 중심 Y좌표
 * @param	dAngle			: 회전 각도
 * @return	Error Code		: 0 = SUCCESS
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::Arc2(double dXCenter, double dYCenter, double dAngle)
{
	short siResult = ERR_MOTION_SUCCESS;
	CString strLogMsg;

#ifndef SIMULATION
	/** 원호 이동 */
	if ((siResult = arc_2(motionRoundValue(dXCenter), motionRoundValue(dYCenter), motionRoundValue(dAngle))) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("Arc2(): arc_2(draw a circular arc) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC arc move Setting Degree"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 주어진 중심에서 지정된 각도만큼 원호를 그리며 동작을 수행한다.
 * 동일 Board의 축이 아니면 Error 처리됨.
 *  (다른 Board의 축 사용 불가)
 *
 * MMC Library : arc_2ax()
 *
 * @param	siAxis1			: 축1 ID (0 ~ 63)
 * @param	siAxis2			: 축2 ID (0 ~ 63)
 * @param	siCenterX		: 회전 중심 X좌표
 * @param	siCenterY		: 회전 중심 Y좌표
 * @param	dAngle			: 회전 각도
 * @param	dVelocity		: 이동 속도
 * @param	siAccel			: 이동 가속도
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID AXIS ID IN COMMON BOARD (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::Arc2Ax(short siAxis1, short siAxis2, double dXCenter, double dYCenter,
					 double dAngle, double dVelocity, short siAccel)
{
	short siResult = ERR_MOTION_SUCCESS;
	int	  iBdID = 0;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis1 < DEF_AXIS_NON_NO) || (siAxis1 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("Arc2Ax(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis1);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC arc move Setting Degree"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	iBdID = (int)(siAxis1 / DEF_AXIS_NO_PER_BRD);

	/** 축 ID 범위 오류 */
	if ((siAxis2 < DEF_AXIS_NON_NO) || (siAxis2 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("Arc2Ax(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis2);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC arc move Setting Degree"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 동일 Board내 축 ID 오류 */
	if (iBdID != (int)(siAxis2 / DEF_AXIS_NO_PER_BRD))
	{
		//WriteErrorLog("Arc2Ax(): Invalid Board Range(the axes are not in same board)");
		SetErrorLevel(_T("MMC arc move Setting Degree"),3, __FILE__, __LINE__);
		return generateErrorCode(106116);	// ERR_MLIB_INVALID_AXIS_ID_IN_COMMON_BOARD
	}

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

#ifndef SIMULATION
	/** 원호 이동 */
	if ((siResult = arc_2ax(siAxis1, siAxis2, motionRoundValue(dXCenter), motionRoundValue(dYCenter), motionRoundValue(dAngle), motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("Arc2Ax(): arc_2ax(draw circular arcs) Fail[AxisID1=%d, AxisID2=%d] - Error# is %d"), siAxis1, siAxis2, siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC arc move Setting Degree"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 주어진 사각형의 가로와 세로의 길이를 이용하여 현재위치에서 상대이동을 하면서 CP Motion으로 사각형을 그린다.
 *
 *			+--------------------+ pdPoint (X, Y)
 *			|					 |
 *			|					 |
 *			|					 |
 *			|					 |
 *			|					 |
 *			+--------------------+
 *		현재위치
 *
 * MMC Library : rect_move()
 *
 * @param	siAxis1			: 축1 ID (0 ~ 63)
 * @param	siAxis2			: 축2 ID (0 ~ 63)
 * @param	*pdPoint		: 현재위치와 대각선방향의 X, Y 좌표
 * @param	dVelocity		: 이동 속도
 * @param	siAccel			: 이동 가속도
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::RectMove(short siAxis1, short siAxis2, double *pdPoint,
					    double dVelocity, short siAccel)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis1 < DEF_AXIS_NON_NO) || (siAxis1 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("RectMove(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis1);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC draw Square(Using Width, Height(AxisID=%d)"),siAxis1);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 축 ID 범위 오류 */
	if ((siAxis2 < DEF_AXIS_NON_NO) || (siAxis2 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("RectMove(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis2);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC draw Square(Using Width, Height(AxisID=%d)"),siAxis1);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdPoint == NULL)
	{
		//WriteErrorLog("RectMove(): pdPoint Pointer is NULL");
		strLogMsg.Format(_T("MMC draw Square(Using Width, Height(AxisID=%d)"),siAxis1);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	pdPoint[0] = motionRoundValue(pdPoint[0]);
	pdPoint[1] = motionRoundValue(pdPoint[1]);

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

#ifndef SIMULATION
	/** 사각형 이동 */
	if ((siResult = rect_move(siAxis1, siAxis2, pdPoint, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("RectMove(): rect_move(draw a square) Fail[AxisID1=%d, AxisID2=%d] - Error# is %d"), siAxis1, siAxis2, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC draw Square(Using Width, Height(AxisID=%d)"),siAxis1);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 현재위치에서 주어진 위치를 경유하면서 CP Motion으로 이동한다.
 *
 *				  |----------------> siLen = n <----------------|
 *		+---------+---------+---------+---------+-----+---------+
 *		| 축 ID#1 | 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+---------+-----+---------+
 *		| 축 ID#2 | 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+---------+-----+---------+
 *		| 축 ID#3 | 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+---------+-----+---------+
 *		+------+--------+
 *		| 속도 | 가속도 |
 *		+------+--------+
 *
 * MMC Library : spl_move()
 *
 * @param	siLen			: 위치 Data 개수, 최대 30
 * @param	siAxis1			: 축1 ID (0 ~ 63)
 * @param	siAxis2			: 축2 ID (0 ~ 63)
 * @param	siAxis3			: 축3 ID (0 ~ 63)
 * @param	*pdPointX		: X좌표 배열 (위치 Data 개수만큼 존재)
 * @param	*pdPointY		: Y좌표 배열 (위치 Data 개수만큼 존재)
 * @param	*pdPointZ		: Z좌표 배열 (위치 Data 개수만큼 존재)
 * @param	dVelocity		: 이동 속도
 * @param	siAccel			: 이동 가속도
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POSITION DATA NUMBER (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SplMove(short siLen, short siAxis1, short siAxis2, short siAxis3,
					  double *pdPointX, double *pdPointY, double *pdPointZ,
					  double dVelocity, short siAccel)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	double rgdPointX[DEF_MAX_AXIS_NO];
	double rgdPointY[DEF_MAX_AXIS_NO];
	double rgdPointZ[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 위치 Data 개수 범위 오류 */
	if ((siLen < DEF_POSITION_DATA_MIN_NO) || (siLen > DEF_POSITION_DATA_MAX_NO))
	{
		//strLogMsg.Format(_T("SplMove(): Invalid Axis Number(AxisNo=%d is out of range)"), siLen);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106083);	// ERR_MLIB_INVALID_POSITION_DATA_NUMBER
	}

	/** 축 ID 범위 오류 */
	if ((siAxis1 < DEF_AXIS_NON_NO) || (siAxis1 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SplMove(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis1);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 축 ID 범위 오류 */
	if ((siAxis2 < DEF_AXIS_NON_NO) || (siAxis2 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SplMove(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis2);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 축 ID 범위 오류 */
	if ((siAxis3 < DEF_AXIS_NON_NO) || (siAxis3 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SplMove(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis3);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdPointX == NULL)
	{
		//WriteErrorLog("SplMove(): pdPointX Pointer is NULL");
		SetErrorLevel(_T("AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pdPointY == NULL)
	{
		//WriteErrorLog("SplMove(): pdPointY Pointer is NULL");
		SetErrorLevel(_T("AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pdPointZ == NULL)
	{
		//WriteErrorLog("SplMove(): pdPointZ Pointer is NULL");
		SetErrorLevel(_T("AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	for (int i=0; i<siLen; i++)
	{
		rgdPointX[i] = motionRoundValue(*(pdPointX + i));
		rgdPointY[i] = motionRoundValue(*(pdPointY + i));
		rgdPointZ[i] = motionRoundValue(*(pdPointZ + i));
	}

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

#ifndef SIMULATION
	/** CP Motion 이동 */
	if ((siResult = spl_move(siLen, siAxis1, siAxis2, siAxis3, pdPointX, pdPointY, pdPointZ, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SplMove(): spl_move(pass through given positions, CP Motion) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * SplMoveX()에 필요한 위치경로를 설정한다.
 *
 *				  |----------------> siLen = n <----------------|
 *		+---------+---------+---------+---------+-----+---------+
 *		| 축 ID#1 | 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+---------+-----+---------+
 *		| 축 ID#2 | 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+---------+-----+---------+
 *		| 축 ID#3 | 위치 #1 | 위치 #2 | 위치 #3 | ... | 위치 #n |
 *		+---------+---------+---------+---------+-----+---------+
 *		+------+--------+
 *		| 속도 | 가속도 |
 *		+------+--------+
 *
 * MMC Library : spl_move_data()
 *
 * @param	siSplNum		: Spline Motion 번호, 1 ~ 20
 * @param	siLen			: 이동 경로 수, 1 ~ 500
 * @param	siAxis1			: 축1 ID (0 ~ 63)
 * @param	siAxis2			: 축2 ID (0 ~ 63)
 * @param	siAxis3			: 축3 ID (0 ~ 63)
 * @param	*pdPoint1		: 1좌표 배열
 * @param	*pdPoint2		: 2좌표 배열
 * @param	*pdPoint3		: 3좌표 배열
 * @param	dVelocity		: 이동 속도
 * @param	siAccel			: 이동 가속도
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID SPLINE MOTION NUMBER (MOTIONLIB)
 *							  xx = INVALID MOVE PATH NUMBER (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SplMoveData(short siSplNum, short siLen, short siAxis1, short siAxis2,
						  short siAxis3, double *pdPoint1, double *pdPoint2,
						  double *pdPoint3, double dVelocity, short siAccel)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	double rgdPoint1[DEF_MAX_AXIS_NO];
	double rgdPoint2[DEF_MAX_AXIS_NO];
	double rgdPoint3[DEF_MAX_AXIS_NO];
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** Spline Motion 번호 범위 오류 */
	if ((siSplNum < DEF_SPLINE_MOTION_MIN_NO) || (siSplNum > DEF_SPLINE_MOTION_MAX_NO))
	{
		//strLogMsg.Format(_T("SplMoveData(): Invalid Spline Motion Number(MotionNo=%d is out of range)"), siSplNum);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set pass Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106078);	// ERR_MLIB_INVALID_SPLINE_MOTION_NUMBER
	}

	/** 이동 경로 개수 범위 오류 */
	if ((siLen < DEF_SPLINE_MOVE_PATH_MIN_NO) || (siLen > DEF_SPLINE_MOVE_PATH_MAX_NO))
	{
		//strLogMsg.Format(_T("SplMoveData(): Invalid Path Number(PathNo=%d is out of range)"), siLen);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set pass Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106093);	// ERR_MLIB_INVALID_MOVE_PATH_NUMBER
	}

	/** 축 ID 범위 오류 */
	if ((siAxis1 < DEF_AXIS_NON_NO) || (siAxis1 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SplMoveData(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis1);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set pass Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 축 ID 범위 오류 */
	if ((siAxis2 < DEF_AXIS_NON_NO) || (siAxis2 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SplMoveData(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis2);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set pass Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 축 ID 범위 오류 */
	if ((siAxis3 < DEF_AXIS_NON_NO) || (siAxis3 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SplMoveData(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis3);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set pass Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdPoint1 == NULL)
	{
		//WriteErrorLog("SplMoveData(): pdPoint1 Pointer is NULL");
		SetErrorLevel(_T("MMC set pass Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pdPoint2 == NULL)
	{
		//WriteErrorLog("SplMoveData(): pdPoint2 Pointer is NULL");
		SetErrorLevel(_T("MMC set pass Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	/** 인수 Pointer 오류 */
	if (pdPoint3 == NULL)
	{
		//WriteErrorLog("SplMoveData(): pdPoint3 Pointer is NULL");
		SetErrorLevel(_T("MMC set pass Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

	for (int i=0; i<siLen; i++)
	{
		rgdPoint1[i] = motionRoundValue(*(pdPoint1 + i));
		rgdPoint2[i] = motionRoundValue(*(pdPoint2 + i));
		rgdPoint3[i] = motionRoundValue(*(pdPoint3 + i));
	}

	// **1202 -> msec 단위로 수정
	siAccel = (short)siAccel/4;
	// **050112
	if(siAccel <= 0) siAccel = 1;

#ifndef SIMULATION
	/** 위치 경로 설정 */
	if ((siResult = spl_move_data(siSplNum, siLen, siAxis1, siAxis2, siAxis3, pdPoint1, pdPoint2, pdPoint3, motionRoundValue(dVelocity), siAccel)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SplMoveData(): spl_move_data(set position paths) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC set pass Points in CP Motion"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 지정 3축이 Spline Motion으로 SplMoveData()에서 지정한 위치를 경유하면서 연속 이동한다.
 *
 * MMC Library : spl_movex()
 *
 * @param	siSplNum		: Spline Motion 번호, 1 ~ 20
 * @param	siAxis1			: 축1 ID (0 ~ 63)
 * @param	siAxis2			: 축2 ID (0 ~ 63)
 * @param	siAxis3			: 축3 ID (0 ~ 63)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID SPLINE MOTION NUMBER (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::SplMovex(short siSplNum, short siAxis1, short siAxis2, short siAxis3)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** Spline Motion 번호 범위 오류 */
	if ((siSplNum < DEF_SPLINE_MOTION_MIN_NO) || (siSplNum > DEF_SPLINE_MOTION_MAX_NO))
	{
		//strLogMsg.Format(_T("SplMovex(): Invalid SplNum(SplNum=%d is out of range)"), siSplNum);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("3 AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106078);	// ERR_MLIB_INVALID_SPLINE_MOTION_NUMBER
	}

	/** 축 ID 범위 오류 */
	if ((siAxis1 < DEF_AXIS_NON_NO) || (siAxis1 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SplMovex(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis1);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("3 AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 축 ID 범위 오류 */
	if ((siAxis2 < DEF_AXIS_NON_NO) || (siAxis2 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SplMovex(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis2);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("3 AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 축 ID 범위 오류 */
	if ((siAxis3 < DEF_AXIS_NON_NO) || (siAxis3 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("SplMovex(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis3);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("3 AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

#ifndef SIMULATION
	/** 위치 경로따라 이동 */
	if ((siResult = spl_movex(siSplNum, siAxis1, siAxis2, siAxis3)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("SplMovex(): spl_movex(pass through given paths, Spline Motion) Fail - Error# is %d"), siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("3 AXIS pass through Points in CP Motion"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 각 Board별 ROM Version을 읽는다.
 *
 * MMC Library : version_chk()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	*psiVersion		: ROM Version, 101 => 1.01
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::VersionCheck(short siBdNum, short *psiVersion)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("VersionCheck(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC check Version(BoradNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

	/** 인수 Pointer 오류 */
	if (psiVersion == NULL)
	{
		//WriteErrorLog("VersionCheck(): psiVersion Pointer is NULL");
		strLogMsg.Format(_T("MMC check Version(BoradNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

#ifndef SIMULATION
	/** ROM Version 읽기 */
	if ((siResult = version_chk(siBdNum, psiVersion)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("VersionCheck(): version_chk(check the ROM version) Fail[BoardNo=%d] - Error# is %d"), siBdNum, siResult);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC check Version(BoradNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	*psiVersion = 130;
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * 해당 Error Code의 Error Message를 반환한다.
 *
 * MMC Library : error_message(), _error_message()
 *
 * @param	siCode			: Error Code
 * @param	*pcDst			: Error Message, m_iErrorBase + ERR_MAX_ERROR_LEN(80)보다 크거나 같아야 한다.
 * @return	Error Code		: 0 = SUCCESS
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::ErrorMessage(short siCode, char *pcDst)
{
	short siResult = ERR_MOTION_SUCCESS;
	CString strLogMsg;

#ifndef SIMULATION
	/** Error Code에 따른 Message 읽기 */
	if ((siResult = error_message(siCode, pcDst)) != ERR_MOTION_SUCCESS)
	{
		//strLogMsg.Format(_T("ErrorMessage(): error_message(return the error message) Fail[ErrorCode=%d] - Error# is %d"), siCode, siResult);
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("MMC return Error Message"),3, __FILE__, __LINE__);
		return makeMMCError((int)siResult);
	}
#else
	pcDst = "test";
#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * Position Compare Board를 초기화한다. (축 2를 사용할 때는 같은 Board의 축이어야 한다.)
 * 동일 Board의 축이 아니면 Error 처리됨.
 * Board 구성에 기록한다.
 *
 * MMC Library : position_compare_init()
 *
 * @param	siIndexSel		: Position Compare할 축, 1 ~ 2 (0=PC10 미사용)
 * @param	siAxis1			: 축1 ID (0 ~ 63), 동일 Board의 축이어야 한다.
 * @param	siAxis2			: 축2 ID (0 ~ 63), 동일 Board의 축이어야 한다. (siIndexSel=2일 때만 적용)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = ALREADY INITIALIZED POSITION COMPARE (MOTIONLIB)
 *							  xx = INVALID POSITION COMPARE INDEXSEL NUMBER (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID AXIS ID IN COMMON BOARD (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::PositionCompareInit(short siIndexSel, short siAxis1, short siAxis2)
{
	short siResult = ERR_MOTION_SUCCESS;
	SMotionBoard	mBd;
	BOOL	bUse = 0;
	int		iBdID = 0;
	short	siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** Position Compare할 축 개수 범위 오류 */
	if ((siIndexSel < DEF_PC_INDEXSEL_0) || (siIndexSel > DEF_PC_INDEXSEL_2))
	{
		//strLogMsg.Format(_T("PositionCompareInit(): Invalid Axis Number(AxisNo=%d is out of range)"), siIndexSel);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC initialize Position Compare Board(AxisNo=%d)"),siIndexSel);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106087);	// ERR_MLIB_INVALID_POSITION_COMPARE_INDEXSEL_NUMBER
	}

	/** 축 ID 범위 오류 */
	if ((siAxis1 < DEF_AXIS_NON_NO) || (siAxis1 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("PositionCompareInit(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis1);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC initialize Position Compare Board(AxisNo=%d)"),siIndexSel);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	iBdID = (int)(siAxis1 / DEF_AXIS_NO_PER_BRD);

	/** Position Compare 초기화수행 여부 */
	if (m_pBoardConfig->GetPC10BoardInitSuccess(iBdID) == TRUE)
	{
		//WriteErrorLog("PositionCompareInit(): GetPC10BoardInitSuccess Fail");
		strLogMsg.Format(_T("MMC initialize Position Compare Board(AxisNo=%d)"),siIndexSel);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106117);	// ERR_MLIB_ALREADY_INITIALIZED_POSITION_COMPARE
	}

	/** 축 2개를 사용할 경우 */
	if (siIndexSel == DEF_PC_INDEXSEL_2)
	{
		/** 축 ID 범위 오류 */
		if ((siAxis2 < DEF_AXIS_NON_NO) || (siAxis2 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		{
			//strLogMsg.Format(_T("PositionCompareInit(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis2);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC initialize Position Compare Board(AxisNo=%d)"),siIndexSel);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}

		/** 동일 Board 축 오류 */
		if (iBdID != (int)(siAxis1 / DEF_AXIS_NO_PER_BRD))
		{
			//WriteErrorLog("PositionCompareInit(): Invalid Board Range(the axes are not in same board)");
			strLogMsg.Format(_T("MMC initialize Position Compare Board(AxisNo=%d)"),siIndexSel);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return generateErrorCode(106116);	// ERR_MLIB_INVALID_AXIS_ID_IN_COMMON_BOARD
		}
	}

	if (siIndexSel != DEF_PC_INDEXSEL_0)
	{
//#if FALSE	// MMCWFI30.h에 있는 API인 듯...
//#ifndef SIMULATION
//		/** Position Compare 초기화 */
//		if ((siResult = position_compare_init(siIndexSel, siAxis1, siAxis2)) != ERR_MOTION_SUCCESS)
//		{
//			strLogMsg.Format(_T("PositionCompareInit(): position_compare_init Fail - Error# is %d"), siResult);
//			WriteErrorLog(strLogMsg);
//			return makeMMCError((int)siResult);
//		}
//#endif
//#endif

		bUse = TRUE;
	}
	else
		bUse = FALSE;

	/** Board 구성 읽기 */
	if ((siResult = m_pBoardConfig->GetBoardConfig(&mBd)) != ERR_MOTION_SUCCESS)
		return (int)siResult;

	/** Position Compare 사용이면 */
	if (bUse == TRUE)
	{
		mBd.rgiPC10IndexSel[iBdID] = siIndexSel;
		mBd.rgiPC10Axis[iBdID][0] = siAxis1;
		mBd.rgiPC10Axis[iBdID][1] = siAxis2;
	}
	/** Position Compare 사용 아니면 */
	else
	{
		mBd.rgiPC10IndexSel[iBdID] = DEF_PC_INDEXSEL_0;
		mBd.rgiPC10Axis[iBdID][0] = DEF_AXIS_NON_ID;
		mBd.rgiPC10Axis[iBdID][1] = DEF_AXIS_NON_ID;
	}

	m_pBoardConfig->SetPC10BoardInitSuccess(iBdID, bUse);

	/** Board 구성 설정 */
	if ((siResult = m_pBoardConfig->SetBoardConfig(mBd)) != ERR_MOTION_SUCCESS)
		return (int)siResult;

	return ERR_MOTION_SUCCESS;
}
/**
 * Position Compare를 설정한다. (Standard Type)
 *
 * MMC Library : position_compare()
 *
 * @param	siIndexSel		: Position Compare시 사용할 축 수, 1 ~ 2
 * @param	siIndexNum		: Position Compare를 실시할 Index 번호, 1 ~ 8
 * @param	siBitNo			: 출력할 I/O Bit 번호, 0 ~ 31
 * @param	siAxis1			: 축1 ID (0 ~ 63), 동일 Board의 축이어야 한다.
 * @param	siAxis2			: 축2 ID (0 ~ 63), 동일 Board의 축이어야 한다. (siIndexSel=2일 때만 적용)
 * @param	bLatch			: I/O 출력모드, FALSE=Transparent Mode, TRUE=Latch Mode
 * @param	siFunction		: Position Compare에 사용할 부등호, 1="=", 2=">", 3="<"
 * @param	siOutMode		: 지정 I/O의 출력모드, 0=축별 ON/OFF, 1=두축 AND, 2=두축 OR
 * @param	dPosition		: Position Compare에 사용될 위치 Data (> 0.0)
 * @param	lTime			: I/O 출력 시간, Transparent Mode일때만 적용, 40usec단위,  최대 5.38sec
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID POSITION COMPARE INDEXSEL NUMBER (MOTIONLIB)
 *							  xx = INVALID POSITION COMPARE INDEX NUMBER (MOTIONLIB)
 *							  xx = INVALID IO BIT NUMBER (MOTIONLIB)
 *							  xx = INVALID POSITION COMPARE FUNCTION TYPE (MOTIONLIB)
 *							  xx = INVALID POSITION COMPARE OUT MODE TYPE (MOTIONLIB)
 *							  xx = INVALID POSITION COMPARE IO OUT TIME (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::PositionCompare(short siIndexSel, short siIndexNum, short siBitNo, short siAxis1,
							  short siAxis2, BOOL bLatch, short siFunction, short siOutMode,
							  double dPosition, long lTime)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** Position Compare할 축 개수 범위 오류 */
	if ((siIndexSel < DEF_PC_INDEXSEL_1) || (siIndexSel > DEF_PC_INDEXSEL_2))
	{
		//strLogMsg.Format(_T("PositionCompare(): Invalid Axis Number(AxisNo=%d is out of range)"), siIndexSel);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Compare(AxisNo=%d)"),siIndexSel);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106087);	// ERR_MLIB_INVALID_POSITION_COMPARE_INDEXSEL_NUMBER
	}

	/** Index 번호 범위 오류 */
	if ((siIndexNum < DEF_PC_INDEX_MIN_NO) || (siIndexNum > DEF_PC_INDEX_MAX_NO))
	{
		//strLogMsg.Format(_T("PositionCompare(): Invalid Index Number(IndexNo=%d is out of range)"), siIndexNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Compare(AxisNo=%d)"),siIndexSel);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106088);	// ERR_MLIB_INVALID_POSITION_COMPARE_INDEX_NUMBER
	}

	/** I/O Bit 번호 범위 오류 */
	if ((siBitNo < DEF_MIN_IO_BIT) || (siBitNo > (DEF_MAX_IO_PER_BOARD - 1)))
	{
		//strLogMsg.Format(_T("PositionCompare(): Invalid I/O Bit Number(IOBitNo=%d is out of range)"), siBitNo);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Compare(AxisNo=%d)"),siIndexSel);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106101);	// ERR_MLIB_INVALID_IO_BIT_NUMBER
	}

	/** 축 ID 범위 오류 */
	if ((siAxis1 < DEF_AXIS_NON_NO) || (siAxis1 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("PositionCompare(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis1);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Compare(AxisNo=%d)"),siIndexSel);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 축 2개를 사용할 경우 */
	if (siIndexSel == DEF_PC_INDEXSEL_2)
	{
		/** 축 ID 범위 오류 */
		if ((siAxis2 < DEF_AXIS_NON_NO) || (siAxis2 > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
		{
			//strLogMsg.Format(_T("PositionCompare(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis2);
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("MMC set Position Compare(AxisNo=%d)"),siIndexSel);
			SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
			return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
		}
	}

	/** 비교 조건 범위 오류 */
	if ((siFunction < DEF_PC_EQUAL) || (siFunction > DEF_PC_LT))
	{
		//strLogMsg.Format(_T("PositionCompare(): Invalid Comparision Condition(Condition=%d is out of range)"), siFunction);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Compare(AxisNo=%d)"),siIndexSel);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106089);	// ERR_MLIB_INVALID_POSITION_COMPARE_FUNCTION_TYPE
	}

	/** 지정 I/O의 출력모드 범위 오류 */
	if ((siOutMode < DEF_PC_OUT_NON) || (siOutMode > DEF_PC_OUT_OR))
	{
		//strLogMsg.Format(_T("PositionCompare(): Invalid I/O Output Mode(Mode=%d is out of range)"), siOutMode);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Compare(AxisNo=%d)"),siIndexSel);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106084);	// ERR_MLIB_INVALID_POSITION_COMPARE_OUT_MODE_TYPE
	}

	/** I/O 출력 시간 범위 오류 */
	if ((bLatch == 0) && (lTime <= 0))
	{
		//strLogMsg.Format(_T("PositionCompare(): Invalid Output Time(Time=%d is out of range)"), lTime);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Compare(AxisNo=%d)"),siIndexSel);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106086);	// ERR_MLIB_INVALID_POSITION_COMPARE_IO_OUT_TIME
	}

//#if FALSE	// MMCWFI30.h에 있는 API인 듯...
//#ifndef SIMULATION
//	/** Position Compare 설정 */
//	if ((siResult = position_compare(siIndexSel, siIndexNum, siBitNo, siAxis1,
//									siAxis2, (short)bLatch, siFunction, siOutMode,
//									motionRoundValue(dPosition), lTime)) != ERR_MOTION_SUCCESS)
//	{
//		strLogMsg.Format(_T("PositionCompareInit(): position_compare Fail - Error# is %d"), siResult);
//		WriteErrorLog(strLogMsg);
//		return makeMMCError((int)siResult);
//	}
//#endif
//#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * Position Compare를 설정한다. (Interval Type)
 *
 * MMC Library : position_compare_interval()
 *
 * @param	bDir			: Position Compare시 +방향으로 이동시 동작시킬 것인지 -방향으로 동작시킬 것인 설정
 *							   FALSE="+", TRUE="-"
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siBitNo			: 출력할 I/O Bit 번호 (0 ~ 63)
 * @param	dStartPos		: I/O가 동작될 최초의 Position 값
 * @param	dLimitPos		: I/O가 동작될 마지막 Position 값
 * @param	lInterval		: I/O가 반복될 간격을 펄스수 단위로 지정
 * @param	lTime			: I/O 출력이 지속될 시간, 40sec 단위
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID IO BIT NUMBER (MOTIONLIB)
 *							  xx = INVALID POSITION COMPARE IO REPEAT TIME (MOTIONLIB)
 *							  xx = INVALID POSITION COMPARE IO OUT TIME (MOTIONLIB)
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::PositionCompareInterval(BOOL bDir, short siAxis, short siBitNo, double dStartPos, double dLimitPos,
							  long lInterval, long lTime)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("PositionCompareInterval(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Compare(Interval Type)(AxisNo=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** I/O Bit 번호 범위 오류 */
	if ((siBitNo < DEF_MIN_IO_BIT) || (siBitNo > (DEF_MAX_IO_PER_BOARD - 1)))
	{
		//strLogMsg.Format(_T("PositionCompareInterval(): Invalid I/O Bit Number(IOBitNo=%d is out of range)"), siBitNo);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Compare(Interval Type)(AxisNo=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106101);	// ERR_MLIB_INVALID_IO_BIT_NUMBER
	}

	/** I/O 반복 시간 범위 오류 */
	if (lInterval <= 0)
	{
		//strLogMsg.Format(_T("PositionCompareInterval(): Invalid I/O Interval Time(Time=%d is out of range)"), lInterval);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Compare(Interval Type)(AxisNo=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106085);	// ERR_MLIB_INVALID_POSITION_COMPARE_IO_REPEAT_TIME
	}

	/** I/O 출력 시간 범위 오류 */
	if (lTime <= 0)
	{
		//strLogMsg.Format(_T("PositionCompareInterval(): Invalid I/O Output Time(Time=%d is out of range)"), lTime);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Compare(Interval Type)(AxisNo=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106086);	// ERR_MLIB_INVALID_POSITION_COMPARE_IO_OUT_TIME
	}

//#if FALSE	// MMCWFI31.h에 있는 API인 듯...
//#ifndef SIMULATION
//	/** Position Compare 설정 */
//	if ((siResult = position_compare_interval((short)bDir, siAxis, siBitNo, motionRoundValue(dStartPos), motionRoundValue(dLimitPos),
//											  lInterval, lTime)) != ERR_MOTION_SUCCESS)
//	{
//		strLogMsg.Format(_T("PositionCompareInit(): position_compare_interval Fail - Error# is %d"), siResult);
//		WriteErrorLog(strLogMsg);
//		return makeMMCError((int)siResult);
//	}
//#endif
//#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * Position Compare 동작을 할 것인지 여부를 설정한다.
 *
 * MMC Library : position_compare_enable()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	bFlag			: FALSE=Position Compare 동작 Disable, TRUE=Enable
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::PositionCompareEnable(short siBdNum, BOOL bFlag)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("PositionCompareEnable(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC set Position Compare Enable(BoradNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

//#if FALSE	// MMCWFI30.h에 있는 API인 듯...
//#ifndef SIMULATION
//	/** Position Compare 동작 사용 여부 설정 */
//	if ((siResult = position_compare_enable(siBdNum, (short)bFlag)) != ERR_MOTION_SUCCESS)
//	{
//		strLogMsg.Format(_T("PositionCompareEnable(): position_compare_enable Fail[BoardNo=%d]- Error# is %d"), siBdNum, siResult);
//		WriteErrorLog(strLogMsg);
//		return makeMMCError((int)siResult);
//	}
//#endif
//#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * Position Compare의 Index를 초기화한다.
 *
 * MMC Library : position_compare_index_clear()
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	siIndexSel		: 항상 "1"로 설정
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::PositionCompareClear(short siBdNum, short siIndexSel)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNumber;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNumber);

	/** Board ID 범위 오류 */
	if ((siBdNum < DEF_NON_MOTION_BD) || (siBdNum > (siBdNumber - 1)))
	{
		//strLogMsg.Format(_T("PositionCompareClear(): Invalid Board Number(BoradNo=%d is out of range)"), siBdNum);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC initialize Position Compare Index(BoradNo=%d)"),siBdNum);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106097);	// ERR_MLIB_INVALID_MOTION_BOARD_ID
	}

//#if FALSE	// MMCWFI30.h에 있는 API인 듯...
//#ifndef SIMULATION
//	/** Position Compare Index 초기화 */
//	if ((siResult = position_compare_index_clear(siBdNum, 1)) != ERR_MOTION_SUCCESS)
//	{
//		strLogMsg.Format(_T("PositionCompareClear(): position_compare_index_clear Fail[BoardNo=%d]- Error# is %d"), siBdNum, siResult);
//		WriteErrorLog(strLogMsg);
//		return makeMMCError((int)siResult);
//	}
//#endif
//#endif

	return ERR_MOTION_SUCCESS;
}
/**
 * Position Compare 설정된 축의 Encoder 값을 읽어낸다.
 *
 * MMC Library : position_compare_read()
 *
 * @param	siIndexSel		: 항상 "1"로 설정
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pdPosition		: Encoder 값
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMMCLib::PositionCompareRead(short siIndexSel, short siAxis, double *pdPosition)
{
	short siResult = ERR_MOTION_SUCCESS;
	short siBdNum;
	CString strLogMsg;

	/** 구성 Board 개수 읽기 */
	m_pBoardConfig->GetBoardNum(&siBdNum);

	/** 축 ID 범위 오류 */
	if ((siAxis < DEF_AXIS_NON_NO) || (siAxis > (siBdNum * DEF_AXIS_NO_PER_BRD - 1)))
	{
		//strLogMsg.Format(_T("PositionCompareRead(): Invalid Axis ID(AxisID=%d is out of range)"), siAxis);
		//WriteErrorLog(strLogMsg);
		strLogMsg.Format(_T("MMC read Position Compare(Axis=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106109);	// ERR_MLIB_INVALID_AXIS_ID
	}

	/** 인수 Pointer 오류 */
	if (pdPosition == NULL)
	{
		//WriteErrorLog("PositionCompareRead(): pdPosition Pointer is NULL");
		strLogMsg.Format(_T("MMC read Position Compare(Axis=%d)"),siAxis);
		SetErrorLevel(strLogMsg,3, __FILE__, __LINE__);
		return generateErrorCode(106090);	// ERR_MLIB_INVALID_POINTER
	}

//#if FALSE	// MMCWFI30.h에 있는 API인 듯...
//#ifndef SIMULATION
//	/** Position Compare Encoder 읽기 */
//	if ((siResult = position_compare_read(1, siAxis, pdPosition)) != ERR_MOTION_SUCCESS)
//	{
//		strLogMsg.Format(_T("PositionCompareRead(): position_compare_read Fail[AxisID=%d]- Error# is %d"), siAxis, siResult);
//		WriteErrorLog(strLogMsg);
//		return makeMMCError((int)siResult);
//	}
//#endif
//#endif

	return ERR_MOTION_SUCCESS;
}

// 반올림 Function
double MMMCLib::motionRoundValue(double dVal)
{
	return (ceil(dVal + 0.5) - 1.0);
}

// MMC Library가 리턴하는 에러 코드를 System Error형태로 만든다
int MMMCLib::makeMMCError(int iError)
{
	// XXX XXX      XXX
	//   6 MMCError 인스턴스번호
	return (106000+iError)*1000+m_iInstanceNo;
}
