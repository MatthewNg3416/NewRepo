/* Generated by Together */
/* 
 * Motion Component
 *
 * Copyright 2004 by Mechatronics Center, Samsung Electronics, Inc.,
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of Smasung Electronics, Inc. ("Confidential Information"). You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Samsung.
 */

#include "stdafx.h"
#include "MMEILib.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif
	
/**
 * MMEILib.cpp : This file implements the class of MEI Motion Library.
 *				 이 파일은 MEI Motion Library를 위한 Class의 실행 코드를 구현한다.
 * @author Yong-Seog Pahn (dragon.pahn@samsung.com)
 * @version $Revision$
 */

int	MMEILib::iObjNo = 0;

/**
 * Constructor : create and clear data
 *				 Data를 생성하고 초기화한다.
 * @stereotype constructor
 */
MMEILib::MMEILib ()
{
}

/**
 * Destructor : Delete inner object
 *				내부 개체를 소멸한다.
 * @stereotype destructor
 */
MMEILib::~MMEILib ()
{
}

/**
 * 축 사용 여부 설정
 *
 * @param	siAxisID		: 축 ID
 * @param	bState			: 사용 여부 (TRUE=사용, FALSE=미사용)
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetUseAxis (short siAxisID, BOOL bState)
{
	return 0 /* SUCCESS */;
}

/**
 * 축 사용 여부 읽기
 *
 * @param	siAxisID		: 축 ID
 * @param	*pbState		: 사용 여부 (TRUE=사용, FALSE=미사용)
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetUseAxis (short siAxisID, BOOL *pbState)
{
	return 0 /* SUCCESS */;
}

/**
 * Motor Parameter 설정 (Board 초기화 후 사용 가능)
 *
 * 전달된 SMotionAxis의 내용으로 Motion을 설정한다. (축 1개 단위로 설정)
 *
 * @param	siAxisID		: 축 ID, -1=허용안됨
 * @param	mAx				: Motor Parameter
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 기록할지 여부, TRUE=boot file에 기록
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = USED AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMEILib::SetMotorParam (short siAxisID, SMotionAxis *pmAx, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * Motor Parameter 읽기
 *
 * @param	siAxisID		: 축 ID, -1=All Motor
 * @param	*pmAx			: Motor Parameter, siAxisID=-1이면 배열 구조로 구성
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetMotorParam (short siAxisID, SMotionAxis *pmAx)
{
	return 0 /* SUCCESS */;
}

/**
 * Motion Board Parameter 설정
 *
 * @param	iObjectID		: Object ID
 * @param	MotionBd		: Motion Board Parameter
 * @param	iErrorBase		: Error Code Start Number
 * @param	strFullFileName	: Log File Path & File Name
 * @param	ucLevel			: Log LEvel (None, Normal, Warning, Error)
 * @param	iDays			: Log 우지 일 수
 * @return	Error Code		: 0 = SUCCESS
 *							  그 외 = 타 함수 Return Error
 */
int MMEILib::SetBoardParam (int iObjectID, 
							SMotionBoard MotionBd, 
							int iErrorBase,
							CString strFullFileName,
							BYTE ucLevel,
							int iDays)
{
	return 0 /* SUCCESS */;
}

/**
 * Motion Board Parameter 읽기
 *
 * @param	*pmBd			: Motion Board Parameter
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetBoardParam (SMotionBoard *pmBd)
{
	return 0 /* SUCCESS */;
}

/**
 * 구성된 Board 개수 읽기
 *
 * @param	*psiBdNum		: Board 구성 개수
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetBoardNum (short *psiBdNum)
{
	return 0 /* SUCCESS */;
}

/**
 * Motion Board 초기화
 * 
 * 1. Motion Board 초기화가 수행된 경우
 * 	(1) Board 구성 수와 Board DPRAM Address가 같은 경우
 * 		→ Board 초기화 과정 Pass
 * 	(2) Board 구성 수가 다른 경우
 * 		→ Board 초기화 수행
 * 	(3) Board DPRAM Address가 다른 경우
 * 		→ Board 초기화 수행
 * 
 * 2. Motion Board 초기화가 수행되지 않은 경우
 * 	→ Board 초기화 수행
 *
 * @param	siBdNum			: Motion Board 수 (1 ~ 8)
 * @param	*plAddress		: Board DPRAM Address (Board 수만큼)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID MOTION BOARD NUMBER (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMEILib::Initialize (short siBdNum, long *plAddress)
{
	return 0 /* SUCCESS */;
}

/**
 * Motion Board 초기화 여부 읽기
 *
 * @param	*pbInit			: Board 초기화 여부, TRUE=초기화됐음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetBoardInit (BOOL *pbInit)
{
	return 0 /* SUCCESS */;
}

/**
 * Motion Board의 제어 축 수를 돌려준다.
 *
 * @param	siBdNum			: Motion Board ID (0 ~ 7)
 * @param	*psiAxes		: Board에 구성된 제어 축 수
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAxes (short siBdNum, short *psiAxes)
{
	return 0 /* SUCCESS */;
}

/**
 * 직선, 원, 원호등의 동작을 수행할 각 좌표계의 축을 정의
 *
 * @param	siAxNum			: 축 수
 * @param	*psiMapArray	: 축 ID 배열
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::MapAxes (short siAxNum, short *psiMapArray)
{
	return 0 /* SUCCESS */;
}

/**
 * 직선, 원, 원호등의 동작을 수행할 각 좌표계의 축을 정의
 *
 * @param	siAxis			: 축 ID, -1=프로그램지연
 * @param	*plDuration		: (OPTION=NULL) 지연시간 (1msec단위, siAxis=-1이면 생략가능)
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::Dwell (short siAxis, long *plDuration)
{
	return 0 /* SUCCESS */;
}

/**
 * I/O Bit가 지정된 상태로 될 때까지 해당 축의 다음 동작 실행을 지연한다.
 *
 * @param	siAxis			: 축 ID
 * @param	siBitNo			: I/O Bit No
 * @param	bState			: I/O Bit 상태
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::IOTrigger (short siAxis, short siBitNo, BOOL bState)
{
	return 0 /* SUCCESS */;
}

/**
 * 축 명령 수행에 대한 상태를 돌려준다.
 *
 * @param	siAxis			: 축 ID
 * @param	siType			: 조회 종류, 0=이동명령, 1=속도명령, 2=InPosition 범위내 여부
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::InCommand (short siAxis, short siType)
{
	return 0 /* SUCCESS */;
}

/**
 * 직선, 원, 원호등의 동작이 완료되었는지 여부를 돌려준다.
 *
 * @param	*pbStatus		: 완료 여부
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::AllDone (BOOL *pbStatus)
{
	return 0 /* SUCCESS */;
}

/**
 * 축의 동작 완료될 때까지 대기한다.
 *
 * @param	siAxis			: 축 ID
 * @param	siMode			: 대기 종류, 0=이동 및 속도이동 완료,
 *										 1=이동 및 속도이동 완료 & InPosition 범위내 이동 완료
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::WaitDone(short siAxis, short siMode)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축이 동작 완료될 때까지 기다린다.
 *
 * @param	siAxis			: 축 ID 혹은 축 수
 * @param	*psiAxis		: (OPTION=NULL) 축 ID 배열, siAxis가 축 수일 경우 사용
 *																 축 ID라면 생략 가능
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::WaitForDone(short siAxis, short *psiAxis)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 AMP Fault를 Clear하거나 Fault Port를 Enable 상태로 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bState			: 지정할 상태, FALSE=Clear, TRUE=Enable
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAmpFaultEnable(short siAxis, BOOL bState)
{
	return 0 /* SUCCESS */;
}

/**
 * 축 모든 현재 상태를 한꺼번에 읽는다.
 * psIstatus[0] = axis_source 함수값
 * psistatus[1] = in_sequence 함수값
 * psistatus[2] = get_com_velocity 함수값
 * psistatus[3] = get_act_velocity 함수값
 * psistatus[4] = motion_done 함수값
 * psistatus[5] = in_position 함수값
 * psistatus[6] = axis_done 함수값
 * 
 * plstatus[0] = get_io 함수값
 * 
 * pdstatus[0] = get_position 함수값
 * pdstatus[1] = get_command 함수값
 * pdstatus[2] = get_error 함수값
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiState		: 상태, (axis_source, in_sequence, get_com_velocity, get_act_velocity,
 *									 motion_done, in_position, axis_done 결과값)
 * @param	*plStatus		: 상태, (get_io 결과값)
 * @param	*pdStatus		: 상태, (get_position, get_command, get_error 결과값)
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  xx = INVALID POINTER (MOTIONLIB)
 */
int MMEILib::GetAllStatus(short siAxis, short *psiStatus, long *plStatus, double *pdStatus)
{
	return 0 /* SUCCESS */;
}

/**
 * 축 현재 상태를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*psiState		: 상태, 각 상태는 bit 조합으로 구성된다.
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAxisSource(short siAxis, short *psiState)
{
	return 0 /* SUCCESS */;
}

/**
 * 축의 센서 상태를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	siType			: 센서 종류, 0=Home, 1=Positive, 2=Negative
 * @param	*pbState		: 센서 상태, TRUE=Active, FALSE=No Active
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetSensorStatus(short siAxis, short siType, BOOL *pbState)
{
	return 0 /* SUCCESS */;
}

/**
 * AMP Disable/Enable 상태를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pbState		: AMP Enable 상태, TRUE=Enable, FALSE=Disable
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAmpEnable(short siAxis, BOOL *pbState)
{
	return 0 /* SUCCESS */;
}

/**
 * AMP Enable의 Active Level을 읽는다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*pbLevel		: Enable Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAmpEnableLevel(short siAxis, BOOL *pbLevel, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 축의 현재 Event 발생 상태를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*psiState		: Event 내역, 0=NO EVENT, 1=STOP EVENT, 2=ESTOP EVENT, 3=ABORT EVENT
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAxisState(short siAxis, short *psiState)
{
	return 0 /* SUCCESS */;
}

/**
 * Board의 Position Latch 여부를 읽는다.
 *
 * @param	siBdNum			: Board ID
 * @param	*pbState		: Position Latch 여부
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAxisLatchStatus(short siBdNum, BOOL *pbState)
{
	return 0 /* SUCCESS */;
}

/**
 * 발생된 Event를 해제하고, 다음 명령부터 실행한다.
 *
 * @param	siAxis			: 축 ID
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::ClearStatus(short siAxis)
{
	return 0 /* SUCCESS */;
}

/**
 * Board의 Frame Buffer를 Clear한다.
 *
 * @param	siAxis			: 축 ID
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::ClearFrames(short siAxis)
{
	return 0 /* SUCCESS */;
}

/**
 * 비어있는 Interpolation Frame 개수를 돌려준다.
 *
 * @param	siAxis			: 축 ID
 * @param	*psiFrameNo		: Frame 개수
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::FramesInterpolation(short siAxis, short *psiFrameNo)
{
	return 0 /* SUCCESS */;
}

/**
 * Board의 비어있는 Frame 개수를 돌려준다.
 *
 * @param	siAxis			: 축 ID
 * @param	*psiFrameNo		: 비어있는 Frame 개수
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::FramesLeft(short siAxis, short *psiFrameNo)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 Board의 Latch 상태를 지정하고, Latch Status를 False로 만들거나, S/W적으로
 * Position을 Latch한다.
 *
 * @param	siBdNum			: Board ID
 * @param	bType			: Latch 종류, FALSE=S/W Position Latch, TRUE=Board Latch Enable/Disable 지정
 * @param	bState			: (OPTION=FALSE) bType=1인 경우 Enable/Disable 지정
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::Latch(short siBdNum, BOOL bType, BOOL bState)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 Latch된 Position을 돌려준다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pdPosition		: Latch된 Position
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetLatchedPosition(short siAxis, double *pdPosition)
{
	return 0 /* SUCCESS */;
}

/**
 * 동작중 목표위치를 재지정할 때 사용한다. (원, 원호 동작중에는 적용되지 않는다.)
 *
 * @param	siLen			: 축 수
 * @param	*psiAxes		: 축 ID 배열
 * @param	*pdDist			: 위치 보정값
 * @param	*psiAccel		: 이동 가,감속 구간
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::CompensationPos(short siLen, short *psiAxes, double *pdDist, short *psiAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * 절대치 Motor의 Type을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*psiType		: Motor 종류, 1=삼성CSDJ, CSDJ+SERVO DRIVE, 2=YASKAWA SERVO DRIVE
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAbsEncoderType(short siAxis, short *psiType)
{
	return 0 /* SUCCESS */;
}

/**
 * 축의 이동 최고속도와 가,감속 구간값의 제한값을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pdVelocity		: 이동 최고속도, 1 ~ 2047000 coutn/sec
 * @param	*psiAccel		: 가,감속 구간값, 1 ~ 200, 10msec 단위
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetVelLimit(short siAxis, double *pdVelocity, short *psiAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * AMP Drive에 Fault 발생 시 동작할 Event를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pbStatus		: AMP Fault 상태를 읽는다.
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAmpFaultStatus(short siAxis, BOOL *pbStatus)
{
	return 0 /* SUCCESS */;
}

/**
 * AMP Drive에 Fault 발생 시 동작할 Event를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*psiAction		: 동작할 Event, NO EVENT, STOP EVENT, ESTOP EVENT, ABORT EVENT
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAmpFaultEvent(short siAxis, short *psiAction, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * AMP Enable의 Active Level을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pbLevel		: Enable 신호 Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAmpEanbleLevel(short siAxis, BOOL *pbLevel, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * AMP Fault의 Active Level을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pbLevel		: Fault 신호 Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAmpFaultLevel(short siAxis, BOOL *pbLevel, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * AMP Reset의 Active Level을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pbLevel		: Reset 신호 Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAmpResetLevel(short siAxis, BOOL *pbLevel, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 AMP Drive의 Resolution을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*psiResolution	: AMP Resolution, default=2500 pulse/rev
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAmpResolution(short siAxis, short *psiResolution, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 AMP Drive의 Resolution을 설정한다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	*psiRatioA		: Encoder 분주비 분자값
 * @param	*psiRatioB		: Encoder 분주비 분모값
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetEncoderRatio(short siAxis, short *psiRatioA, short *psiRatioB, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축을 회전/직선운동하는 무한회전 축인지 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pbStatus		: 무한회전 축 설정여부
 * @param	bType			: 운동 종류, FALSE=직선, TRUE=회전
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetEndlessAx(short siAxis, BOOL *pbStatus, BOOL bType, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 무한회전 축의 움직이는 영역을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pdRange		: 이동 영역
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetEndlessRange(short siAxis, double *pdRange, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 축의 위치결정 완료값과 위치결정 시 신호 Level을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pdInPosition	: 위치 결정값
 * @param	*psiLevel		: 신호 Level
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetInPosition(short siAxis, double *pdInPosition, short *psiLevel, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 InPosition 신호 사용여부를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pbReq			: 사용 여부, TRUE=사용
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetInpositionRequired(short siAxis, BOOL *pbReq, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 축의 위치오차 제한값과 Event를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pdLimit		: 위치오차 제한값, 최대 35000 count
 * @param	*psiAction		: 위치오차 Event, NO EVENT, ESTOP EVENT, ABORT EVENT
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetErrorLimit(short siAxis, double *pdLimit, short *psiAction, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 원점 복귀 시 Encoder의 C상 펄스 이용 여부를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pbIndexReq		: C상 펄스 사용 여부, TRUE=Home Sensor와 Encoder의 Index Pulse를 동시 검출,
 *												  FALSE=Home Sensor만 검출
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetIndexRequired(short siAxis, BOOL *pbIndexReq, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * I/O 8점에 대한  입,출력 모드를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pbMode			: 입, 출력 모드, TRUE=출력, FALSE=입력
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetIOMode(short siBdNum, BOOL *pbMode, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * Home, +/- 방향 Limit Switch Active시 동작할 Event와 신호 LEvel을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	siType			: Sensor 종류, 0=Home, 1=Positive, 2=Negative
 * @param	*psiLimit		: 동작할 Event
 * @param	*psiLevel		: 신호 Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetSensorLimit(short siAxis, short siType, short *psiLimit, short *psiLevel, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * +/- 방향으로 Motor가 이동할 수 있는 제한 위치값과 그 위치값에 도달했을 때 적용할 Event를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	bType			: 이동 방향, TRUE=Positive, FALSE=Negative
 * @param	*pdPosition		: 제한 위치값
 * @param	*psiLimit		: 적용할 Event
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetSWLimit(short siAxis, BOOL bType, double *pdPosition, short *psiLimit, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축이 어떤 Motor로 제어하는 축으로 지정되어 있는지 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*psiType		: Motor 종류, 0=속도형Servo, 1=일반Stepper, 2=MicroStepper 혹은 위치형Servo
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetMotorType(short siAxis, short *psiType, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축의 Feedback 장치와 Loop 형태를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*psiDevice		: Feedback 장치, 1=0~10volt입력, 2=-10~10volt입력
 * @param	*pbLoop			: Loop 형태, FALSE=Open Loop, TRUE=Closed Loop
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAxisProperty(short siAxis, short *psiDevice, BOOL *pbLoop, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축의 Pulse 분주비와 전자기어비를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*psiPgratio		: Pulse 분주비
 * @param	*pdEgratio		: 전자기어비
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetRatioProperty(short siAxis, short *psiPgratio, double *pdEgratio, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 속도형 Servo의 설정을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pbControl		: 제어모드, FALSE=속도제어, TRUE=위치제어
 * @param	*pbPolar		: Analog 출력 종류, FALSE=UNIPOLAR, TRUE=BIPOLER
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetVServoProperty(short siAxis, BOOL *pbControl, BOOL *pbPolar, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 Pulse 출력 형태를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pbMode			: Pulse 출력 형태, FALSE=Two Pulse(CW+CCW), TRUE=Sign+Pulse
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetStepMode(short siAxis, BOOL *pbMode, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 Encoder 입력 방향과 좌표 방향을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pbEncDir		: Encoder 입력 방향, FALSE=ENCO_CW(시계방향, - Count)
 *												 TRUE =ENCO_CCW(반시계방향, + Count)
 * @param	*pbCoorDir		: 좌표방향, FALSE=CORD_CW(시계방향, + 좌표 이동)
 *										TRUE =CORD_CCW(반시계방향, - 좌표 이동)
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetEncoderDirection(short siAxis, BOOL *pbEncDir, BOOL *pbCoorDir, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정된 축의 STOP EVENT, ESTOP EVENT 수행 시 감속 시간을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	bType			: 정지 종류, FALSE=STOP, TRUE=E-STOP
 * @param	*psiRate		: 감속 시간
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetStopRate(short siAxis, BOOL bType, short *psiRate, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 동기제어시 적용되는 보상 Gain값을 읽는다.
 *
 * @param	*psiCoeff		: 보상 Gain 값
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetSyncGain(short *psiCoeff)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축의 PID & FF Gain값들을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	siVelType		: 위치/속도 종류 지정, 0=위치, 1=속도
 * @param	*plGain			: Gain 값 배열, 뱌열인수위치는 아래와 같다.
 *								0=GA_P, 1=GA_I, 2=GA_D, 3=GA_F, 4=GA_LIMIT, 5=GAIN_MUNBER
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetGain(short siAxis, short siVelType, long *plGain, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축의 적분제어 시 적분제어 모드를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	bType			: 제어모드, FALSE=위치, TRUE=속도
 * @param	*pbMode			: 적분제어 모드, FALSE=항상적용, TRUE=정지시적용
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetIntegration(short siAxis, BOOL bType, BOOL *pbMode, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 속도지령 혹은 토크 지령에 대해 Low Pass Filter 혹은 Notch Filter에 대한 Filter 값을 읽는다.
 * boot file 또는 실행중인 memory에서 읽을 수 있다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bCommandType	: 지령 종류, FALSE=속도(Position), TRUE=토크(Velocity)
 * @param	bFilterType		: Filter 종류, FALSE=LowPass, TRUE=Notch
 * @param	*pdFilter		: Filter 값
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS
 *							  xx = INVALID AXIS ID (MOTIONLIB)
 *							  그 외 = 타 함수 Return Error
 */
int MMEILib::GetFilter(short siAxis, BOOL bCommandType, BOOL bFilterType, double *pdFilter, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축의 동작 중 속도를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	bType			: 속도 종류, FALSE=실제속도값, TRUE=속도명령값
 * @param	*psiPulse		: 속도의 Pulse값
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetVelocity(short siAxis, BOOL bType, short *psiPulse)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정된 Board의 축별 동작여부를 읽는다.
 *
 * @param	siBdNum			: Board ID
 * @param	*psiState		: 축별 동작 여부, bit가 한 축
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAxisRunStop(short siBdNum, short *psiState)
{
	return 0 /* SUCCESS */;
}

/**
 * 축의 실제위치 및 목표위치를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	bType			: 위치 종류, FALSE=실제위치, TRUE=목표위치
 * @param	*pdPosition		: bType=FALSE이면, 지정할 실제위치
 *							  bType=TRUE 이면, 지정할 목표위치
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetPosition(short siAxis, BOOL bType, double *pdPosition)
{
	return 0 /* SUCCESS */;
}

/**
 * Motor의 지령치 RPM이나 실제 RPM을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*psiRpm			: RPM값
 * @param	bType			: RMP 종류, FALSE=실제RPM, TRUE=지령치RPM
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetRpm(short siAxis, short *psiRpm, BOOL bType)
{
	return 0 /* SUCCESS */;
}

/**
 * Board별 Sampling Rate를 읽는다.
 *
 * @param	siBdNum			: Board ID
 * @param	*psiTime		: Sampling Rate, msec단위 (1, 2, 4msec만 지원)
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetControlTimer(short siBdNum, short *psiTime, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 축의 목표위치와 실제위치의 차이값인 위치오차를 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*pError			: 위치오차, (목표위치-실제위치)
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetError(short siAxis, double *pError)
{
	return 0 /* SUCCESS */;
}

/**
 * 특정 축의 Encoder Feedback Data를 빠르게 읽어들일 때 사용 (50usec 주기 Update)
 *
 * @param	siAxis			: 축 ID
 * @param	*pbStatus		: 설정 여부
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetFastReadEncoder(short siAxis, BOOL *pbStatus)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축의 Analog Offset 값을 읽는다.
 *
 * @param	siAxis			: 축 ID
 * @param	*psiOffset		: Analog Offer, +/-2048, +/-32767
 * @param	bBootOpt		: (OPTION=FALSE) boot file에서 읽을지 여부, TRUE=boot file에서 읽음
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAnalogOffset(short siAxis, short *psiOffset, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 입, 출력 Port의 32bit Data를 읽는다.
 *
 * @param	siPort			: 입, 출력 Port 번호
 * @param	bType			: 입, 출력 종류, FALSE=입력, TRUE=출력
 * @param	*plValue		: 32bit Data
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetIO(short siPort, BOOL bType, long *plValue)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정된 Analog 입/출력의 12/16bit Data 값을 읽는다.
 *
 * @param	siChannel		: Analog 입력 채널 수 혹은 출력 축 ID
 * @param	bType			: 입, 출력 종류, FALSE=입력, TRUE=출력
 * @param	*psiValue		: bType=FALSE이면 Analog 입력 값, -2048 ~ +2047
 *							  bType=TRUE이면 Analog 출력 값, +/-2048, +/-32767
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetAnalog(short siChannel, BOOL bType, short *psiValue)
{
	return 0 /* SUCCESS */;
}

/**
 * 충돌방지 기능의 사용여부를 읽는다.
 *
 * @param	siBdNum			: Board ID
 * @param	*pbMode			: 사용여부, TRUE=사용
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetCollisionPreventFlag(short siBdNum, BOOL *pbMode)
{
	return 0 /* SUCCESS */;
}

/**
 * 동기제어 여부를 읽는다.
 *
 * @param	*pbState		: 지정 여부, TRUE=지정
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetSyncControl(BOOL *pbState)
{
	return 0 /* SUCCESS */;
}

/**
 * Master축과 Slave축의 실제위치를 읽는다.
 *
 * @param	*pdMasterPos	: Master 축 위치
 * @param	*pdSlavePos		: Slave 축 위치
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetSyncPosition(double *pdMasterPos, double *pdSlavePos)
{
	return 0 /* SUCCESS */;
}

/**
 * Master축과 Slave축의 실제위치를 읽는다.
 *
 * @param	siID			: Board 혹은 축 ID
 * @param	siType			: 종류, 0=Board Enable/Disable, 1=STOP EVENT지정, 2=ESTOP EVENT지정
 * @param	bState			: 설정, TRUE =Enable지정,  STOP EVENT/ESTOP EVENT지정,
 *									FALSE=Disable지정, STOP EVENT/ESTOP EVENT미지정
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::IOInterrupt(short siID, short siType, BOOL bState, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * I/O Interrupt 발생 시 PC쪽으로 Interrupt를 발생시킬지 여부를 지정한다.
 *
 * @param	siBdNum			: Board ID
 * @param	bState			: 발생 여부, TRUE=발생
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::IOInterruptPCIRQ(short siBdNum, BOOL bState, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * PC Interrupt 발생 시 end of interrupt 신호를 발생시킨다.
 *
 * @param	siBdNum			: Board ID
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::IOInterruptPCIRQ_EOI(short siBdNum)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 PID 제어 여부를 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bState			: PID 제어 여부, FALSE=PID제어 미실시, Analog 출력 0volt,
 *											 TRUE =PID제어 실시
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetController(short siAxis, BOOL bState)
{
	return 0 /* SUCCESS */;
}

/**
 * AMP Disable/Enable 상태를 설정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bState			: AMP Enable 상태, TRUE=Enable
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAmpEnable(short siAxis, BOOL bState)
{
	return 0 /* SUCCESS */;
}

/**
 * 축의 이동 최고속도와 가,감속 구간값의 Limit를 지정한다. (boot file에 자동 저장)
 *
 * @param	siAxis			: 축 ID
 * @param	dVelocity		: 이동속도, 1 ~ 2047000 count/rev
 * @param	siAccel			: 가,감속구간값, 1 ~ 200, 10msec단위
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetVelLimit(short siAxis, double dVelocity, short siAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * AMP Drive에 Fault 발생 시 동작할 Event를 설정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	siAction		: 동작할 Event, NO EVENT, STOP EVENT, ESTOP EVENT, ABORT EVENT
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAmpFaultEvent(short siAxis, short siAction, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * AMP Enable의 Active Level을 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bLevel			: Enable Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAmpEnableLevel(short siAxis, BOOL bLevel, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * AMP Fault의 Active Level을 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bLevel			: Fault Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAmpFaultLevel(short siAxis, BOOL bLevel, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * AMP Reset의 Active Level을 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bLevel			: Reset Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAmpResetLevel(short siAxis, BOOL bLevel, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 AMP Drive의 Resolution을 설정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	siResolution	: AMP Resolution, default=2500 pulse/rev
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAmpResolution(short siAxis, short siResolution, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 분주비에 대한 분자값, 분모값을 읽는다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siRatioA		: Encoder 분주비 분자값
 * @param	siRatioB		: Encoder 분주비 분모값
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetEncoderRatio(short siAxis, short siRatioA, short siRatioB, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축을 회전/직선운동하는 무한회전 축으로 설정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bStatus			: 무한회전 축 설정여부
 * @param	siResolution	: Motor 1회전당 Pulse수
 * @param	bType			: 운동 종류, FALSE=직선, TRUE=회전
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetEndlessAx(short siAxis, BOOL bStatus, short siResolution, BOOL bType, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 무한회전 축의 움직이는 영역을 설정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	dRange			: 이동 영역
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetEndlessRange(short siAxis, double dRange, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 원점 복귀 시 Encoder의 C상 펄스 이용 여부를 설정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bIndexReq		: C상 펄스 사용 여부, TRUE =Home Sensor와 Encoder의 Index Pulse를 동시 검출,
 *												  FALSE=Home Sensor만 검출
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetIndexRequired(short siAxis, BOOL bIndexReq, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축을 해당 Motor로 제어하는 축으로 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	siType			: Motor 종류, 0=속도형Servo, 1=일반Stepper, 2=MicroStepper 혹은 위치형Servo
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetMotorType(short siAxis, short siType, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축의 Feedback 장치와 Loop 형태를 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	siDevice		: Feedback 장치, 0=ENCODER, 1=0~10volt입력, 2=-10~10volt입력
 * @param	bLoop			: Loop 형태, FALSE=Open Loop, TRUE=Closed Loop
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAxisProperty(short siAxis, short siDevice, BOOL bLoop, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축의 분주비와 전자기어비를 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	siPgratio		: Pulse 분주비, default=8
 * @param	dEgratio		: 전자기어비, default=1.0
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetRatioProperty(short siAxis, short siPgratio, double dEgratio, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 속도형 Servo의 설정을 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bControl		: 제어모드, FALSE=속도제어, TRUE=토크제어
 * @param	bPolar			: Analog 출력 종류, FALSE=UNIPOLAR, TRUE=BIPOLAR
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetVServoProperty(short siAxis, BOOL bControl, BOOL bPolar, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 Pulse 출력 형태를 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bMode			: Pulse 출력 형태, FALSE=Two Pulse(CW+CCW), TRUE=Sign+Pulse
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetStepMode(short siAxis, BOOL bMode, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 Encoder 입력 방향과 좌표 방향을 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bEncDir			: Encoder 입력 방향, FALSE=ENCO_CW(시계방향, - count),
 *												 TRUE =ENCO_CCW(반시계방향, + count)
 * @param	bCoorDir		: 좌표방향, FALSE=CORD_CW(시계방향, +좌표이동),
 *										TRUE =CORD_CCW(반시계방향, -좌표이동)
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetEncoderDirection(short siAxis, BOOL bEncDir, BOOL bCoorDir, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 Encoder 입력 방향과 좌표 방향을 지정한다.
 *
 * @param	siBdNum			: Board ID
 * @param	bMode			: 입, 출력 모드, TRUE=출력, FALSE=입력
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetIOMode(short siBdNum, BOOL bMode, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 축의 위치결정 완료값과 위치결정 시 신호 Level을 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	dInPosition		: 위치 결정값
 * @param	bLevel			: 신호 Level, TRUE=HIGH, FALSE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetInPosition(short siAxis, double dInPosition, BOOL bLevel, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 InPosition 신호 사용여부를 설정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bReq			: 사용 여부, TRUE=사용
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetInpositionRequired(short siAxis, BOOL bReq, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 축의 위치오차 Limit값과 Event를 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	dLimit			: 위치오차 Limit값, 최대 35000 count
 * @param	siAction		: 위치오차 Event, NO EVENT, STOP EVENT, ESTOP EVENT
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetErrorLimit(short siAxis, double dLimit, short siAction, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정된 축의 STOP EVENT, ESTOP EVENT 수행 시 감속 시간을 설정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bType			: 정지 종류, FALSE=STOP, TRUE=ESTOP
 * @param	siRate			: 감속 시간, default=10
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetStopRate(short siAxis, BOOL bType, short siRate, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * Home, +/- 방향 Limit Switch Active시 동작할 Event와 신호 Level을 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	siType			: Sensor 종류, 0=Home, 1=Positive, 2=Negative
 * @param	siLimit			: 동작할 Event
 * @param	bLevel			: 신호 Level, TRUE=HIGH, FLASE=LOW
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetSensorLimit(short siAxis, short siType, short siLimit, BOOL bLevel, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * +/- 방향으로 Motor가 이동할 수 있는 Limit 위치값과 그 위치값에 도달했을 때 적용될 Event를 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bType			: 방향, FALSE=Negative, TRUE=Positive
 * @param	dPosition		: 제한 위치값, +/-2147483647
 * @param	siLimit			: 적용될 Event
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetSWLimit(short siAxis, BOOL bType, double dPosition, short siLimit, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축의 PID & FF Gain 값들을 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bVelType		: 위치/속도 종류 지정, FALSE=위치, TRUE=속도
 * @param	*plGain			: Gain 값 배열, 배열인수 위치는 아래와 같다.
 *								0=GA_P, 1=GA_I, 2=GA_D, 3=GA_F, 4=GA_ILIMIT, 5=GAIN_NUMBER
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetGain(short siAxis, BOOL bVelType, long *plGain, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축의 적분 제어 시 적분 제어 모드를 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	bType			: 제어모드, FALSE=위치, TRUE=속도
 * @param	bMode			: 적분제어 모드, FALSE=항상적용, TRUE=정지시적용
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetIntegration(short siAxis, BOOL bType, BOOL bMode, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 속도지령 혹은 토크 지령에 대해 Low Pass Filter 혹은 Notch Filter에 대한 Filter 값을 설정한다.
 * boot file 또는 실행중인 memory에 저장할 수 있다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	bCommandType	: 지령 종류, FALSE=속도(Position), TRUE=토크(Velocity)
 * @param	bFilterType		: Filter 종류, FALSE=LowPass, TRUE=Notch
 * @param	dFilter			: Filter 값
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetFilter(short siAxis, BOOL bCommandType, BOOL bFilterType, double dFilter, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정된 Board의 축별 동작 여부를 설정한다.
 *
 * @param	siBdNum			: Board ID
 * @param	siState			: 축별 동작 여부, bit가 한 축을 의미
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAxisRunStop(short siBdNum, short siState)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 I/O bit를 HIGH(1)/LOW(0) 상태로 만든다.
 *
 * @param	siBitNo			: 지정할 I/O Bit 번호 (장착된 Board의 수량에 따라 달라짐)
 * @param	bValue			: 지정할 값, (TRUE, FALSE)
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetBit(short siBitNo, BOOL bValue)
{
	return 0 /* SUCCESS */;
}

/**
 * 32bit의 I/O Data를 출력 Port를 통해 내보낸다.
 *
 * @param	siPort			: 출력 Port 번호
 * @param	lValue			: 출력 값
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetIO(short siPort, long lValue)
{
	return 0 /* SUCCESS */;
}

/**
 * 12/16 bit Analog 출력전압을 내보낸다.
 *
 * @param	siAxis			: 축 ID
 * @param	siValue			: 출력할 전압 값, +/-2048, +/-32767
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetDacOut(short siAxis, short siValue)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 축의 Analog Offset값을 설정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	siOffset		: Analog OFfset, +/-2048, +/-32767
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAnalogOffset(short siAxis, short siOffset, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 축의 출력전압의 범위를 설정한다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siLimit			: A출력 전압 범위, 0 ~ 32767
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAnalogLimit(short siAxis, short siLimit, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 축의 실제 위치 및 목표 위치를 지정한다. (AMP Disable 상태에서 수행하는게 좋다.)
 *
 * @param	siAxis			: 축 ID
 * @param	bType			: 위치 종류, FALSE=실제위치, TRUE=목표위치
 * @param	dPosition		: bType=FALSE이면 지정할 실제위치, bType=TRUE이면 지정할 목표위치
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetPosition(short siAxis, BOOL bType, double dPosition)
{
	return 0 /* SUCCESS */;
}

/**
 * 특정 축의 Encoder Feedback Data를 빠르게 읽어들일 때 사용 (50usec 주기 Update)
 *
 * @param	siAxis			: 축 ID
 * @param	bStatus			: 설정 여부, TRUE=설정
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetFastReadEncoder(short siAxis, BOOL bStatus)
{
	return 0 /* SUCCESS */;
}

/**
 * 사용자가 Motion 관련 S/W를 자체 개발하여 시스템을 동작시킬 수 있도록 지원해주는 기능
 *
 * @param	siLen			: 제어대상 축 수
 * @param	*psiAxes		: 제어대상 축 ID를 배열구조로 설정
 * @param	*plDelt			: 매 Sampling Time(10msec)당 위치증가분 Data
 * @param	siFlag			: 속도 Profile의 시작과 끝을 알려주는데 사용, 1=동작시작, 2=동작중, 3=동작완료
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetInterpolation(short siLen, short *psiAxes, long *plDelt, short siFlag)
{
	return 0 /* SUCCESS */;
}

/**
 * 충돌방지 기능을 사용할 Mastr/Slave축 및 충돌방지 거리 및 조건 (+, -, >, <)을 설정한다.
 *
 * @param	siMasterAx		: Master 축 ID
 * @param	siSlaveAx		: Slave 축 ID
 * @param	bAddSub			: 오차 계산, FALSE=(Master현재위치-Slave현재위치),
 *										 TRUE=(Master현재위치+Slave현재위치)
 * @param	bNonEqual		: 비교, FALSE=(dPosition < bAddSub결과치),
 *									TRUE=(dPosition > bAddSub결과치)
 * @param	dPosition		: 충돌 방지 거리
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetCollisionPrevent(short siMasterAx, 
								 short siSlaveAx,
								 short siAddSub,
								 short siNonEqual,
								 double dPosition)
{
	return 0 /* SUCCESS */;
}

/**
 * 충돌방지 기능의 사용여부를 설정한다.
 *
 * @param	siBdNum			: Board ID
 * @param	bMode			: 사용 여부, TRUE=사용
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetCollisionPreventFlag(short siBdNum, BOOL bMode)
{
	return 0 /* SUCCESS */;
}

/**
 * Board DPRAM Address를 설정한다.
 *
 * @param	siBdNum			: Board ID
 * @param	lAddr			: DPRAM Address
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetDpramAddress(short siBdNum, long lAddr)
{
	return 0 /* SUCCESS */;
}

/**
 * 절대치 Motor의 Type을 지정한다.
 *
 * @param	siAxis			: 축 ID
 * @param	siType			: Motor 종류, 1=삼성CSDJ, CSDJ+SERVO DRIVE, 2=YASKAWA SERVO DRIVE
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAbsEncoderType(short siAxis, short siType)
{
	return 0 /* SUCCESS */;
}

/**
 * 절대치 Motor를 설정한다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetAbsEncoder(short siAxis)
{
	return 0 /* SUCCESS */;
}

/**
 * Servo Linear Flag 상태를 설정한다.
 *
 * @param	siAxis			: 축 ID (0 ~ 63)
 * @param	siFlag			: Servo Linear Flag 상태
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetServoLinearFlag(short siAxis, short siFlag, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 동기제어 여부를 지정한다.
 *
 * @param	bState			: 지정 여부, TRUE=동기제어 실행
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetSyncControl(BOOL bState)
{
	return 0 /* SUCCESS */;
}

/**
 * 동기제어할 Master축과 Slave축을 지정한다.
 *
 * @param	siMasterAx		: Master 축 ID
 * @param	siSlaveAx		: Slave 축 ID
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetSyncMapAxes(short siMasterAx, short siSlaveAx)
{
	return 0 /* SUCCESS */;
}

/**
 * 동기제어시 적용되는 보상 Gain값을 지정한다.
 *
 * @param	siCoeff			: 보상 Gain 값
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetSyncGain(short siCoeff, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * Board별 Sampling Rate를 설정한다.
 *
 * @param	siBdNum			: Board ID
 * @param	siTime			: Sampling Time(msec 단위), 1, 2, 4msec 설정 가능
 * @param	bBootOpt		: (OPTION=FALSE) boot file에 저장 여부, TRUE=boot file에 저장
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetControlTimer(short siBdNum, short siTime, BOOL bBootOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 직선 동작 혹은 직선, 원, 원호등의 동작 시 속도와 가,감속도를 지정한다.
 *
 * @param	dVelocity		: 속도
 * @param	siAccel			: 가,감속도
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetMoveSpeed(double dVelocity, short siAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * 자동 가,감속 기능의 사용여부를 지정한다.
 *
 * @param	siBdNum			: Board ID
 * @param	bState			: 사용여부, TURE=사용
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetSplAutoOff(short siBdNum, BOOL bState)
{
	return 0 /* SUCCESS */;
}

/**
 * 자동 가,감속 기능의 사용여부를 읽는다.
 *
 * @param	siBdNum			: Board ID
 * @param	*pbState		: 사용여부, TURE=사용
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::GetSplAutoOff(short siBdNum, BOOL *pbState)
{
	return 0 /* SUCCESS */;
}

/**
 * 축 이동을 정지한다.
 *
 * @param	siAxis			: 축 ID
 * @param	siType			: 정지 종류, 0=STOP, 1=ESTOP, 2=VSTOP
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetStop(short siAxis, short siType)
{
	return 0 /* SUCCESS */;
}

/**
 * 1축 속도 Profile 이동
 *
 * @param	siAxis			: 축 ID
 * @param	dPosition		: 이동할 위치, 혹은 상대거리
 * @param	dVelocity		: 이동 속도, 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도, 0=기지정된 가속도로 이동
 * @param	siDecel			: 이동 감속도, 0=기지정된 감속도로 이동
 * @param	siType			: 이동 Type, 0=사다리꼴 속도 Profile, 절대좌표 이동
 *										 1=S-Curve 속도 Profile, 절대좌표 이동
 *										 2=사다리꼴 속도 Profile, 상대거리 이동
 *										 3=S-Curve 속도 Profile, 상대거리 이동
 *										 4=비대칭 사다리꼴 속도 Profile, 절대좌표 이동
 *										 5=비대칭 S-Curve 속도 Profile, 절대좌표 이동
 *										 6=비대칭 사다리꼴 속도 Profile, 상대거리 이동
 *										 7=비대칭 S-Curve 속도 Profile, 상대거리 이동
 * @param	bWaitOpt		: (OPTION=FALSE) 이동 완료 대기 여부, TRUE=이동완료될때까지대기
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::Move(short siAxis,
				  double dPosition, 
				  double dVelocity, 
				  short siAccel,
				  short siDecel, 
				  short siType, 
				  BOOL bWaitOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 다축 속도 Profile 동시 이동
 *
 * @param	siLen			: 축 수, >0
 * @param	*psiAxis		: 축 ID (축 수 만큼 존재)
 * @param	*pdPosition		: 이동할 위치, 혹은 상대거리 (축 수 만큼 존재)
 * @param	*pdVelocity		: 이동 속도 (축 수 만큼 존재), 0.0=기지정된 속도로 이동
 * @param	*psiAccel		: 이동 가속도 (축 수 만큼 존재), 0=기지정된 가속도로 이동
 * @param	*psiDecel		: 이동 감속도 (축 수 만큼 존재), 0=기지정된 감속도로 이동
 * @param	siType			: 이동 Type, 0=사다리꼴 속도 Profile, 절대좌표 이동
 *										 1=S-Curve 속도 Profile, 절대좌표 이동
 *										 2=사다리꼴 속도 Profile, 상대거리 이동
 *										 3=S-Curve 속도 Profile, 상대거리 이동
 *										 4=비대칭 사다리꼴 속도 Profile, 절대좌표 이동
 *										 5=비대칭 S-Curve 속도 Profile, 절대좌표 이동
 *										 6=비대칭 사다리꼴 속도 Profile, 상대거리 이동
 *										 7=비대칭 S-Curve 속도 Profile, 상대거리 이동
 * @param	bWaitOpt		: (OPTION=FALSE) 이동 완료 대기 여부, TRUE=이동완료될때까지대기
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::MoveAll(short siLen, 
					 short *psiAxes,
					 double *pdPosition, 
					 double *pdVelocity,
					 short *psiAccel,
					 short *psiDecel, 
					 short siType,
					 BOOL bWaitOpt)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정된 n축이 주어진 좌표값만큼 직선이동을 한다. (다른 Board의 축 사용 불가)
 *  MapAxes(), SetMoveSpped()에서 지정된 축들이 이동한다.
 *
 * @param	siLen			: 축 수, >0
 * @param	*pdPosition		: 이동할 좌표값 (축 수 만큼 존재)
 * @param	siType			: 이동 Type, 0=사다리꼴 속도 Profile, 절대좌표 이동
 *										 1=S-Curve 속도 Profile, 절대좌표 이동
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::MoveN(short siLen, double *pdPosition, short siType)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정된 n축이 주어진 좌표값만큼 직선이동을 한다. (다른 Board의 축 사용 가능)
 *
 * @param	siLen			: 축 수, >0
 * @param	*psiAxes		: 축 ID 배열
 * @param	*pdPosition		: 이동할 좌표값 (축 수 만큼 존재)
 * @param	siType			: 이동 Type, 0=사다리꼴 속도 Profile, 절대좌표 이동
 *										 1=S-Curve 속도 Profile, 절대좌표 이동
 * @param	dVelocity		: 이동 속도 (축 수 만큼 존재), 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도 (축 수 만큼 존재), 0=기지정된 가속도로 이동
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::MoveNAx(short siLen, 
					 short *psiAxes,
					 double *pdPosition,
					 short siType,
					 double dVelocity,
					 short siAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정된 그룹의 축들이 주어진 좌표값만큼 직선이동을 한다.
 *
 * @param	siGrpNum		: Group 번호, 1 ~ 4
 * @param	siLen			: 축 수, >0
 * @param	siAxes			: 축 ID 배열
 * @param	*psPosition		: 이동할 좌표값 (축 수 만큼 존재)
 * @param	siType			: 이동 Type, 0=사다리꼴 속도 Profile, 절대좌표 이동
 *										 1=S-Curve 속도 Profile, 절대좌표 이동
 * @param	dVelocity		: 이동 속도 (축 수 만큼 존재), 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도 (축 수 만큼 존재), 0=기지정된 가속도로 이동
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::MoveNAxGr(short siGrpNum,
					   short siLen, 
					   short *psiAxes, 
					   double *pdPosition,
					   short siType, 
					   double dVelocity, 
					   short siAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * 가속 후 등속 이동한다.
 *
 * @param	siAxis			: 축 ID
 * @param	dVelocity		: 이동 속도, 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도, 0=기지정된 가속도로 이동
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::VMove(short siAxis, double dVelocity, short siAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * 현재 위치에서 주어진 2/3차원 평면상의 좌표점까지 가,감속하면서 원호 CP Motion으로 이동한다.
 *  (다른 Board의 축 사용 불가)
 *  MapAxes(), SetMoveSpped()에서 지정된 축들이 이동한다.
 *
 * @param	siAxNum			: 축 수, 2=2축, 3=3축
 * @param	dCenterX		: 회전 중심 X좌표
 * @param	dCenterY		: 회전 중심 Y좌표
 * @param	*pdPoint		: 이동할 좌표, 2축이면 2차원배열, 3축이면 3차원배열
 * @param	dVelocity		: 이동 속도, 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도, 0=기지정된 가속도로 이동
 * @param	bDir			: 회전방향, FALSE=CIR_CW(시계방향), TRUE=CIR_CCW(반시계방향)
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SplArcMove(short siAxNum,
						double dCenterX,
						double dCenterY,
						double *pdPoint, 
						double dVelocity, 
						short siAccel, 
						BOOL bDir)
{
	return 0 /* SUCCESS */;
}

/**
 * 현재 위치에서 주어진 좌표점까지 가,감속하면서 원호 CP Motion으로 이동한다.
 *  (다른 Board의 축 사용 가능)
 *
 * @param	siLen			: 축 수
 * @param	*psiAxes		: 축 ID 배열
 * @param	siCenterX		: 회전 중심 X좌표
 * @param	siCenterY		: 회전 중심 Y좌표
 * @param	*pdPoint		: 이동할 좌표 (축 수 만큼 존재)
 * @param	dVelocity		: 이동 속도, 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도, 0=기지정된 가속도로 이동
 * @param	bDir			: 회전방향, FALSE=CIR_CW(시계방향), TRUE=CIR_CCW(반시계방향)
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SplArcMoveNax(short siLen, 
						   short *psiAxes, 
						   double dCenterX,
						   double dCenterY,
						   double *pdPoint,
						   double dVelocity, 
						   short siAccel,
						   BOOL bDir)
{
	return 0 /* SUCCESS */;
}

/**
 * 현재 위치에서 주어진 2/3차원 평면상의 좌표점까지 가,감속하면서 직선 CP Motion으로 이동한다.
 *  (다른 Board의 축 사용 불가)
 *  MapAxes(), SetMoveSpped()에서 지정된 축들이 이동한다.
 *
 * @param	siAxNum			: 축 수, 2=2축, 3=3축
 * @param	*pdPoint		: 이동할 좌표, 2축이면 2차원배열, 3축이면 3차원배열
 * @param	dVelocity		: 이동 속도, 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도, 0=기지정된 가속도로 이동
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SplLineMoveN(short siAxNum, double *pdPoint, double dVelocity, short siAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * 현재 위치에서 주어진 좌표점까지 가,감속하면서 직선 CP Motion으로 이동한다.
 *  (다른 Board의 축 사용 가능)
 *
 * @param	siLen			: 축 수
 * @param	*psiAxes		: 축 ID 배열
 * @param	*pdPoint		: 이동할 좌표 (축 수 만큼 존재)
 * @param	dVelocity		: 이동 속도, 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도, 0=기지정된 가속도로 이동
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SplLineMoveNax(short siLen,
							short *psiAxes, 
							double *pdPoint, 
							double dVelocity,
							short siAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * 원, 원호 이동 시 원주속도를 지정한다.
 *
 * @param	dDegree			: 원주속도, 0 < dDegree < 1000.0
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SetArcDivision(double dDegree)
{
	return 0 /* SUCCESS */;
}

/**
 * 주어진 중심에서 지정된 각도만큼 원호를 그리며 동작을 수행한다.
 *  (다른 Board의 축 사용 불가)
 *  MapAxes(), SetMoveSpped()에서 지정된 축들이 이동한다.
 *
 * @param	siCenterX		: 회전 중심 X좌표
 * @param	siCenterY		: 회전 중심 Y좌표
 * @param	dAngle			: 회전 각도
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::Arc2(double dXCenter, double dYCenter, double dAngle)
{
	return 0 /* SUCCESS */;
}

/**
 * 주어진 중심에서 지정된 각도만큼 원호를 그리며 동작을 수행한다.
 *  (다른 Board의 축 사용 불가)
 *
 * @param	siAxis1			: 축1 ID
 * @param	siAxis2			: 축2 ID
 * @param	siCenterX		: 회전 중심 X좌표
 * @param	siCenterY		: 회전 중심 Y좌표
 * @param	dAngle			: 회전 각도
 * @param	dVelocity		: 이동 속도, 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도, 0=기지정된 가속도로 이동
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::Arc2Ax(short siAxis1, 
					short siAxis2,
					double dXCenter, 
					double dYCenter,
					double dAngle,
					double dVelocity, 
					short siAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * 주어진 사각형의 가로와 세로의 길이를 이용하여 현재위치에서 상대이동을 하면서 CP Motion으로 사각형을 그린다.
 *
 * @param	siAxis1			: 축1 ID
 * @param	siAxis2			: 축2 ID
 * @param	*pdPoint		: 현재위치와 대각선방향의 X, Y 좌표
 * @param	dVelocity		: 이동 속도, 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도, 0=기지정된 가속도로 이동
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::RectMove(short siAxis1,
					  short siAxis2, 
					  double *pdPoint,
					  double dVelocity,
					  short siAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * 현재위치에서 주어진 위치를 경유하면서 CP Motion으로 이동한다.
 *
 * @param	siLen			: 위치 Data 개수, 최대 30
 * @param	siAxis1			: 축1 ID
 * @param	siAxis2			: 축2 ID
 * @param	siAxis3			: 축3 ID
 * @param	*pdPointX		: X좌표 배열
 * @param	*pdPointY		: Y좌표 배열
 * @param	*pdPointZ		: Z좌표 배열
 * @param	dVelocity		: 이동 속도, 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도, 0=기지정된 가속도로 이동
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SplMove(short siLen, 
					 short siAxis1,
					 short siAxis2, 
					 short siAxis3,
					 double *pdPointX,
					 double *pdPointY,
					 double *pdPointZ,
					 double dVelocity,
					 short siAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * SplMoveX()에 필요한 위치경로를 설정한다.
 *
 * @param	siSplNum		: Spline Motion 번호, 1 ~ 20
 * @param	siLen			: 이동 경로 수, 1 ~ 500
 * @param	siAxis1			: 축1 ID
 * @param	siAxis2			: 축2 ID
 * @param	siAxis3			: 축3 ID
 * @param	*pdPoint1		: 1좌표 배열
 * @param	*pdPoint2		: 2좌표 배열
 * @param	*pdPoint3		: 3좌표 배열
 * @param	dVelocity		: 이동 속도, 0.0=기지정된 속도로 이동
 * @param	siAccel			: 이동 가속도, 0=기지정된 가속도로 이동
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SplMoveData(short siSplNum,
						 short siLen,
						 short siAxis1,
						 short siAxis2,
						 short siAxis3,
						 double *pdPoint1,
						 double *pdPoint2,
						 double *pdPoint3,
						 double dVelocity, 
						 short siAccel)
{
	return 0 /* SUCCESS */;
}

/**
 * 지정 3축이 Spline Motion으로 SplMoveData()에서 지정한 위치를 경유하면서 연속 이동한다.
 *
 * @param	siSplNum		: Spline Motion 번호, 1 ~ 20
 * @param	siAxis1			: 축1 ID
 * @param	siAxis2			: 축2 ID
 * @param	siAxis3			: 축3 ID
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::SplMovex(short siSplNum, short siAxis1, short siAxis2, short siAxis3)
{
	return 0 /* SUCCESS */;
}

/**
 * 각 Board별 ROM Version을 읽는다.
 *
 * @param	siBdNum			: Board ID
 * @param	*psiVersion		: ROM Version, 101 => 1.01
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::VersionCheck(short siBdNum, short *psiVersion)
{
	return 0 /* SUCCESS */;
}

/**
 * 해당 Error Code의 Error Message를 반환한다.
 *
 * @param	siCode			: Error Code
 * @param	*pcDst			: Error Message, MAX_ERROR_LEN(100)보다 크거나 같아야 한다.
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::ErrorMessage(short siCode, char *pcDst)
{
	return 0 /* SUCCESS */;
}

/**
 * Position Compare Board를 초기화한다.
 *
 * @param	siIndexSel		: Position Compare할 축, 1 ~ 2
 * @param	siAxis1			: 축1 ID
 * @param	siAxis2			: 축2 ID
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::PositionCompareInit(short siIndexSel, short siAxis1, short siAxis2)
{
	return 0 /* SUCCESS */;
}

/**
 * Position Compare를 설정한다. (Standard Type)
 *
 * @param	siIndexSel		: Position Compare시 사용할 축 수, 1 ~ 2
 * @param	siIndexNum		: Position Compare를 실시할 Index 번호, 1 ~ 8
 * @param	siBitNo			: 출력할 I/O Bit 번호, 0 ~ 31
 * @param	siAxis1			: 축1 ID
 * @param	siAxis2			: 축2 ID
 * @param	bLatch			: I/O 출력모드, FALSE=Transparent Mode, TRUE=Latch Mode
 * @param	siFunction		: Position Compare에 사용할 부등호, 1="=", 2=">", 3="<"
 * @param	siOutMode		: 지정 I/O의 출력모드, 0=축별 ON/OFF, 1=두축 AND, 2=두축 OR
 * @param	dPosition		: Position Compare에 사용될 위치 Data (> 0.0)
 * @param	lTime			: I/O 출력 시간, Transparent Mode일때만 적용, 40usec ~ 5.38sec
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::PositionCompare(short siIndexSel, 
							 short siIndexNum,
							 short siBitNo, 
							 short siAxis1,
							 short siAxis2,
							 BOOL bLatch,
							 short siFunction,
							 short siOutMode,
							 double dPosition, 
							 long lTime)
{
	return 0 /* SUCCESS */;
}

/**
 * Position Compare를 설정한다. (Interval Type)
 *
 * @param	bDir			: Position Compare시 +방향으로 이동시 동작시킬 것인지 -방향으로 동작시킬 것인 설정
 *							   FALSE="+", TRUE="-"
 * @param	siAxis			: 축 ID
 * @param	siBitNo			: 출력할 I/O Bit 번호 (0 ~ 63)
 * @param	dStartPos		: I/O가 동작될 최초의 Position 값
 * @param	dLimitPos		: I/O가 동작될 마지막 Position 값
 * @param	lInterval		: I/O가 반복될 간격을 펄스수 단위로 지정
 * @param	lTime			: I/O 출력이 지속될 시간, 1=40sec
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::PositionCompareInterval(BOOL bDir,
									 short siAxis,
									 short siBitNo, 
									 double dStartPos,
									 double dLimitPos,
									 long lInterval,
									 long lTime)
{
	return 0 /* SUCCESS */;
}

/**
 * Position Compare 동작을 할 것인지 여부를 설정한다.
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	bFlag			: FALSE=Position Compare 동작 Disable, TRUE=Enable
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::PositionCompareEnable(short siBdNum, BOOL bFlag)
{
	return 0 /* SUCCESS */;
}

/**
 * Position Compare의 Index를 초기화한다.
 *
 * @param	siBdNum			: Board ID (0 ~ 7)
 * @param	siIndexSel		: 항상 "1"로 설정
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::PositionCompareClear(short siBdNum, short siIndexSel)
{
	return 0 /* SUCCESS */;
}

/**
 * Position Compare 설정된 축의 Encoder 값을 읽어낸다.
 *
 * @param	siIndexSel		: 항상 "1"로 설정
 * @param	siAxis			: 축 ID
 * @param	*pdPosition		: Encoder 값
 * @return	Error Code		: 0 = SUCCESS, 그 외 = Error
 */
int MMEILib::PositionCompareRead(short siIndexSel, short siAxis, double *pdPosition)
{
	return 0 /* SUCCESS */;
}

