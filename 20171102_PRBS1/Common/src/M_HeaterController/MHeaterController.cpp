/* Generated by Together */
/* samsung */
/* 
 * Heater Controller Component Component
 *
 * Copyright 2004 by Mechatronics Center, Samsung Electronics, Inc.,
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of Smasung Electronics, Inc. ("Confidential Information"). You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Samsung.
 */

/**
 * MHeaterController.cpp : This file implements the interface class of IHeaterController.
 *
 *
 * @author  Arena99 
 * @version $Revision$
 */

#include "StdAfx.h"
#include "MHeaterController.h"
#include "MTickTimer.h"

// ML_hongju
#include "atlconv.h"

#include "common.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

MHeaterController::MHeaterController()
{
	m_dTimeoutSerialComm	= 3.0; // default timeout interval
	m_dMaxTemperature		= DEF_MAX_TEMPERATURE;
	m_dMinTemperature		= DEF_MIN_TEMPERATURE;
	m_iNumHeaters			= 28;
}


/** Constructor, Destructor, 초기화 관련 */
/** @stereotype constructor
 * @param	iObjectID : int RegisterObject()에서 반환한 ObjectID
 * @param   listRefComponent :  SAcfToolRefComList, 참조할 Component List 구조체
 * @param   iErrorBase : int, Component의 에러 시작 
 * @param   strFullFileName : CString, 로그 파일 Path와 이름 
 * @param   ucLevel : BYTE, 로그 수준(MLog Class 참조)
 * @param   iDalys : int, 로깅보관 기간, Default 30
 * @param   datComponent; SHeaterControllerData, 콤포넌트의 데이타 구조
 */
MHeaterController::MHeaterController(	SCommonAttribute commonData, 
										SHeaterControllerRefCompList listRefComponent, 
										SHeaterControllerData datComponent)
: ICommon(commonData)
{
	CString strLogMsg;

	// memory allocation for SHeaterControllerRefCompList and assignment
	AssignComponents(listRefComponent);

	// memory allocation for Data and assignment
	SetData(datComponent);

	Initialize();
}

/** @stereotype destructor */
MHeaterController::~MHeaterController()
{
	TRACE(_T("MHeaterController 소멸\n"));
}

/**
 * Initialize Heaer Controller Component. 
 *
 * Local variable initialization
 * @return  Error Code : 0 = Success
 *                        그외= Error
 */
int MHeaterController::Initialize()
{
	CString strLogMsg;

	// max temperature
	if( m_dMaxTemperature == 0.0 )
		m_dMaxTemperature = DEF_MAX_TEMPERATURE;
	else
		m_dMaxTemperature = m_dMaxTemperature;

	// min temperature
	if( m_dMinTemperature == 0.0 )
		m_dMinTemperature = DEF_MIN_TEMPERATURE;
	else
		m_dMaxTemperature = m_dMaxTemperature;

	// serial comm timeout
	if( m_dTimeoutSerialComm == 0.0 )
		m_dTimeoutSerialComm = 3.0; // default timeout interval( msec )

	// critical section
	InitializeCriticalSection(&m_csHeaterControl);

	return ERR_HEATER_CONTROLLER_SUCCESS;
}


/*---------- Controlling Tool Temperature Operations --------------------*/
/**
* Setting Temperature of the given indexed Heater
*
* @param	eHeaterIndex : heater index - 1,2,3 (1-Based)
* @param	dTemperature : temperature to be set( Min/Max definded in DefHeaterController.h )
* @return	Error Code : 0 = SUCCESS, etc = Error
*/
int	MHeaterController::SetHeaterTemperature( EHeaterControllerID eHeaterIndex, double dTemperature )
{
	int iResult;
	CString strLogMsg;
	CString strReceiveResponse;
	// ML_hongju 수정..
//	char* chReceiveResponse;
	MTickTimer timerTimeOutCheck;
	double dTemp;
	char buffer[512];
	memset(buffer, 0, sizeof(buffer));

//	chReceiveResponse= "";
	// Check Temperature Range
	if( dTemperature < m_dMinTemperature || dTemperature > m_dMaxTemperature )
	{
		//strLogMsg.Format(_T("SetHeaterTemperature(Temperature=%f) : Out Range Error"), dTemperature );
		//WriteErrorLog(strLogMsg);
		//strLogMsg.Format(_T("HEATERCONTROLLER set Heater Temperature(Temperature=%f)."), dTemperature);
		//SetErrorLevel(strLogMsg,2, __FILE__, __LINE__);

		if( dTemperature < m_dMinTemperature )
			dTemperature = m_dMinTemperature;
		if( dTemperature > m_dMaxTemperature )
			dTemperature = m_dMaxTemperature;

	}

	// make command of setting temperature into m_strSendCommand
	makeSerialTemperatureCommand( SEND_CMD_SET_TEMPERATURE, eHeaterIndex, &dTemperature );

	// Enter critical section
	EnterCriticalSection((RTL_CRITICAL_SECTION*)&m_csHeaterControl);
	// Clear Recv Queue
	m_plnkSerial->ClearRecvQueue();

	// Write command buffer to Serial Port( Actually to Serial Component Queue )
	m_plnkSerial->SendData(m_strSendCommand);

	/*
	strLogMsg.Format("SetHeaterTemperature(HeaterIndex=%d) : SendCommand(%s)", eHeaterIndex,_T(m_strSendCommand) );
	WriteNormalLog(strLogMsg);
	*/

	Sleep(30);

	// Wait until there is a response. If it's too long time out
	timerTimeOutCheck.StartTimer();
	while(1)
	{
//		iResult = m_plnkSerial->ReceiveData(chReceiveResponse);
//		iResult = m_plnkSerial->ReceiveData(&strReceiveResponse, 512);
		iResult = m_plnkSerial->ReceiveData(buffer, sizeof(buffer));
		if (iResult == SUCCESS)
			break;
			
		if( timerTimeOutCheck.MoreThan( m_dTimeoutSerialComm ) )
		{
			//strLogMsg.Format(_T("SetHeaterTemperature(HeaterIndex=%d) : Out Range Error"), eHeaterIndex );
			//WriteErrorLog(strLogMsg);
			strLogMsg.Format(_T("HEATERCONTROLLER set Heater Temperature(HeaterIndex=%d)."), eHeaterIndex);
			SetErrorLevel(strLogMsg,2, __FILE__, __LINE__);
			iResult = generateErrorCode(201001);// ERR_HEATER_CONTROLLER_SERIAL_COMM_TIMEOUT
			 
			timerTimeOutCheck.StopTimer();
		
			// Leave critical section
			LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_csHeaterControl);
			
			return iResult;	
			
		}
		Sleep(10);
//		if(chReceiveResponse != "") 
		if(strReceiveResponse != "")		
			break;
	}
	timerTimeOutCheck.StopTimer();
	// Leave critical section
	LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_csHeaterControl);

	strReceiveResponse.Format(_T("%s"), buffer);

//	USES_CONVERSION;
//	WCHAR* pszReveiveResponse = NULL;
//	pszReveiveResponse = A2W(chReceiveResponse);
//	strReceiveResponse.Format(_T("%s"),pszReveiveResponse);

	// Check error & Compare Setting Value with Reading Value
	if(strReceiveResponse.GetAt(5) == 0x30 && strReceiveResponse.GetAt(6) == 0x30)// Response OK(00)
	{
		GetSettingHeaterTemperature( eHeaterIndex, &dTemp );
		if( dTemperature != dTemp )
		{
			//WriteErrorLog("SetHeaterTemperature() : Mismatch Writing/Reading Value");
			SetErrorLevel(_T("HEATCONTROLLER set Heater Temperature"),2, __FILE__, __LINE__);
			return generateErrorCode(201002);	// ERR_HEATER_CONTROLLER_SET_GET_VALUE_MISMATCH
 		}
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x30) // parity error(10)
	{
		//WriteErrorLog("SetHeaterTemperature() : Parity Error");
		SetErrorLevel(_T("HEATCONTROLLER set Heater Temperature"),2, __FILE__, __LINE__);
		return generateErrorCode(201005);	// ERR_HEATER_CONTROLLER_PARITY_ERROR
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x31) // Framing error(11)
	{
		//WriteErrorLog("SetHeaterTemperature() : Framing Error");
		SetErrorLevel(_T("HEATCONTROLLER set Heater Temperature"),2, __FILE__, __LINE__);
		return generateErrorCode(201006);	// ERR_HEATER_CONTROLLER_FRAMING_ERROR
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x32) // Overrun error(12)
	{
		//WriteErrorLog("SetHeaterTemperature() : Overrun Error");
		SetErrorLevel(_T("HEATCONTROLLER set Heater Temperature"),2, __FILE__, __LINE__);
		return	generateErrorCode(201007);	// ERR_HEATER_CONTROLLER_OVERRUN_ERROR
	}
	else if(strReceiveResponse.GetAt(5) == 0x49 && strReceiveResponse.GetAt(6) == 0x43) // undefined error(IC*)
	{
		//WriteErrorLog("SetHeaterTemperature() : Undefined Error");
		SetErrorLevel(_T("HEATCONTROLLER set Heater Temperature"),2, __FILE__, __LINE__);
		return generateErrorCode(201008);	// ERR_HEATER_CONTROLLER_UNDEFINED_ERROR
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x34) // Format error(14)
	{
		//WriteErrorLog("SetHeaterTemperature() : Format Error");
		SetErrorLevel(_T("HEATCONTROLLER set Heater Temperature"),2, __FILE__, __LINE__);
		return generateErrorCode(201009);	// ERR_HEATER_CONTROLLER_FORMAT_ERROR
	}
	else if(strReceiveResponse.GetAt(5) == 0x30 && strReceiveResponse.GetAt(6) == 0x44) // Non-executable command(0D)
	{
		//WriteErrorLog("SetHeaterTemperature() : Non-Executable Command Error");
		SetErrorLevel(_T("HEATCONTROLLER set Heater Temperature"),2, __FILE__, __LINE__);
		return generateErrorCode(201010);	// ERR_HEATER_CONTROLLER_NONEXECUTABLE_COMMAND_ERROR
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x35) // Undefined data Value(15)
	{
		//WriteErrorLog("SetHeaterTemperature() : Undefined Data Error");
		SetErrorLevel(_T("HEATCONTROLLER set Heater Temperature"),2, __FILE__, __LINE__);
		return generateErrorCode(201011);	// ERR_HEATER_CONTROLLER_UNDEFINED_DATA_ERROR
	}
	else
	{
		//WriteErrorLog("SetHeaterTemperature() : Undefined Error Code");
		SetErrorLevel(_T("HEATCONTROLLER set Heater Temperature"),2, __FILE__, __LINE__);
		return generateErrorCode(201012);	// ERR_HEATER_CONTROLLER_UNKNOWN_ERROR_CODE
	}
	return ERR_HEATER_CONTROLLER_SUCCESS;	
}

/**
* Getting Temperature of the given indexed Heater
*
* @param	eHeaterIndex : heater index - 1,2,3 (1-Based)
* @param	dTemperature : temperature to get( Min/Max definded in DefHeaterController.h )
* @return	Error Code : 0 = SUCCESS, etc = Error
*/
int	MHeaterController::GetHeaterTemperature( EHeaterControllerID eHeaterIndex, double *pdTemperature )
{
	MTickTimer	timerTimeOutCheck;
	CString strReceiveResponse;
	int iResult;
	CString strLogMsg;
	char buffer[512];
	memset(buffer, 0, sizeof(buffer));

	// make command for getting temperature
	makeSerialTemperatureCommand(RECV_CMD_GET_TEMPERATURE, eHeaterIndex);

	// Enter critical section
	EnterCriticalSection((RTL_CRITICAL_SECTION*)&m_csHeaterControl);

	m_plnkSerial->ClearRecvQueue();

	// Write command buffer to Serial Port( Actually to Serial Component Queue )
	m_plnkSerial->SendData(m_strSendCommand);

	/*
	strLogMsg.Format("GetHeaterTemperature(HeaterIndex=%d) : SendCommand(%s)", eHeaterIndex, _T(m_strSendCommand) );
	WriteNormalLog(strLogMsg);
	*/

	strReceiveResponse = _T("");

	Sleep(30);
	// jdy sesl 090102	Sleep(50);

	// Wait until there is a response. If it's too long time out
	timerTimeOutCheck.StartTimer();
	while(1)
	{
//		iResult = m_plnkSerial->ReceiveData(&strReceiveResponse);
		iResult = m_plnkSerial->ReceiveData(buffer, sizeof(buffer));
		if (iResult == SUCCESS)
			break;
	
		if( timerTimeOutCheck.MoreThan( m_dTimeoutSerialComm ) )
		{
			//strLogMsg.Format(_T("GetHeaterTemperature() : Timeout(%f sec) Error"), m_dTimeoutSerialComm );
			//WriteErrorLog(strLogMsg);
			SetErrorLevel(_T("HEATCONTROLLER get Heater Temperature"),2, __FILE__, __LINE__);
			iResult = generateErrorCode(201001);	// ERR_HEATER_CONTROLLER_SERIAL_COMM_TIMEOUT

			// Leave critical section
			LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_csHeaterControl);
			return iResult;			
		}
		Sleep(10);
		if(strReceiveResponse != _T(""))
			break;
	}
	timerTimeOutCheck.StopTimer();

	// Leave critical section
	LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_csHeaterControl);

	strReceiveResponse.Format(_T("%s"), (CString)buffer);

	int iResponceLng = strReceiveResponse.GetLength();
	if( iResponceLng < 2)
	{
		//strLogMsg.Format(_T("GetHeaterTemperature() : Response Length (%d) Error"), iResponceLng );
		//WriteErrorLog(strLogMsg);
		SetErrorLevel(_T("HEATCONTROLLER get Heater Temperature"),2, __FILE__, __LINE__);
		return generateErrorCode(201003);	// ERR_HEATER_CONTROLLER_RECEIVE_DATA_NULL;
	}

	// Check error & constructing Reading Value into double temperature
	if(strReceiveResponse.GetAt(5) == 0x30 && strReceiveResponse.GetAt(6) == 0x30)	// Response OK
	{
		USES_CONVERSION;
		WCHAR pszAnsi1[100];
		char* chReceiveResponse;
		wcscpy(pszAnsi1, strReceiveResponse);
		chReceiveResponse = W2A(pszAnsi1);
		*pdTemperature = (double(chReceiveResponse[7]-48.0)*1000) + (double(chReceiveResponse[8]-48.0)*100) 
					 + (double(chReceiveResponse[9]-48.0)*10) + double(chReceiveResponse[10]-48.0);
//		*pdTemperature = (double(strReceiveResponse[7]-48.0)*1000) + (double(strReceiveResponse[8]-48.0)*100) 
//					 + (double(strReceiveResponse[9]-48.0)*10) + double(strReceiveResponse[10]-48.0);
		return ERR_HEATER_CONTROLLER_SUCCESS;
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x30) // parity error(10)
	{
		iResult = generateErrorCode(201005);	// ERR_HEATER_CONTROLLER_PARITY_ERROR
		//WriteErrorLog("GetHeaterTemperature() : Parity Error");
		SetErrorLevel(_T("HEATCONTROLLER get Heater Temperature"),2, __FILE__, __LINE__);
		return iResult;
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x31) // Framing error(11)
	{
		iResult = generateErrorCode(201006);	// ERR_HEATER_CONTROLLER_FRAMING_ERROR
		//WriteErrorLog("GetHeaterTemperature() : Framing Error");
		SetErrorLevel(_T("HEATCONTROLLER get Heater Temperature"),2, __FILE__, __LINE__);
		return iResult;
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x32) // Overrun error(12)
	{
		iResult = generateErrorCode(201007);	// ERR_HEATER_CONTROLLER_OVERRUN_ERROR
		//WriteErrorLog("GetHeaterTemperature() : Overrun Error");
		SetErrorLevel(_T("HEATCONTROLLER get Heater Temperature"),2, __FILE__, __LINE__);
		return iResult;
	}
	else if(strReceiveResponse.GetAt(5) == 0x49 && strReceiveResponse.GetAt(6) == 0x43) // undefined error(IC*)
	{
		iResult = generateErrorCode(201008);	// ERR_HEATER_CONTROLLER_UNDEFINED_ERROR
		//WriteErrorLog("GetHeaterTemperature() : Undefined Error");
		SetErrorLevel(_T("HEATCONTROLLER get Heater Temperature"),2, __FILE__, __LINE__);
		return iResult;
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x34) // Format error(14)
	{
		iResult = generateErrorCode(201009);	// ERR_HEATER_CONTROLLER_FORMAT_ERROR
		//WriteErrorLog("GetHeaterTemperature() : Format Error");
		SetErrorLevel(_T("HEATCONTROLLER get Heater Temperature"),2, __FILE__, __LINE__);
		return iResult;
	}
	else if(strReceiveResponse.GetAt(5) == 0x30 && strReceiveResponse.GetAt(6) == 0x44) // Non-executable command(0D)
	{
		iResult = generateErrorCode(201010);	// ERR_HEATER_CONTROLLER_NONEXECUTABLE_COMMAND_ERROR
		//WriteErrorLog("GetHeaterTemperature() : Non-Executable Command Error");
		SetErrorLevel(_T("HEATCONTROLLER get Heater Temperature"),2, __FILE__, __LINE__);
		return iResult;
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x35) // Undefined data Value(15)
	{
		iResult = generateErrorCode(201011);	// ERR_HEATER_CONTROLLER_UNDEFINED_DATA_ERROR
		//WriteErrorLog("GetHeaterTemperature() : Undefined Data Error");
		SetErrorLevel(_T("HEATCONTROLLER get Heater Temperature"),2, __FILE__, __LINE__);
		return iResult;
	}
	else
	{
		//WriteErrorLog("GetHeaterTemperature() : Undefined Error Code");
		SetErrorLevel(_T("HEATCONTROLLER get Heater Temperature"),2, __FILE__, __LINE__);
		return generateErrorCode(201012);	// ERR_HEATER_CONTROLLER_UNKNOWN_ERROR_CODE
	}
	return ERR_HEATER_CONTROLLER_SUCCESS;
}


/**
* Getting Setting Temperature of the given indexed Heater
*
* @param	eHeaterIndex : heater index - 1,2,3 (1-Based)
* @param	dTemperature : temperature to get( Min/Max definded in DefHeaterController.h )
* @return	Error Code : 0 = SUCCESS, etc = Error
*/
int	MHeaterController::GetSettingHeaterTemperature( EHeaterControllerID eHeaterIndex, double *pdTemperature )
{
	MTickTimer	timerTimeOutCheck;
	CString strReceiveResponse;
	// ML_hongju 수정..
//	char* chReceiveResponse;
	int iResult;
	CString strLogMsg;
	char buffer[512];
	memset(buffer, 0, sizeof(buffer));

	// make command for getting temperature
	makeSerialTemperatureCommand(RECV_CMD_SET_TEMPERATURE, eHeaterIndex);

	// Enter critical section
	EnterCriticalSection((RTL_CRITICAL_SECTION*)&m_csHeaterControl);

	m_plnkSerial->ClearRecvQueue();

	// Write command buffer to Serial Port( Actually to Serial Component Queue )
	m_plnkSerial->SendData(m_strSendCommand);

	/*
	strLogMsg.Format("GetHeaterTemperature(HeaterIndex=%d) : SendCommand(%s)", eHeaterIndex, _T(m_strSendCommand) );
	WriteNormalLog(strLogMsg);
	*/

	strReceiveResponse = "";
	// ML_hongju 수정..
//	chReceiveResponse = "";

	Sleep(30);

	// Wait until there is a response. If it's too long time out
	timerTimeOutCheck.StartTimer();
	while(1)
	{
//		iResult = m_plnkSerial->ReceiveData(chReceiveResponse);
//		iResult = m_plnkSerial->ReceiveData(&strReceiveResponse);
		iResult = m_plnkSerial->ReceiveData(buffer, sizeof(buffer));
		if (iResult == SUCCESS)
			break;

		if( timerTimeOutCheck.MoreThan( m_dTimeoutSerialComm ) )
		{
			SetErrorLevel(_T("HEATCONTROLLER get Setting Heater Temperature"),2, __FILE__, __LINE__);
			iResult = generateErrorCode(201001);	// ERR_HEATER_CONTROLLER_SERIAL_COMM_TIMEOUT

			//strLogMsg.Format(_T("GetHeaterTemperature() : Timeout(%f sec) Error"), m_dTimeoutSerialComm );
			//WriteErrorLog(strLogMsg);

			// Leave critical section
			LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_csHeaterControl);
			return iResult;			
		}
		Sleep(10);
		if(strReceiveResponse != "")
//		if(chReceiveResponse != "")
			break;
	}
	timerTimeOutCheck.StopTimer();

	/*
	strLogMsg.Format("GetSettingHeaterTemperature(HeaterIndex=%d) : SendCommand() Resoponse=%s", eHeaterIndex, _T(strReceiveResponse) );
	WriteNormalLog(strLogMsg);
	*/
	strReceiveResponse.Format(_T("%s"), buffer);
	
	// Leave critical section
	LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_csHeaterControl);
	

//	USES_CONVERSION;
//	WCHAR* pszReveiveResponse = NULL;
//	pszReveiveResponse = A2W(chReceiveResponse);
//	strReceiveResponse.Format(_T("%s"),pszReveiveResponse);

	// Check error & constructing Reading Value into double temperature
	if(strReceiveResponse.GetAt(5) == 0x30 && strReceiveResponse.GetAt(6) == 0x30)	// Response OK
	{
		*pdTemperature = ((double(strReceiveResponse[7])-48.0)*1000) + ((double(strReceiveResponse[8])-48.0)*100) 
					 + ((double(strReceiveResponse[9])-48.0)*10) + (double(strReceiveResponse[10])-48.0);
		return ERR_HEATER_CONTROLLER_SUCCESS;
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x30) // parity error(10)
	{
		SetErrorLevel(_T("HEATCONTROLLER get Setting Heater Temperature"),2, __FILE__, __LINE__);
		iResult = generateErrorCode(201005);	// ERR_HEATER_CONTROLLER_PARITY_ERROR
		//WriteErrorLog("SetHeaterTemperature() : Parity Error");
		return iResult;
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x31) // Framing error(11)
	{
		SetErrorLevel(_T("HEATCONTROLLER get Setting Heater Temperature"),2, __FILE__, __LINE__);
		iResult = generateErrorCode(201006);	// ERR_HEATER_CONTROLLER_FRAMING_ERROR
		//WriteErrorLog("SetHeaterTemperature() : Framing Error");
		return iResult;
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x32) // Overrun error(12)
	{
		SetErrorLevel(_T("HEATCONTROLLER get Setting Heater Temperature"),2, __FILE__, __LINE__);
		iResult = generateErrorCode(201007);	// ERR_HEATER_CONTROLLER_OVERRUN_ERROR
		//WriteErrorLog("SetHeaterTemperature() : Overrun Error");
		return iResult;
	}
	else if(strReceiveResponse.GetAt(5) == 0x49 && strReceiveResponse.GetAt(6) == 0x43) // undefined error(IC*)
	{
		SetErrorLevel(_T("HEATCONTROLLER get Setting Heater Temperature"),2, __FILE__, __LINE__);
		iResult = generateErrorCode(201008);	// ERR_HEATER_CONTROLLER_UNDEFINED_ERROR
		//WriteErrorLog("SetHeaterTemperature() : Undefined Error");
		return iResult;
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x34) // Format error(14)
	{
		SetErrorLevel(_T("HEATCONTROLLER get Setting Heater Temperature"),2, __FILE__, __LINE__);
		iResult = generateErrorCode(201009);	// ERR_HEATER_CONTROLLER_FORMAT_ERROR
		//WriteErrorLog("SetHeaterTemperature() : Format Error");
		return iResult;
	}
	else if(strReceiveResponse.GetAt(5) == 0x30 && strReceiveResponse.GetAt(6) == 0x44) // Non-executable command(0D)
	{
		SetErrorLevel(_T("HEATCONTROLLER get Setting Heater Temperature"),2, __FILE__, __LINE__);
		iResult = generateErrorCode(201010);	// ERR_HEATER_CONTROLLER_NONEXECUTABLE_COMMAND_ERROR
		//WriteErrorLog("SetHeaterTemperature() : Non-Executable Command Error");
		return iResult;
	}
	else if(strReceiveResponse.GetAt(5) == 0x31 && strReceiveResponse.GetAt(6) == 0x35) // Undefined data Value(15)
	{
		SetErrorLevel(_T("HEATCONTROLLER get Setting Heater Temperature"),2, __FILE__, __LINE__);
		iResult = generateErrorCode(201011);	// ERR_HEATER_CONTROLLER_UNDEFINED_DATA_ERROR
		//WriteErrorLog("SetHeaterTemperature() : Undefined Data Error");
		return iResult;
	}
	return ERR_HEATER_CONTROLLER_SUCCESS;
}

/**
* Setting Temperature of all Heaters
*
* @param	iNumHeaters : array size
* @param	eHeaterIndex : Heater indexes
* @param	rgdTemperature : temperature array to be set( Min/Max definded in DefHeaterController.h )
* @return	Error Code : 0 = SUCCESS, etc = Error
*/
int	MHeaterController::SetHeaterTemperature(	int iNumHeaters, 
												EHeaterControllerID *eHeaterIndex, 
												double *rgdTemperature )
{
	int iError;
	int iErrorCode;
	CString strLogMsg;

	// check argument null pointer
	if( eHeaterIndex == NULL || rgdTemperature == NULL )
	{
		SetErrorLevel(_T("HEATCONTROLLER set All Heater Temperature"),2, __FILE__, __LINE__);
		iErrorCode = generateErrorCode(201004);	// ERR_HEATER_CONTROLLER_ARGUMENT_NULL_POINTER
		//WriteErrorLog("SetHeaterTemperature(All Heaters) : Null Argument Pointer" );
		return iErrorCode;
	}

	for( int i = 0 ; i < iNumHeaters; i++ )
	{
		iError = SetHeaterTemperature( eHeaterIndex[i], rgdTemperature[i] );
		if( iError )
			return iError;
	}

	return ERR_HEATER_CONTROLLER_SUCCESS;
}

/**
* Getting Temperature of all Heaters
*
* @param	eHeaterIndex : heater index - 1,2,3 (1-Based)
* @param	dTemperature : temperature array to get( Min/Max definded in DefHeaterController.h )
* @return	Error Code : 0 = SUCCESS, etc = Error
*/
int	MHeaterController::GetHeaterTemperature( double *dTemperature, int *iNumHeaters )
{
	int iError;
	int iErrorCode;
	CString strLogMsg;

	if( dTemperature == NULL )
	{
		SetErrorLevel(_T("HEATCONTROLLER get All Heater Temperature"),2, __FILE__, __LINE__);
		iErrorCode = generateErrorCode(201004);	// ERR_HEATER_CONTROLLER_ARGUMENT_NULL_POINTER
		//WriteErrorLog("SetHeaterTemperature(All Heaters) : Null Argument Pointer" );
		return iErrorCode;
	}

	// set number of heaters
	*iNumHeaters = m_iNumHeaters;

	for( int i = 0; i < m_iNumHeaters; i++ )
	{
		iError = GetHeaterTemperature( EHeaterControllerID(i + 1), (dTemperature+i) );
		if( iError )
			return iError;
	}

	return ERR_HEATER_CONTROLLER_SUCCESS;
}

/**
* Getting Setting Temperature of all Heaters
*
* @param	eHeaterIndex : heater index - 1,2,3 (1-Based)
* @param	dTemperature : temperature array to get( Min/Max definded in DefHeaterController.h )
* @return	Error Code : 0 = SUCCESS, etc = Error
*/
int	MHeaterController::GetSettingHeaterTemperature( double *dTemperature, int *iNumHeaters )
{
	int iError;
	int iErrorCode;
	CString strLogMsg;

	// check argument null pointer
	if( dTemperature == NULL )
	{
		SetErrorLevel(_T("HEATCONTROLLER get All Setting Heater Temperature"),2, __FILE__, __LINE__);
		iErrorCode = generateErrorCode(201004);	// ERR_HEATER_CONTROLLER_ARGUMENT_NULL_POINTER

		//WriteErrorLog("GetSettingHeaterTemperature(All Heaters) : Null Argument Pointer" );
		return iErrorCode;
	}

	*iNumHeaters = m_iNumHeaters;

	for( int i = 0; i < m_iNumHeaters; i++ )
	{
		iError = GetSettingHeaterTemperature( EHeaterControllerID(i + 1), (dTemperature+i) );
		if( iError )
			return iError;
	}

	return ERR_HEATER_CONTROLLER_SUCCESS;
}

/**
* Added on 2004.11.29
* Check Heater Alarms
*
* @param	alarm io index : return value of the alarm i/o 
* @return	boolean value : TRUE - Alarm State, FALSE - no alarm state 
*/
BOOL MHeaterController::IsHeaterInAlarmState(int *iAlarmIndex)
{
	BOOL	rgbState[DEF_MAX_NUM_HEATER];
	BOOL	bOverHeater[DEF_MAX_NUM_OVERHEAT_ALARM];
	BOOL	bDisconnectHeater[DEF_MAX_NUM_CONNECT_ALARM];
	int		iNumHeaters;
	CString	strLogMsg;

	int i;
	// initialize state : B type ( Normal On )
	for( i = 0; i < m_iNumHeaters; i++ ) // 28개
		rgbState[i] = TRUE;

	// 
	for( i = 0; i < m_iNumOfOverHeaterAlarm; i++ ) //1개
		bOverHeater[i] = TRUE;

	// initialize state : A type ( Normal Off )
	for( i = 0; i < m_iNumOfDisconnectHeaterAlarm; i++ ) // 3개
		bDisconnectHeater[i] = FALSE;

	CheckHeaterAlarms( rgbState, &iNumHeaters );

	for( i = 0; i < m_iNumHeaters; i++ )
	{
		if( rgbState[i] == FALSE )
		{
			//strLogMsg.Format(_T("IsHeaterInAlarmState() : Heater Index(1-Based) = %d, State=%d"), i+1, rgbState[i]);
			//WriteErrorLog(strLogMsg);
			//SetErrorLevel(_T("HEATCONTROLLER State : Heater Alarm"),2, __FILE__, __LINE__);

			//2009.04.18 SESL_HJH
			//*iAlarmIndex = i + 1;
			*iAlarmIndex = i + 400050;

			return TRUE;
		}
	}

	// overheater check
	for( i = 0; i < m_iNumOfOverHeaterAlarm; i++ )
	{
		bOverHeater[i]=  m_plnkIO->IsOn(m_usAddrOverHeatAlarm[i]);
	}

	for( i = 0; i < m_iNumOfOverHeaterAlarm; i++ )
	{
		if( bOverHeater[i] == TRUE )
		{
			//strLogMsg.Format(_T("IsHeaterInAlarmState() : Heater Index(1-Based) = %d, State=%d"), DEF_MAX_NUM_OVERHEAT_ALARM+ i+1, bOverHeater[i]);
			//WriteErrorLog(strLogMsg);
			//SetErrorLevel(_T("HEATCONTROLLER State : Heater Alarm"),2, __FILE__, __LINE__);

			//2009.04.18 SESL_HJH
			//400080 = 1번 OverHeat 감지 센서 Alarm이 감지 되었습니다.
			//*iAlarmIndex = i + 1 + DEF_MAX_NUM_OVERHEAT_ALARM;
			*iAlarmIndex = i + 400080;

			return TRUE;
		}
	}

	// Heater Disconnect check
	for( i = 0; i < m_iNumOfDisconnectHeaterAlarm; i++ )
	{
		bDisconnectHeater[i]=  m_plnkIO->IsOn(m_usAddrDisconnectHeatAlarm[i]);
	}

	for( i = 0; i < m_iNumOfDisconnectHeaterAlarm; i++ )
	{
		if( bDisconnectHeater[i] == TRUE )
		{
			//strLogMsg.Format(_T("IsHeaterInAlarmState() : Heater Index(1-Based) = %d, State=%d"), DEF_MAX_NUM_CONNECT_ALARM+ i+1, bDisconnectHeater[i]);
			//WriteErrorLog(strLogMsg);
			//SetErrorLevel(_T("HEATCONTROLLER State : Heater Alarm"),2, __FILE__, __LINE__);
			
			//2009.04.18 SESL_HJH
			//400090 = Tool Left측 단선 Alarm이 감지 되었습니다.
			//*iAlarmIndex = i + 1 + DEF_MAX_NUM_CONNECT_ALARM;
#ifdef DEF_GATE_SYSTEM
			*iAlarmIndex = i + 400090;
#else
			*iAlarmIndex = i + 400100;
#endif

			return TRUE;
		}
	}

	return FALSE;
}


/**
* Check Heater Alarms of the given indexed Heater
*
* @param	eHeaterIndex : heater index - 1,2,3 (1-Based)
* @param	HeaterAlarm : FALSE = No Alram, TURE = Alarm
* @return	Error : 0 - Success, etc. = error
*/
int	MHeaterController::CheckHeaterAlarms( EHeaterControllerID eHeaterIndex, BOOL *pbStates )
{
	int iIndex;
	/** IO Object가 할당되지 않음 */
	ASSERT(m_plnkIO != NULL);
	iIndex = eHeaterIndex - 1;

	*pbStates = m_plnkIO->IsOn(m_usAddrHeaterAlarm[iIndex]);

	return ERR_HEATER_CONTROLLER_SUCCESS;
}

/**
* Check Heater Alarms of All Heaters
*
* @param	HeaterAlarm Array: FALSE = No Alram, TURE = Alarm - Array별
* @return	Error : 0 - Success, etc. = error
*/
int	MHeaterController::CheckHeaterAlarms( BOOL *rgbStates, int *iNumHeaters )
{
	int iError;

	*iNumHeaters = m_iNumHeaters;

	for( int i = 0 ; i < m_iNumHeaters ; i++ )
	{
		iError = CheckHeaterAlarms(EHeaterControllerID(i+1), &rgbStates[i] );
		if( iError )
			return iError;
	}

	return ERR_HEATER_CONTROLLER_SUCCESS;
}

/***************** Common Implementation *************************************/

/**
* Assign component linkage
* 
* @param	listRefComponents	: Drawer 참조 Component list
*/
int MHeaterController::AssignComponents(SHeaterControllerRefCompList listRefComponents)
{
	m_plnkIO	 = listRefComponents.m_plnkIO;
	m_plnkSerial = listRefComponents.m_plnkSerial;

	return ERR_HEATER_CONTROLLER_SUCCESS;
}

/** 
* Component Data 처리 
*
* @param	pData : SAcfCarrierData 구조체에 대한 포인터
* @return	Error : 0 = Success, 그외=기타
*/
int MHeaterController::SetData(SHeaterControllerData datComponent)
{

	ASSERT(datComponent.m_iNumHeater >= 0 && datComponent.m_iNumHeater <= DEF_MAX_NUM_HEATER);
	ASSERT(datComponent.m_iNumOfOverHeaterAlarm >= 0	&& datComponent.m_iNumOfOverHeaterAlarm <= DEF_MAX_NUM_OVERHEAT_ALARM);
	ASSERT(datComponent.m_iNumOfDisconnectHeaterAlarm >= 0	&& datComponent.m_iNumOfDisconnectHeaterAlarm <= DEF_MAX_NUM_CONNECT_ALARM);

	// Number of Heaters
	m_iNumHeaters			= datComponent.m_iNumHeater;

	m_iNumOfOverHeaterAlarm	= datComponent.m_iNumOfOverHeaterAlarm;

	m_iNumOfDisconnectHeaterAlarm = datComponent.m_iNumOfDisconnectHeaterAlarm;

	m_dMaxTemperature		= datComponent.m_dMaxTemperature;

	m_dMinTemperature		= datComponent.m_dMinTemperature;

	int i;
	// set range
	for( i = 0; i < m_iNumHeaters; i++ )
		m_usAddrHeaterAlarm[i]		= datComponent.m_usAddrHeaterAlarm[i];

	// over heater alarm
	for( i = 0; i < m_iNumOfOverHeaterAlarm; i++ )
		m_usAddrOverHeatAlarm[i]	= datComponent.m_usAddrOverHeatAlarm[i];

	// Heat Disconnect Alarm
	for( i = 0; i < m_iNumOfDisconnectHeaterAlarm ; i++)
		m_usAddrDisconnectHeatAlarm[i]	= datComponent.m_usAddrDisconnectHeatAlarm[i];

	m_dTimeoutSerialComm			= datComponent.m_dTimeoutSerialComm;	// unit - sec

	return ERR_HEATER_CONTROLLER_SUCCESS;
}

/** 
* Component Data 처리 
*
* @param	pData : SHeaterControllerData 구조체에 대한 포인터
* @return	Error : 0 = Success, 그외=기타
*/
int MHeaterController::GetData(SHeaterControllerData *pData)
{
	CString	strLogMsg;
	int		iErrorCode;

	if( pData == NULL )
	{
		SetErrorLevel(_T("HEATCONTROLLER get Component Data"),2, __FILE__, __LINE__);
		iErrorCode = generateErrorCode(201004);	// ERR_HEATER_CONTROLLER_ARGUMENT_NULL_POINTER
		//WriteErrorLog("Get Data Error : pData is Null");
		return iErrorCode;
	}

	// Number of Heaters
	pData->m_iNumHeater				= m_iNumHeaters;
	pData->m_iNumOfOverHeaterAlarm	= m_iNumOfOverHeaterAlarm;
	pData->m_iNumOfDisconnectHeaterAlarm = m_iNumOfDisconnectHeaterAlarm;
	pData->m_dMaxTemperature		= m_dMaxTemperature;
	pData->m_dMinTemperature		= m_dMinTemperature;

	int i;
	for( i = 0; i < m_iNumHeaters; i++ )
		pData->m_usAddrHeaterAlarm[i]	= m_usAddrHeaterAlarm[i];

	// over heater alarm
	for( i = 0; i < m_iNumOfOverHeaterAlarm; i++ )
		pData->m_usAddrOverHeatAlarm[i] = m_usAddrOverHeatAlarm[i];
	// Heat Disconnect Alarm
	for( i = 0; i < m_iNumOfDisconnectHeaterAlarm ; i++)
		pData->m_usAddrDisconnectHeatAlarm[i]	= m_usAddrDisconnectHeatAlarm[i];

	pData->m_dTimeoutSerialComm		= m_dTimeoutSerialComm;	// unit - sec

	return ERR_HEATER_CONTROLLER_SUCCESS;
}



/*----------------------- Private Operations ----------------------------------------------*/
void MHeaterController::makeSerialTemperatureCommand( ETemperatureControlCommand cmdTemperature, 
													  EHeaterControllerID eHeaterIndex, 
													  void *pData )
{
	double	*pdTemperature;
	BYTE	ucTemperature[4] = {0, };
	int		iSum=0, iLength=0, iTemp=0, i=0;

	memset( m_strSendCommand, 0, sizeof(m_strSendCommand) );
	switch( cmdTemperature )
	{
	//==========================================
	case SEND_CMD_SET_TEMPERATURE:
		pdTemperature = (double *)pData;
		
		// convert temperature from double format to BYTE order format
#ifndef USE_E5CC_TEMP_CONTROL
		ucTemperature[3] = BYTE(*pdTemperature/1000);
		iTemp = int(*pdTemperature) % 1000;

		ucTemperature[2] = BYTE(iTemp/100);
		iTemp = int(*pdTemperature) % 100;
		
		ucTemperature[1] = BYTE(iTemp/10);
		iTemp = int(*pdTemperature) % 10;

		ucTemperature[0] = BYTE(iTemp);

		// make command buffer to send to temperature controller
		memset(m_strSendCommand, 0, sizeof(m_strSendCommand) );
		sprintf( m_strSendCommand, "@%02dWS01%X%X%X%X", 
			eHeaterIndex, ucTemperature[3], ucTemperature[2], ucTemperature[1], ucTemperature[0] );
#else
		{
			char   *ptr;
			long lValue=0;
			int length;
			char sHex[256];
			char strTemp[256];
			memset(sHex, 0, sizeof(sHex));
			memset(strTemp, 0, sizeof(strTemp));
			sprintf(strTemp, "%1.f", *pdTemperature);
			lValue = strtol(strTemp, &ptr, 10);
			sprintf(sHex, "%X", lValue);
			length = strlen(sHex);

			char tmp[256];
			memset(tmp, 0, sizeof(tmp));
			for(i=0; i<4; i++)
			{
				if(i<length)
				{
					strcat(tmp, "0");
				}
				else
				{
					strcat(tmp, sHex);
					break;
				}
			}	
			sprintf(m_strSendCommand, "%c%02X0000102C100030000010000%s%c", 0x02, eHeaterIndex ,tmp,0x03);
		}
#endif
		iLength = strlen(m_strSendCommand);
		iSum=0;

#ifndef USE_E5CC_TEMP_CONTROL
		for( i = 0; i < iLength ; i++) 
			iSum^=m_strSendCommand[i];	//exclusive OR		
		sprintf(m_strSendCommand+iLength, "%02X%c%c",iSum & 0xFF, 0x2A, 0x0D);
#else
		for( i = iLength; i > 0; i--) 
			iSum^=m_strSendCommand[i];
		sprintf(m_strSendCommand+iLength, "%c", iSum);
#endif
		break;

	//==========================================
	case RECV_CMD_GET_TEMPERATURE:
#ifndef USE_E5CC_TEMP_CONTROL
		sprintf(m_strSendCommand, "@%02dRX01", eHeaterIndex );
#else
		sprintf(m_strSendCommand, "%c%02X0000101C00000000001%c", 0x02, eHeaterIndex, 0x03 );
#endif
		
		iLength = strlen(m_strSendCommand);
		iSum=0;

#ifndef USE_E5CC_TEMP_CONTROL
		for( i = 0; i < iLength ; i++) 
			iSum^=m_strSendCommand[i];			
		sprintf(m_strSendCommand+iLength, "%02X%c%c",iSum & 0xFF, 0x2A, 0x0D);
#else
		for( i = iLength; i > 0; i--) 
			iSum^=m_strSendCommand[i];
		sprintf(m_strSendCommand+iLength, "%c", iSum);
#endif
		break;

	//==========================================
	case RECV_CMD_SET_TEMPERATURE:
#ifndef USE_E5CC_TEMP_CONTROL
		sprintf(m_strSendCommand, "@%02dRS01", eHeaterIndex );
#else
		sprintf(m_strSendCommand, "%c%02X0000101C00002000001%c", 0x02, eHeaterIndex, 0x03);
#endif
		iLength = strlen(m_strSendCommand);
		iSum=0;
#ifndef USE_E5CC_TEMP_CONTROL
		for( i = 0; i < iLength ; i++) 
			iSum^=m_strSendCommand[i];	
		sprintf(m_strSendCommand+iLength, "%02X%c%c",iSum & 0xFF, 0x2A, 0x0D);
#else
		for( i = iLength; i > 0; i--) 
			iSum^=m_strSendCommand[i];
		sprintf(m_strSendCommand+iLength, "%c", iSum);
#endif
		break;
	default:
		break;
	}
}

// End Of Code
