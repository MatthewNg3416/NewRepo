/* Generated by Together */

#include "stdafx.h"
#include "IIO.h"
#include "MVacuum.h"
#include "MTickTimer.h"

#include "common.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/** Default 생성자 */
MVacuum::MVacuum()
{
	/** Referenced Component 초기화 */
	m_gpIIO = NULL;
	
	/** Data 초기화 */
	for (int i = 0; i < DEF_MAX_VACUUM_SOLENOID; i++)
	{
		m_rgusSolenoid[i] = 0;
		m_rgusSensor[i] = 0;
	}

	m_eVacuumType = UNKOWN_VACUUM;
	m_strFileName = "";

#ifdef SIMULATION
	m_bSimulOnState = FALSE;
	m_bVacuumOnBeingOnState = FALSE;
	m_bVacuumOnBeingOffState = FALSE;
	m_tmSimulTimer.StopTimer();

	InitializeCriticalSection(&m_csSimul);
#endif
}

/** 
 * Constructor
 * 
 * @param	commonData : 공통적으로 사용할 Data
 * @param	pIIO : 참조할 I/O Component 포인터
 * @param	datComponent : 자체적으로 사용할 Data
 */
MVacuum::MVacuum(SCommonAttribute commonData, IIO *pIIO, SVacuumData datComponent)
: ICommon(commonData)
{
	CString	strLogMsg;

	m_gpIIO = pIIO;
	SetData(datComponent);

#ifdef SIMULATION
	m_bSimulOnState = FALSE;
	m_bVacuumOnBeingOnState = FALSE;
	m_bVacuumOnBeingOffState = FALSE;
	m_tmSimulTimer.StopTimer();

	InitializeCriticalSection(&m_csSimul);
#endif

	strLogMsg.Format(_T("MVacuum() : ObjectID=%d OK"), GetObjectID());
	WriteLog(DEF_MLOG_NORMAL_LOG_LEVEL, strLogMsg, __FILE__, __LINE__);
}

/** 소멸자 */
MVacuum::~MVacuum()
{
#ifdef SIMULATION
	DeleteCriticalSection(&m_csSimul);
#endif

	TRACE(_T("MVacuum Class Destruction is Completed.\n"));
}

int MVacuum::GetVacuumTime(double & dTurningTime, double & dOnSettlingTime, double & dOffSettlingTime)
{
    dTurningTime		= m_VacParameter.m_dTurningTime;
    dOnSettlingTime		= m_VacParameter.m_dOnSettlingTime;
    dOffSettlingTime	= m_VacParameter.m_dOffSettlingTime;
    return ERR_VACUUM_SUCCESS;
}

int MVacuum::GetVacuumTime(EVacuumTime eVacuumTime, double & dVacuumTime)
{
    switch (eVacuumTime)
    {
    case TURNING_TIME:
		dVacuumTime = m_VacParameter.m_dTurningTime;
        break;
    case ON_SETTLING_TIME:
        dVacuumTime = m_VacParameter.m_dOnSettlingTime;
        break;
    case OFF_SETTLING_TIME:
        dVacuumTime = m_VacParameter.m_dOffSettlingTime;
        break;
    default:
        break;
    }
    return ERR_VACUUM_SUCCESS;
}

int MVacuum::CompareIO()
{
#ifdef SIMULATION
	return ERR_VACUUM_SUCCESS;
#endif

	BOOL	bVal1, bVal2, bVal3, bVal4, bVal5, bVal6;

    switch (m_eVacuumType)
    {
    case SINGLE_VACUUM:
	case SINGLE_VACUUM_W_I_BLOW:
		bVal1 = m_gpIIO->IsOn(m_rgusSensor[0]);
		bVal2 = m_gpIIO->IsOff(m_rgusSolenoid[0]);

		if ((bVal1 && bVal2) || (!bVal1 && !bVal2))
			return generateErrorCode(102000);
		break;

	case SINGLE_VACUUM_W_D_BLOW:
		bVal1 = m_gpIIO->IsOn(m_rgusSensor[0]);
		bVal2 = m_gpIIO->IsOn(m_rgusSolenoid[0]);
		bVal3 = m_gpIIO->IsOn(m_rgusSolenoid[1]);
		
		if ((!bVal2 && bVal1) || (bVal2 && ((bVal3 && bVal1) || (!bVal3 && !bVal1))))
			return generateErrorCode(102000);
		break;
    
    case REVERSE_SINGLE_VACUUM:
		bVal1 = m_gpIIO->IsOn(m_rgusSensor[0]);
		bVal2 = m_gpIIO->IsOn(m_rgusSolenoid[0]);

		if ((bVal1 && bVal2) ||	(!bVal1 && !bVal2))
			return generateErrorCode(102000); 
		break;
	
    case DOUBLE_VACUUM:
	case DOUBLE_VACUUM_W_I_BLOW:
 		bVal1 = m_gpIIO->IsOn(m_rgusSensor[0]);
		bVal2 = m_gpIIO->IsOff(m_rgusSolenoid[0]);
		bVal3 = m_gpIIO->IsOn(m_rgusSensor[1]);
		bVal4 = m_gpIIO->IsOff(m_rgusSolenoid[1]);

		if ((bVal1 && bVal2) || (!bVal1 && !bVal2) || (bVal3 && bVal4) || (!bVal3 && !bVal4))
			return generateErrorCode(102000);
		break;

	case DOUBLE_VACUUM_W_D_BLOW:
		bVal1 = m_gpIIO->IsOn(m_rgusSensor[0]);
		bVal2 = m_gpIIO->IsOn(m_rgusSolenoid[0]);
		bVal3 = m_gpIIO->IsOn(m_rgusSolenoid[2]);
		bVal4 = m_gpIIO->IsOn(m_rgusSensor[1]);
		bVal5 = m_gpIIO->IsOn(m_rgusSolenoid[1]);
		bVal6 = m_gpIIO->IsOn(m_rgusSolenoid[3]);
		
		if ((!bVal2 && bVal1) || (bVal2 && ((bVal3 && bVal1) || (!bVal3 && !bVal1)))
			|| (!bVal5 && bVal4) || (bVal5 && ((bVal6 && bVal4) || (!bVal6 && !bVal4))))
			return generateErrorCode(102000);
		break;
		 
    case HETERO_DOUBLE_VACUUM:
		bVal1 = m_gpIIO->IsOn(m_rgusSensor[0]);
		bVal2 = m_gpIIO->IsOn(m_rgusSolenoid[0]);
		bVal3 = m_gpIIO->IsOn(m_rgusSensor[1]);
		bVal4 = m_gpIIO->IsOff(m_rgusSolenoid[1]);

		if ((bVal1 && bVal2) || (!bVal1 && !bVal2) || (bVal3 && bVal4) || (!bVal3 && !bVal4))
			return generateErrorCode(102000);
		break;

    case REVERSE_DOUBLE_VACUUM:
 		bVal1 = m_gpIIO->IsOn(m_rgusSensor[0]);
		bVal2 = m_gpIIO->IsOn(m_rgusSolenoid[0]);
		bVal3 = m_gpIIO->IsOn(m_rgusSensor[1]);
		bVal4 = m_gpIIO->IsOn(m_rgusSolenoid[1]);

		if ((bVal1 && bVal2) || (!bVal1 && !bVal2) || (bVal3 && bVal4) || (!bVal3 && !bVal4))
			return generateErrorCode(102000);
		break;
      
    default:
        break;
    }

	return ERR_VACUUM_SUCCESS;
}

BOOL MVacuum::IsOn()
{
#ifdef SIMULATION
	BOOL bReturn = FALSE;
	
	EnterCriticalSection(&m_csSimul);
	
	if (TRUE == m_bSimulOnState)
	{
		m_bVacuumOnBeingOnState = FALSE;
		m_bVacuumOnBeingOffState = FALSE;
		bReturn = TRUE;
	}
	
	if (TRUE == m_bVacuumOnBeingOnState)
	{
		ASSERT(m_VacParameter.m_dSimulationTime > 0.0);
		if (m_tmSimulTimer.MoreThan(m_VacParameter.m_dSimulationTime))
		{
			m_bSimulOnState = TRUE;
			m_bVacuumOnBeingOnState = FALSE;
			m_tmSimulTimer.StopTimer();
			bReturn = TRUE;
		}
	}
	
	LeaveCriticalSection(&m_csSimul);
	return bReturn;
#endif
	
	BOOL bVal1, bVal2;

    switch (m_eVacuumType)
    {
    case SINGLE_VACUUM:
	case SINGLE_VACUUM_W_D_BLOW:
	case SINGLE_VACUUM_W_I_BLOW:
    case REVERSE_SINGLE_VACUUM:
		return m_gpIIO->IsOn(m_rgusSensor[0]);
    
	case DOUBLE_VACUUM_W_D_BLOW:
	case DOUBLE_VACUUM_W_I_BLOW:
	case DOUBLE_VACUUM:
    case HETERO_DOUBLE_VACUUM:
    case REVERSE_DOUBLE_VACUUM:
		bVal1 = m_gpIIO->IsOn(m_rgusSensor[0]);
		bVal2 = m_gpIIO->IsOn(m_rgusSensor[1]);
		return (bVal1 && bVal2);

    default:
		return FALSE;
    }
}

int MVacuum::IsOff()
{
#ifdef SIMULATION
	BOOL bReturn = FALSE;
	
	EnterCriticalSection(&m_csSimul);
	
	if (FALSE == m_bSimulOnState)
	{
		m_bVacuumOnBeingOnState = FALSE;
		m_bVacuumOnBeingOffState = FALSE;
		bReturn = TRUE;
	}
	
	if (TRUE == m_bVacuumOnBeingOffState)
	{
		ASSERT(m_VacParameter.m_dSimulationTime > 0.0);
		if (m_tmSimulTimer.MoreThan(m_VacParameter.m_dSimulationTime))
		{
			m_bSimulOnState = FALSE;
			m_bVacuumOnBeingOffState = FALSE;
			m_tmSimulTimer.StopTimer();
			bReturn = TRUE;
		}
	}
	
	LeaveCriticalSection(&m_csSimul);
	return bReturn;
#endif

	BOOL bVal1, bVal2;

    switch (m_eVacuumType)
    {
    case SINGLE_VACUUM:
	case SINGLE_VACUUM_W_D_BLOW:
	case SINGLE_VACUUM_W_I_BLOW:
    case REVERSE_SINGLE_VACUUM:
		return m_gpIIO->IsOff(m_rgusSensor[0]);

    case DOUBLE_VACUUM:
	case DOUBLE_VACUUM_W_D_BLOW:
	case DOUBLE_VACUUM_W_I_BLOW:
    case HETERO_DOUBLE_VACUUM:
    case REVERSE_DOUBLE_VACUUM:
		bVal1 = m_gpIIO->IsOff(m_rgusSensor[0]);
		bVal2 = m_gpIIO->IsOff(m_rgusSensor[1]);
		return (bVal1 && bVal2);

     default:
        return FALSE;
    }
}

int MVacuum::On(int skip_sensor)
{
#ifdef SIMULATION
	EnterCriticalSection(&m_csSimul);

	if (TRUE == m_bSimulOnState)
	{
		m_tmSimulTimer.StopTimer();
		m_bVacuumOnBeingOnState = FALSE;
		m_bVacuumOnBeingOffState = FALSE;
		LeaveCriticalSection(&m_csSimul);
		return ERR_VACUUM_SUCCESS;
	}

	if (FALSE == m_tmSimulTimer.IsTimerStarted())
	{
		m_tmSimulTimer.StartTimer();
		m_bSimulOnState = FALSE;
		m_bVacuumOnBeingOnState = TRUE;
		m_bVacuumOnBeingOffState = FALSE;
		
		if (skip_sensor)	// 센서를 체크하지 않으면 바로 리턴 한다.
		{
			LeaveCriticalSection(&m_csSimul);
			Sleep(0);
			return ERR_VACUUM_SUCCESS;
		}
	}
	else
	{
		// On 시키는 중인지 Off 시키고 있는 중인지에 따라 처리 구분 필요.
		if (TRUE == m_bVacuumOnBeingOnState)
		{
			// 이미 On 시키는 중이므로 Wait4OnComplete 만 확인하면 됨.
		}
		else
		{
			m_tmSimulTimer.StartTimer();
			m_bSimulOnState = FALSE;
			m_bVacuumOnBeingOnState = TRUE;
			m_bVacuumOnBeingOffState = FALSE;
			
			if (skip_sensor)	// 센서를 체크하지 않으면 바로 리턴 한다.
			{
				LeaveCriticalSection(&m_csSimul);
				Sleep(0);
				return ERR_VACUUM_SUCCESS;
			}
		}
	}

	LeaveCriticalSection(&m_csSimul);
	return Wait4OnComplete();
#endif

    switch (m_eVacuumType)
    {
    case SINGLE_VACUUM:
        m_gpIIO->OutputOn(m_rgusSolenoid[0]);
        break;
	case SINGLE_VACUUM_W_D_BLOW:
	case SINGLE_VACUUM_W_I_BLOW:
        m_gpIIO->OutputOn(m_rgusSolenoid[0]);
        m_gpIIO->OutputOff(m_rgusSolenoid[1]);
        break;
    case REVERSE_SINGLE_VACUUM:
        m_gpIIO->OutputOff(m_rgusSolenoid[0]);
        break;
    case DOUBLE_VACUUM:
		m_gpIIO->OutputOn(m_rgusSolenoid[0]);
        m_gpIIO->OutputOn(m_rgusSolenoid[1]);
		break;
	case DOUBLE_VACUUM_W_D_BLOW:
	case DOUBLE_VACUUM_W_I_BLOW:
		m_gpIIO->OutputOn(m_rgusSolenoid[0]);
		m_gpIIO->OutputOff(m_rgusSolenoid[2]);
		m_gpIIO->OutputOn(m_rgusSolenoid[1]);
		m_gpIIO->OutputOff(m_rgusSolenoid[4]);
        break;
    case HETERO_DOUBLE_VACUUM:
        m_gpIIO->OutputOff(m_rgusSolenoid[0]);
        m_gpIIO->OutputOn(m_rgusSolenoid[1]);
        break;
    case REVERSE_DOUBLE_VACUUM:
        m_gpIIO->OutputOff(m_rgusSolenoid[0]);
        m_gpIIO->OutputOff(m_rgusSolenoid[1]);
        break;
    default:
        break;
    }

    if (skip_sensor)
    {
        Sleep(0);
	    return ERR_VACUUM_SUCCESS;
	}

	return Wait4OnComplete();
}

// Blow를 포함하는 Vacuum의 경우 확인이 필요함
int MVacuum::Off(int skip_sensor)
{
#ifdef SIMULATION
	EnterCriticalSection(&m_csSimul);

	if (FALSE == m_bSimulOnState)
	{
		m_tmSimulTimer.StopTimer();
		m_bVacuumOnBeingOnState = FALSE;
		m_bVacuumOnBeingOffState = FALSE;
		LeaveCriticalSection(&m_csSimul);
		return ERR_VACUUM_SUCCESS;
	}

	if (FALSE == m_tmSimulTimer.IsTimerStarted())
	{
		m_tmSimulTimer.StartTimer();
		m_bSimulOnState = TRUE;
		m_bVacuumOnBeingOnState = FALSE;
		m_bVacuumOnBeingOffState = TRUE;
		
		if (skip_sensor)	// 센서를 체크하지 않으면 바로 리턴 한다.
		{
			LeaveCriticalSection(&m_csSimul);
			Sleep(0);
			return ERR_VACUUM_SUCCESS;
		}
	}
	else
	{
		// On 시키는 중인지 Off 시키고 있는 중인지에 따라 처리 구분 필요.
		if (TRUE == m_bVacuumOnBeingOffState)
		{
			// 이미 Off 시키는 중이므로 Wait4OffComplete 만 확인하면 됨.
		}
		else
		{
			m_tmSimulTimer.StartTimer();
			m_bSimulOnState = TRUE;
			m_bVacuumOnBeingOnState = FALSE;
			m_bVacuumOnBeingOffState = TRUE;
			
			if (skip_sensor)	// 센서를 체크하지 않으면 바로 리턴 한다.
			{
				LeaveCriticalSection(&m_csSimul);
				Sleep(0);
				return ERR_VACUUM_SUCCESS;
			}
		}
	}

	LeaveCriticalSection(&m_csSimul);
	return Wait4OffComplete();
#endif

    switch (m_eVacuumType)
    {
    case SINGLE_VACUUM:
        m_gpIIO->OutputOff(m_rgusSolenoid[0]);
        break;
	case SINGLE_VACUUM_W_I_BLOW:
        m_gpIIO->OutputOff(m_rgusSolenoid[0]);
        m_gpIIO->OutputOn(m_rgusSolenoid[1]);	// 먼저 Blow Off
		Sleep(UINT(m_VacParameter.m_dOffSettlingTime * 1000));
        break;

	case SINGLE_VACUUM_W_D_BLOW:
		m_gpIIO->OutputOn(m_rgusSolenoid[0]);
        m_gpIIO->OutputOn(m_rgusSolenoid[1]);
		break;

    case REVERSE_SINGLE_VACUUM:
        m_gpIIO->OutputOn(m_rgusSolenoid[0]);
        break;
    case DOUBLE_VACUUM:
        m_gpIIO->OutputOff(m_rgusSolenoid[0]);
        m_gpIIO->OutputOff(m_rgusSolenoid[1]);
        break;
	case DOUBLE_VACUUM_W_I_BLOW:
        m_gpIIO->OutputOff(m_rgusSolenoid[0]);
        m_gpIIO->OutputOff(m_rgusSolenoid[1]);
        m_gpIIO->OutputOn(m_rgusSolenoid[2]);	// 먼저 Blow Off
        m_gpIIO->OutputOn(m_rgusSolenoid[3]);	// 먼저 Blow Off
		Sleep(UINT(m_VacParameter.m_dOffSettlingTime * 1000));
        break;

	case DOUBLE_VACUUM_W_D_BLOW:
		m_gpIIO->OutputOn(m_rgusSolenoid[0]);
        m_gpIIO->OutputOn(m_rgusSolenoid[1]);
        m_gpIIO->OutputOn(m_rgusSolenoid[2]);
        m_gpIIO->OutputOn(m_rgusSolenoid[3]);
		Sleep(UINT(m_VacParameter.m_dOffSettlingTime * 1000));
		break;

	case HETERO_DOUBLE_VACUUM:
        m_gpIIO->OutputOn(m_rgusSolenoid[0]);
        m_gpIIO->OutputOff(m_rgusSolenoid[1]);
        break;
    case REVERSE_DOUBLE_VACUUM:
        m_gpIIO->OutputOn(m_rgusSolenoid[0]);
        m_gpIIO->OutputOn(m_rgusSolenoid[1]);
        break;
	default:
        break;
    }

    if (skip_sensor)
    {
        Sleep(0);
        return ERR_VACUUM_SUCCESS;
	}

	return Wait4OffComplete();
}

/*----------- MVacuum 동작 시작  -----------------------*/
/**
 * Vacuum을 On시킨다.
 * @return  0 if Vacuum operates right,  Error Number if error occurs
 */
int MVacuum::StartOn()
{
	return On(TRUE);
}

/**
 * Vacuum을 Off시킨다.
 * @return  0 if MVacuum operates right,  Error Number if error occurs
 */
int MVacuum::StartOff()
{
	return Off(TRUE);
}

/*----------- MVacuum 동작완료시까지 Sleep  -----------------------*/
/**
 * MVacuum On이 완료될때까지 기다린다.
 * @return  0 if MVacuum operates right,  Error Number if error occurs
 */
int MVacuum::Wait4OnComplete()
{
#ifdef SIMULATION
	EnterCriticalSection(&m_csSimul);

	if (TRUE == m_bSimulOnState)
	{
		m_tmSimulTimer.StopTimer();
		m_bVacuumOnBeingOnState = FALSE;
		m_bVacuumOnBeingOffState = FALSE;
		LeaveCriticalSection(&m_csSimul);
		return ERR_VACUUM_SUCCESS;
	}

	// On 시키는 중이 아닌 경우.
	if (FALSE == m_bVacuumOnBeingOnState)
	{
		LeaveCriticalSection(&m_csSimul);
		return ERR_VACUUM_SUCCESS;
	}

	if (TRUE == m_tmSimulTimer.IsTimerStarted())
	{
		LeaveCriticalSection(&m_csSimul);

		ASSERT(m_VacParameter.m_dSimulationTime > 0.0);
		while (m_tmSimulTimer.LessThan(m_VacParameter.m_dSimulationTime))
		{
			Sleep(3);
		}

		EnterCriticalSection(&m_csSimul);

		if (TRUE == m_bVacuumOnBeingOffState)
		{
			LeaveCriticalSection(&m_csSimul);
			return ERR_VACUUM_SUCCESS;
		}
	}

	m_tmSimulTimer.StopTimer();

	m_bSimulOnState = TRUE;
	
	m_bVacuumOnBeingOnState = FALSE;
	m_bVacuumOnBeingOffState = FALSE;

	LeaveCriticalSection(&m_csSimul);
	return ERR_VACUUM_SUCCESS;
#endif

	MTickTimer VacuumTimer;
	VacuumTimer.StartTimer();

    while (TRUE)
    {
		if (IsOn())	break;

        if (VacuumTimer.MoreThan(m_VacParameter.m_dTurningTime))
        {
            switch (m_eVacuumType)
            {
            case SINGLE_VACUUM:
                m_gpIIO->OutputOff(m_rgusSolenoid[0]);
                break;
			case SINGLE_VACUUM_W_D_BLOW:
			case SINGLE_VACUUM_W_I_BLOW:
                m_gpIIO->OutputOff(m_rgusSolenoid[0]);
                m_gpIIO->OutputOff(m_rgusSolenoid[1]);
                break;
            case REVERSE_SINGLE_VACUUM:
                m_gpIIO->OutputOn(m_rgusSolenoid[0]);
                break;
            case DOUBLE_VACUUM:
			case DOUBLE_VACUUM_W_D_BLOW:
			case DOUBLE_VACUUM_W_I_BLOW:
                m_gpIIO->OutputOff(m_rgusSolenoid[0]);
                m_gpIIO->OutputOff(m_rgusSolenoid[1]);
                break;
			case HETERO_DOUBLE_VACUUM:
                m_gpIIO->OutputOn(m_rgusSolenoid[0]);
                m_gpIIO->OutputOff(m_rgusSolenoid[1]);
                break;
			case REVERSE_DOUBLE_VACUUM:
                m_gpIIO->OutputOn(m_rgusSolenoid[0]);
                m_gpIIO->OutputOn(m_rgusSolenoid[1]);
                break;
			default:
                break;
            }
			// 102001 = Vacuum On 동작 시간이 초과 되었습니다.
            return generateErrorCode(102001);	// ERR_VACUUM_TIMEOUT_ON
        }
        Sleep(5);
    }

	Sleep(UINT(m_VacParameter.m_dOnSettlingTime * 1000));

    return ERR_VACUUM_SUCCESS;
}

/**
 * MVacuum Off가 완료될때까지 기다린다.
 * @return  0 if MVacuum operates right,  Error Number if error occurs
 */
int MVacuum::Wait4OffComplete()
{
#ifdef SIMULATION
	EnterCriticalSection(&m_csSimul);

	if (FALSE == m_bSimulOnState)
	{
		m_tmSimulTimer.StopTimer();
		m_bVacuumOnBeingOnState = FALSE;
		m_bVacuumOnBeingOffState = FALSE;
		LeaveCriticalSection(&m_csSimul);
		return ERR_VACUUM_SUCCESS;
	}

	// On 시키는 중이 아닌 경우.
	if (FALSE == m_bVacuumOnBeingOffState)
	{
		LeaveCriticalSection(&m_csSimul);
		return ERR_VACUUM_SUCCESS;
	}

	if (TRUE == m_tmSimulTimer.IsTimerStarted())
	{
		LeaveCriticalSection(&m_csSimul);

		ASSERT(m_VacParameter.m_dSimulationTime > 0.0);
		while (m_tmSimulTimer.LessThan(m_VacParameter.m_dSimulationTime))
		{
			Sleep(1);
		}

		EnterCriticalSection(&m_csSimul);

		if (TRUE == m_bVacuumOnBeingOnState)
		{
			LeaveCriticalSection(&m_csSimul);
			return ERR_VACUUM_SUCCESS;
		}
	}

	m_tmSimulTimer.StopTimer();

	m_bSimulOnState = FALSE;
	
	m_bVacuumOnBeingOnState = FALSE;
	m_bVacuumOnBeingOffState = FALSE;

	LeaveCriticalSection(&m_csSimul);
	return ERR_VACUUM_SUCCESS;
#endif

	MTickTimer	VacuumTimer;
	VacuumTimer.StartTimer();

    while (TRUE)
    {
		if (IsOff())
			break;

	    if (VacuumTimer.MoreThan(m_VacParameter.m_dTurningTime))
	    {
			switch (m_eVacuumType)
			{
            case SINGLE_VACUUM:
                m_gpIIO->OutputOff(m_rgusSolenoid[0]);
                break;
			case SINGLE_VACUUM_W_D_BLOW:
			case SINGLE_VACUUM_W_I_BLOW:
                m_gpIIO->OutputOff(m_rgusSolenoid[0]);
                m_gpIIO->OutputOff(m_rgusSolenoid[1]);
                break;
            case REVERSE_SINGLE_VACUUM:
                m_gpIIO->OutputOn(m_rgusSolenoid[0]);
                break;
            case DOUBLE_VACUUM:
                m_gpIIO->OutputOff(m_rgusSolenoid[0]);
                m_gpIIO->OutputOff(m_rgusSolenoid[1]);
                break;
			case DOUBLE_VACUUM_W_D_BLOW:
			case DOUBLE_VACUUM_W_I_BLOW:
                m_gpIIO->OutputOff(m_rgusSolenoid[0]);
                m_gpIIO->OutputOff(m_rgusSolenoid[1]);
	            m_gpIIO->OutputOff(m_rgusSolenoid[2]);
	            m_gpIIO->OutputOff(m_rgusSolenoid[3]);
                break;
			case HETERO_DOUBLE_VACUUM:
                m_gpIIO->OutputOn(m_rgusSolenoid[0]);
                m_gpIIO->OutputOff(m_rgusSolenoid[1]);
                break;
			case REVERSE_DOUBLE_VACUUM:
                m_gpIIO->OutputOn(m_rgusSolenoid[0]);
                m_gpIIO->OutputOn(m_rgusSolenoid[1]);
                break;
			default:
                break;
			}
			// 102002 = Vacuum Off 동작 시간이 초과 되었습니다.
	        return generateErrorCode(102002);	// ERR_VACUUM_TIMEOUT_OFF
	    }
	    Sleep(5);
	}

	switch (m_eVacuumType)
	{
	case SINGLE_VACUUM_W_D_BLOW:
	case SINGLE_VACUUM_W_I_BLOW:
        m_gpIIO->OutputOff(m_rgusSolenoid[0]);
		m_gpIIO->OutputOff(m_rgusSolenoid[1]);
        break;
	case DOUBLE_VACUUM_W_D_BLOW:
	case DOUBLE_VACUUM_W_I_BLOW:
		m_gpIIO->OutputOff(m_rgusSolenoid[0]);
        m_gpIIO->OutputOff(m_rgusSolenoid[1]);
        m_gpIIO->OutputOff(m_rgusSolenoid[2]);
        m_gpIIO->OutputOff(m_rgusSolenoid[3]);
        break;
	default:
		Sleep(UINT(m_VacParameter.m_dOffSettlingTime * 1000));	// 정종철 추가 : Blow 아닐때만 안정화 기다리게 
        break;
	}
    return ERR_VACUUM_SUCCESS;
}

/**
 * 모든 Solenoid를 Off한다.
 */
void MVacuum::OffSolenoid()
{
	for (int i = 0; i < DEF_MAX_VACUUM_SOLENOID; i++)
	{
		if (NULL != m_rgusSolenoid[i])
			m_gpIIO->OutputOn(m_rgusSolenoid[i]);
	}
}

/**
* Assign component linkage
* 
* @param	pIO	: 참조할 IO Component Pointer
*/
int MVacuum::AssignComponents(IIO *pIO)
{
	ASSERT(pIO != NULL);

	m_gpIIO = pIO;
		
	return ERR_VACUUM_SUCCESS;
}

/** 
* Component Data 처리 
*
* @param	datComponent : 기록할 데이타
* @return	Error : 0 = Success, 그외=기타
*/
int MVacuum::SetData(SVacuumData datComponent)
{
	m_iVacID = datComponent.m_sVacVal.m_iVacID;

	m_strVacuumName.Format(_T("%s"), datComponent.m_sVacVal.m_szName);
	
	for (int i = 0; i < DEF_MAX_VACUUM_SOLENOID; i++)
	{
		m_rgusSolenoid[i] = datComponent.m_sVacVal.m_rgusSolenoid[i];
		m_rgusSensor[i] = datComponent.m_sVacVal.m_rgusSensor[i];
	}

	m_eVacuumType = datComponent.m_sVacVal.m_lnkVacuumType;

	m_strFileName = datComponent.m_strFileName;

	return ERR_VACUUM_SUCCESS;
}

/** 
* Component Data 처리 
*
* @param	datComponent : MVacuumData Class에 대한 포인터
* @return	Error : 0 = Success, 그외=기타
*/
int MVacuum::GetData(SVacuumData* datComponent)
{
	for (int i = 0; i < DEF_MAX_VACUUM_SOLENOID; i++)
	{
		 datComponent->m_sVacVal.m_rgusSolenoid[i] = m_rgusSolenoid[i];
		 datComponent->m_sVacVal.m_rgusSensor[i] = m_rgusSensor[i];
	}
	datComponent->m_sVacVal.m_lnkVacuumType = m_eVacuumType;
	datComponent->m_strFileName = m_strFileName;

	return ERR_VACUUM_SUCCESS;
}

/**
 * Vacuum 관련 Data를 File에서 읽어온다.
 *
 * @param	pvacTimerData (읽어올 Data가 저장될 변수)
 * @return	int (0 = Success, Error Code = 그 외)
 */
int MVacuum::LoadParameter()
{
	BOOL bResult;
	CString strLogMsg;

	MVacuumData vacTimerData(m_strVacuumName, m_strFileName);

	bResult = vacTimerData.ReadData();
	m_VacParameter = vacTimerData;
	
	if (!bResult)
		return generateErrorCode(102003);	// ERR_VACUUM_FAIL_IN_LOADING_PARAM
	
	return ERR_VACUUM_SUCCESS;
}

/**
 * Vacuum 관련 Data를 File에 저장한다.
 *
 * @param	pvacTimerData (저장할 Data)
 * @return	int (0 = Success, Error Code = 그 외)
 */
int MVacuum::SaveParameter(MVacuumData* pvacTimerData)
{	
	BOOL bResult;
	CString strLogMsg;

	MVacuumData vacTimerData(m_strVacuumName, m_strFileName);

	m_VacParameter = *pvacTimerData;

	vacTimerData = m_VacParameter;
	
	bResult = vacTimerData.WriteData();
	if (!bResult)
		return generateErrorCode(102004);	// ERR_VACUUM_FAIL_IN_SAVING_PARAM

	return ERR_VACUUM_SUCCESS;
}

/**
 * Vacuum 관련 Data를 얻어 온다.
 *
 * @param	pvacParameter (읽어올 Data가 저장될 변수)
 */
void MVacuum::GetParameter(MVacuumData* pvacParameter)
{
	*pvacParameter = m_VacParameter;
}

/**
 * Vacuum 이름을 Return 한다.
 * @return : Vacuum Name
 */
CString MVacuum::GetVacuumName()
{
	return m_strVacuumName;
}

/**
 * Vacuum SolValve 배열을 리턴한다.
 */
unsigned short* MVacuum::GetSolAddr()
{
	return m_rgusSolenoid;
}

/**
 * Vacuum Sensor 배열을 리턴한다.
 */
unsigned short* MVacuum::GetSensorAddr()
{
	return m_rgusSensor;
}
/* End Of Code */
