/* Generated by Together */

#include "StdAfx.h"
#include "IIO.h"
#include "MCylinder.h"

#include "common.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/** Default 생성자 */
MCylinder::MCylinder()
{
	/** Referenced Component 초기화 */
	m_gpIIO = NULL;
	
	/** Data 초기화 */
	for (int i = 0; i < 2; i++)
	{
		m_rgusSolenoid[i] = 0;
		m_rgusAccSolenoid[i] = 0;
		m_rgusAccSensor[i] = 0;
	}
	for (int i = 0; i < DEF_MAX_CYLINDER_SENSOR; i++)
	{
		m_rgusUpSensor[i] = 0;
		m_rgusDownSensor[i] = 0;
		m_rgusMiddleSensor[i] = 0;
	}

	m_eCylinderType = UNKOWN_CYLINDER;
	m_eSolenoidType = UNKOWN_SOLENOID;
	m_strFileName = "";
	m_strFilePath = "";

	m_dUpElapseTime = 0.0;
	m_dDownElapseTime = 0.0;

#ifdef SIMULATION
	// 확인 필요 : InitSystem 에서 상태 정해주는 방법은?
	m_bSimulUpState = TRUE;
	m_bSimulDownState = FALSE;
	m_bCylinderOnBeingUpState = FALSE;
	m_bCylinderOnBeingMiddleState = FALSE;
	m_bCylinderOnBeingDownState = FALSE;
	m_tmSimulTimer.StopTimer();

	InitializeCriticalSection(&m_csSimul);
#endif
}

/** 
 * Constructor
 * 
 * @param	commonData : 공통적으로 사용할 Data
 * @param	pIIO : 참조할 I/O Component 포인터
 * @param	datComponent : 자체적으로 사용할 Data
 */
MCylinder::MCylinder(SCommonAttribute commonData, IIO* pIIO, SCylinderData datComponent)
: ICommon(commonData)
{
	CString	strLogMsg;

	m_gpIIO	= pIIO;
	SetData(datComponent);

	m_dUpElapseTime	= 0.0;
	m_dDownElapseTime = 0.0;

#ifdef SIMULATION
	// 확인 필요 : InitSystem 에서 상태 정해주는 방법은?
	m_bSimulUpState = TRUE;
	m_bSimulDownState = FALSE;
	m_bCylinderOnBeingUpState = FALSE;
	m_bCylinderOnBeingMiddleState = FALSE;
	m_bCylinderOnBeingDownState = FALSE;
	m_tmSimulTimer.StopTimer();

	InitializeCriticalSection(&m_csSimul);
#endif
	
	strLogMsg.Format(_T("MCylinder() : ObjectID=%d OK"), GetObjectID());
	WriteLog(DEF_MLOG_NORMAL_LOG_LEVEL, strLogMsg, __FILE__, __LINE__);
}


/** 소멸자 */
MCylinder::~MCylinder()
{
#ifdef SIMULATION
	DeleteCriticalSection(&m_csSimul);
#endif

	TRACE(_T("MCylinder Class Destruction is Completed.\n"));
}

int MCylinder::GetCylinderTime(double & dMovingTime,
							   double & dSettlingTime1, 
							   double & dSettlingTime2, 
							   double & dNoSenMovingTime)
{
    dMovingTime			= m_CylParameter.m_dMovingTime;
    dSettlingTime1		= m_CylParameter.m_dSettlingTime1;
	dSettlingTime2		= m_CylParameter.m_dSettlingTime2;
    dNoSenMovingTime	= m_CylParameter.m_dNoSenMovingTime;
    return 0;
}

int MCylinder::GetCylinderTime(ECylinderTime eCylinderTime, double & dCylinderTime)
{
    switch (eCylinderTime)
    {
    case MOVING_TIME:
        dCylinderTime = m_CylParameter.m_dMovingTime;
        break;
    case NOSEN_MOVING_TIME:
        dCylinderTime = m_CylParameter.m_dNoSenMovingTime;
        break;
    case SETTLING_TIME1:
		dCylinderTime = m_CylParameter.m_dSettlingTime1;
        break;
    case SETTLING_TIME2:
		dCylinderTime = m_CylParameter.m_dSettlingTime2;
        break;
    default:
        break;
    }
    return 0;
}

BOOL MCylinder::IsUp()
{
#ifdef SIMULATION
	BOOL bReturn = FALSE;

	try
	{
		EnterCriticalSection(&m_csSimul);
	}
	catch (CException* e)
	{
		TRACE0("EXCEPTION\n");

		// Handle the exception here.
		// "e" contains information about the exception.
		e->Delete();
	}

	if (TRUE == m_bSimulUpState)
	{
		m_bCylinderOnBeingUpState = FALSE;
		bReturn = TRUE;
	}
	
	if (TRUE == m_bCylinderOnBeingUpState)
	{
		ASSERT(m_CylParameter.m_dSimulationTime >= 0.0);
		if (TRUE == m_tmSimulTimer.MoreThan(m_CylParameter.m_dSimulationTime))
		{
			m_bSimulUpState = TRUE;
			m_bCylinderOnBeingUpState = FALSE;
			m_tmSimulTimer.StopTimer();
			bReturn = TRUE;
		}
	}

	LeaveCriticalSection(&m_csSimul);

	return bReturn;
#endif

	BOOL bRet1, bRet2;
	BOOL bCheckSensor = FALSE; //@130203.KKY
	for (int i = 0; i < DEF_MAX_CYLINDER_SENSOR; i++)	// 모든 실린더에 대해 체크
	{
		bRet1 = bRet2 = TRUE;

		// UP Sensor가 On인지 확인
		if (m_rgusUpSensor[i])	
		{
			bRet1 = m_gpIIO->IsOn(m_rgusUpSensor[i]);
			bCheckSensor = TRUE;
		}

		// Down Sensor가 Off인지 확인
		if (m_rgusDownSensor[i]) 
		{
			bRet2 = m_gpIIO->IsOff(m_rgusDownSensor[i]);
			bCheckSensor = TRUE;
		}
	
		// 2개중 하나라도 True가 아니면
		if (!bRet1 || !bRet2) 
			return FALSE;
	}

	//@130203.KKY____________
	if (FALSE == bCheckSensor)
	{
		switch (m_eSolenoidType)
		{
		case SINGLE_SOLENOID:
			return m_gpIIO->IsOn(m_rgusSolenoid[0]);
		case REVERSE_SINGLE_SOLENOID:
			return m_gpIIO->IsOff(m_rgusSolenoid[0]);
		case DOUBLE_SOLENOID:
		case DOUBLE_3WAY_SOLENOID:
		case DOUBLE_SOLENOID_VARIOUS_VELOCITY:
			return (m_gpIIO->IsOn(m_rgusSolenoid[0]) && m_gpIIO->IsOff(m_rgusSolenoid[1]));
		default:
			break;
		}
		return FALSE;
	}
	//@______________________

	// 모든 Sensor에 대해 확인 완료
	// 아니면 중간에서 FALSE 리턴 했을 테니까 !!!
	return TRUE;
}

BOOL MCylinder::IsDown()
{
#ifdef SIMULATION
	BOOL bReturn = FALSE;

	try
	{
		EnterCriticalSection(&m_csSimul);
	}
	catch (CException* e)
	{
		TRACE0("EXCEPTION\n");

		// Handle the exception here.
		// "e" contains information about the exception.
		e->Delete();
	}
	
	if (m_bSimulDownState)
	{
		m_bCylinderOnBeingDownState = FALSE;
		bReturn = TRUE;
	}

	if (TRUE == m_bCylinderOnBeingDownState)
	{
		///ASSERT(m_CylParameter.m_dSimulationTime > 0.0);
		if (m_CylParameter.m_dSimulationTime <= 0.0 )
			m_CylParameter.m_dSimulationTime = 0.5;
		if (m_tmSimulTimer.MoreThan(m_CylParameter.m_dSimulationTime))
		{
			m_bSimulDownState = TRUE;
			m_bCylinderOnBeingDownState = FALSE;
			m_tmSimulTimer.StopTimer();
			bReturn = TRUE;
		}
	}

	LeaveCriticalSection(&m_csSimul);

	return bReturn;
#endif

	BOOL bRet1, bRet2;
	BOOL bCheckSensor = FALSE; //@130203.KKY
	for (int i = 0; i < DEF_MAX_CYLINDER_SENSOR; i++)	// 모든 실린더에 대해 체크
	{
		bRet1 = bRet2 = TRUE;

		// UP Sensor가 Off인지 확인
		if (m_rgusUpSensor[i])
		{
			bRet1 = m_gpIIO->IsOff(m_rgusUpSensor[i]);
			bCheckSensor = TRUE;
		}
		
		// Down Sensor가 On인지 확인
		if (m_rgusDownSensor[i])
		{
			bRet2 = m_gpIIO->IsOn(m_rgusDownSensor[i]);
			bCheckSensor = TRUE;
		}
		
		// 2개중 하나라도 True가 아니면
		if (!bRet1 || !bRet2)
			return FALSE;
	}

	//@130203.KKY____________
	if (FALSE == bCheckSensor)
	{
		switch (m_eSolenoidType)
		{
		case SINGLE_SOLENOID:
			return m_gpIIO->IsOff(m_rgusSolenoid[0]);
		case REVERSE_SINGLE_SOLENOID:
			return m_gpIIO->IsOn(m_rgusSolenoid[0]);
		case DOUBLE_SOLENOID:
		case DOUBLE_3WAY_SOLENOID:
		case DOUBLE_SOLENOID_VARIOUS_VELOCITY:
			return (m_gpIIO->IsOff(m_rgusSolenoid[0]) && m_gpIIO->IsOn(m_rgusSolenoid[1]));
			break;
		default:
			break;
		}
	}
	//@_______________________

	// 모든 Sensor에 대해 확인 완료
	return TRUE;
}

BOOL MCylinder::IsMiddle()
{
#ifdef SIMULATION
	BOOL bReturn = FALSE;

	try
	{
		EnterCriticalSection(&m_csSimul);
	}
	catch (CException* e)
	{
		TRACE0("EXCEPTION\n");

		// Handle the exception here.
		// "e" contains information about the exception.
		e->Delete();
	}

	if (FALSE == m_bSimulUpState && FALSE == m_bSimulDownState
		&& FALSE == m_bCylinderOnBeingUpState && FALSE == m_bCylinderOnBeingDownState)
	{
		m_bCylinderOnBeingMiddleState = FALSE;
		bReturn = TRUE;
	}

	if (TRUE == m_bCylinderOnBeingMiddleState)
	{
		ASSERT(m_CylParameter.m_dSimulationTime >= 0.0);
		if (m_tmSimulTimer.MoreThan(m_CylParameter.m_dSimulationTime))
		{
			m_bSimulUpState = FALSE;
			m_bSimulDownState = FALSE;
			m_bCylinderOnBeingMiddleState = FALSE;
			m_tmSimulTimer.StopTimer();
			bReturn = TRUE;
		}
	}

	LeaveCriticalSection(&m_csSimul);

	return bReturn;
#endif

    ASSERT(m_eSolenoidType == DOUBLE_3WAY_SOLENOID);

	for (int i = 0; i < DEF_MAX_CYLINDER_SENSOR; i++)	// 모든 실린더에 대해 체크
	{
		if (m_rgusMiddleSensor[i])
		{
			if (m_gpIIO->IsOn(m_rgusMiddleSensor[i]) == FALSE)	// Middle Sensor가 On 인지 확인
				return FALSE;
		}
	}
	return TRUE;	// 모든 Sensor에 대해 확인 완료
}

BOOL MCylinder::IsLeft()
{
	return IsUp();
}

BOOL MCylinder::IsRight()
{
	return IsDown();
}

BOOL MCylinder::IsFront()
{
    return IsUp();
}

BOOL MCylinder::IsBack()
{
    return IsDown();
}

BOOL MCylinder::IsDownstr()
{
    return IsDown();
}

BOOL MCylinder::IsUpstr()
{

    return IsUp();
}

BOOL MCylinder::IsCW()
{
    return IsUp();
}

BOOL MCylinder::IsCCW()
{
    return IsDown();
}

BOOL MCylinder::IsOpen()
{
    return IsUp();
}

BOOL MCylinder::IsClose()
{
    return IsDown();
}

BOOL MCylinder::IsExpand()
{
    return IsUp();
}

BOOL MCylinder::IsShrink()
{
    return IsDown();
}

int MCylinder::Up(int skip_sensor)
{
#ifdef SIMULATION
	try
	{
		EnterCriticalSection(&m_csSimul);
	}
	catch (CException* e)
	{
		TRACE0("EXCEPTION\n");

		// Handle the exception here.
		// "e" contains information about the exception.
		e->Delete();
	}

	if (TRUE == m_bSimulUpState)
	{
		m_tmSimulTimer.StopTimer();
		m_bSimulDownState = FALSE;
		m_bCylinderOnBeingUpState = FALSE;
		m_bCylinderOnBeingMiddleState = FALSE;
		m_bCylinderOnBeingDownState = FALSE;
		LeaveCriticalSection(&m_csSimul);
		return ERR_CYLINDER_SUCCESS;
	}

	if (FALSE == m_tmSimulTimer.IsTimerStarted())
	{		
		m_tmSimulTimer.StartTimer();
		m_bSimulDownState = FALSE;
		m_bCylinderOnBeingUpState = TRUE;
		m_bCylinderOnBeingMiddleState = FALSE;
		m_bCylinderOnBeingDownState = FALSE;
		
		if (skip_sensor)	// 센서를 체크하지 않으면 바로 리턴 한다.
		{
			LeaveCriticalSection(&m_csSimul);
			Sleep(0);
			return ERR_CYLINDER_SUCCESS;
		}
	}
	else
	{
		// 어느 방향으로 움직이고 있는지 확인해서 처리 필요.
		if (TRUE == m_bCylinderOnBeingUpState)
		{
			// 이미 Up 방향으로 움직이고 있는 상태이므로 Wait4UpComplete 만 확인하면 됨.
		}
		else
		{
			m_tmSimulTimer.StartTimer();
			m_bSimulDownState = FALSE;
			m_bCylinderOnBeingUpState = TRUE;
			m_bCylinderOnBeingMiddleState = FALSE;
			m_bCylinderOnBeingDownState = FALSE;

			if (skip_sensor)	// 센서를 체크하지 않으면 바로 리턴 한다.
			{
				LeaveCriticalSection(&m_csSimul);
				Sleep(0);
				return ERR_CYLINDER_SUCCESS;
			}
		}
	}

	LeaveCriticalSection(&m_csSimul);
	return Wait4UpComplete();
#endif

	if (!skip_sensor)
		m_tmUpTimer.StartTimer();

    switch (m_eSolenoidType)
    {
    case SINGLE_SOLENOID:
		m_gpIIO->OutputOn(m_rgusSolenoid[0]);
        break;
    case REVERSE_SINGLE_SOLENOID:
		m_gpIIO->OutputOff(m_rgusSolenoid[0]);
        break;
    case DOUBLE_SOLENOID:
    case DOUBLE_3WAY_SOLENOID:
    case DOUBLE_SOLENOID_VARIOUS_VELOCITY:
		m_gpIIO->OutputOn(m_rgusSolenoid[0]);
		m_gpIIO->OutputOff(m_rgusSolenoid[1]);
		break;
    default:
        break;
    }

	// 센서를 체크하지 않으면 바로 리턴 한다.
    if (skip_sensor)
    {
        Sleep(0);
        return ERR_CYLINDER_SUCCESS;
    }

	return Wait4UpComplete();
}

int MCylinder::Down(int skip_sensor)
{

#ifdef SIMULATION
	try
	{
		EnterCriticalSection(&m_csSimul);
	}
	catch (CException* e)
	{
		TRACE0("EXCEPTION\n");

		// Handle the exception here.
		// "e" contains information about the exception.
		e->Delete();
	}

	if (TRUE == m_bSimulDownState)
	{
		m_tmSimulTimer.StopTimer();
		m_bSimulUpState = FALSE;
		m_bCylinderOnBeingUpState = FALSE;
		m_bCylinderOnBeingMiddleState = FALSE;
		m_bCylinderOnBeingDownState = FALSE;
		LeaveCriticalSection(&m_csSimul);
		return ERR_CYLINDER_SUCCESS;
	}

	if (FALSE == m_tmSimulTimer.IsTimerStarted())
	{
		m_tmSimulTimer.StartTimer();
		m_bSimulUpState = FALSE;
		m_bCylinderOnBeingUpState = FALSE;
		m_bCylinderOnBeingMiddleState = FALSE;
		m_bCylinderOnBeingDownState = TRUE;
		
		if (skip_sensor)	// 센서를 체크하지 않으면 바로 리턴 한다.
		{
			LeaveCriticalSection(&m_csSimul);
			Sleep(0);
			return ERR_CYLINDER_SUCCESS;
		}
	}
	else
	{
		// 어느 방향으로 움직이고 있는지 확인해서 처리 필요.
		if (TRUE == m_bCylinderOnBeingDownState)
		{
			// 이미 Down 방향으로 움직이고 있는 상태이므로 Wait4DownComplete 만 확인하면 됨.
		}
		else
		{
			m_tmSimulTimer.StartTimer();
			m_bSimulUpState = FALSE;
			m_bCylinderOnBeingUpState = FALSE;
			m_bCylinderOnBeingMiddleState = FALSE;
			m_bCylinderOnBeingDownState = TRUE;

			if (skip_sensor)	// 센서를 체크하지 않으면 바로 리턴 한다.
			{
				LeaveCriticalSection(&m_csSimul);
				Sleep(0);
				return ERR_CYLINDER_SUCCESS;
			}
		}
	}

	LeaveCriticalSection(&m_csSimul);
	return Wait4DownComplete();
#endif

	if (!skip_sensor)
		m_tmDownTimer.StartTimer();

	switch (m_eSolenoidType)
    {
    case SINGLE_SOLENOID:
		m_gpIIO->OutputOff(m_rgusSolenoid[0]);
        break;
    case REVERSE_SINGLE_SOLENOID:
		m_gpIIO->OutputOn(m_rgusSolenoid[0]);
        break;
    case DOUBLE_SOLENOID:
    case DOUBLE_3WAY_SOLENOID:
    case DOUBLE_SOLENOID_VARIOUS_VELOCITY:
		m_gpIIO->OutputOff(m_rgusSolenoid[0]);
		m_gpIIO->OutputOn(m_rgusSolenoid[1]);
        break;
    default:
        break;
    }

	// 센서를 체크하지 않으면 바로 리턴 한다.
    if (skip_sensor)
    {
        Sleep(0);
        return ERR_CYLINDER_SUCCESS;
    }

	return Wait4DownComplete();
}

int MCylinder::Middle(int skip_sensor)
{
#ifdef SIMULATION
	try
	{
		EnterCriticalSection(&m_csSimul);
	}
	catch (CException* e)
	{
		TRACE0("EXCEPTION\n");

		// Handle the exception here.
		// "e" contains information about the exception.
		e->Delete();
	}

	if (FALSE == m_bSimulUpState && FALSE == m_bSimulDownState)
	{
		m_tmSimulTimer.StopTimer();
		m_bCylinderOnBeingUpState = FALSE;
		m_bCylinderOnBeingMiddleState = FALSE;
		m_bCylinderOnBeingDownState = FALSE;
		LeaveCriticalSection(&m_csSimul);
		return ERR_CYLINDER_SUCCESS;
	}

	if (FALSE == m_tmSimulTimer.IsTimerStarted())
	{
		m_tmSimulTimer.StartTimer();
		m_bCylinderOnBeingUpState = FALSE;
		m_bCylinderOnBeingMiddleState = TRUE;
		m_bCylinderOnBeingDownState = FALSE;
		
		if (skip_sensor)	// 센서를 체크하지 않으면 바로 리턴 한다.
		{
			LeaveCriticalSection(&m_csSimul);
			Sleep(0);
			return ERR_CYLINDER_SUCCESS;
		}
	}
	else
	{
		// 어느 방향으로 움직이고 있는지 확인해서 처리 필요.
		if (TRUE == m_bCylinderOnBeingMiddleState)
		{
			// 이미 Down 방향으로 움직이고 있는 상태이므로 Wait4MiddleComplete 만 확인하면 됨.
		}
		else
		{
			m_tmSimulTimer.StartTimer();
			m_bCylinderOnBeingUpState = FALSE;
			m_bCylinderOnBeingMiddleState = TRUE;
			m_bCylinderOnBeingDownState = FALSE;

			if (skip_sensor)	// 센서를 체크하지 않으면 바로 리턴 한다.
			{
				LeaveCriticalSection(&m_csSimul);
				Sleep(0);
				return ERR_CYLINDER_SUCCESS;
			}
		}
	}

	BOOL bCylinderDir = (IsUp()) ? FALSE : TRUE;

	LeaveCriticalSection(&m_csSimul);
	return Wait4MiddleComplete(bCylinderDir);

#endif

	if (IsMiddle())
		return ERR_CYLINDER_SUCCESS;

	ASSERT(m_eSolenoidType == DOUBLE_3WAY_SOLENOID);	//중간정지..3way sv...

	BOOL bDir;	// 중간 정지 이동 방향 : 현재 위치가 Middle 이 아니므로 이동 방향은 반드시 True/False 로 결정된다.
	if (IsDown())	//Down Check
	{
		bDir = TRUE;
		Up();		// Down 상태이면 Up() 
	}
	else	// Down 상태가 아니다.
	{
		if (IsUp())	//Up Check
		{
			bDir = FALSE;
			Down();		// Up 상태이면 Down() 
		}
		else	// Down 상태도 아니고 Up상태도 아니다.
		{
			// 101004 = Cylinder position is invalid.
			return generateErrorCode(101004);
		}
	}
	
	if (skip_sensor)	// 센서를 체크하지 않으면 바로 리턴 한다.
	{
		Sleep(0);
		return ERR_CYLINDER_SUCCESS;
	}
	
	return Wait4MiddleComplete(bDir);
}

//--------------- Left / Right -------------

int MCylinder::Left(int skip_sensor)
{
    return Up(skip_sensor);
}

int MCylinder::Right(int skip_sensor)
{
    return Down(skip_sensor);
}

//--------------- Front / Back -------------

int MCylinder::Front(int skip_sensor)
{
    return Up(skip_sensor);
}

int MCylinder::Back(int skip_sensor)
{
    return Down(skip_sensor);
}

//--------------- Downstr / Upstr -------------

int MCylinder::Downstr(int skip_sensor)
{
    return Down(skip_sensor);
}

int MCylinder::Upstr(int skip_sensor)
{
    return Up(skip_sensor);
}

//--------------- CW / CCW -------------

int MCylinder::CW(int skip_sensor)
{
    return Up(skip_sensor);
}

int MCylinder::CCW(int skip_sensor)
{
    return Down(skip_sensor);
}

//--------------- Open / Close -------------

int MCylinder::Open(int skip_sensor)
{
    return Up(skip_sensor);
}

int MCylinder::Close(int skip_sensor)
{
    return Down(skip_sensor);
}

//--------------- Expand / Shrink -------------

int MCylinder::Expand(int skip_sensor)
{
    return Up(skip_sensor);
}

int MCylinder::Shrink(int skip_sensor)
{
    return Down(skip_sensor);
}

int MCylinder::OutputToggle()
{
	switch (m_eSolenoidType)
    {
    case SINGLE_SOLENOID:		
    case REVERSE_SINGLE_SOLENOID:
		m_gpIIO->OutputToggle(m_rgusSolenoid[0]);
        break;
    case DOUBLE_SOLENOID:
    case DOUBLE_3WAY_SOLENOID:
    case DOUBLE_SOLENOID_VARIOUS_VELOCITY:
		if (m_gpIIO->IsOn(m_rgusSolenoid[0]) && m_gpIIO->IsOff(m_rgusSolenoid[1]))
		{
			m_gpIIO->OutputOff(m_rgusSolenoid[0]);
			m_gpIIO->OutputOn(m_rgusSolenoid[1]);
		}
		else if (m_gpIIO->IsOn(m_rgusSolenoid[1]) && m_gpIIO->IsOff(m_rgusSolenoid[0]))
		{
			m_gpIIO->OutputOff(m_rgusSolenoid[1]);
			m_gpIIO->OutputOn(m_rgusSolenoid[0]);
		}
		else
		{
			m_gpIIO->OutputOff(m_rgusSolenoid[0]);
			m_gpIIO->OutputOn(m_rgusSolenoid[1]);
		}
        break;
    default:
        break;
    }
    return ERR_CYLINDER_SUCCESS;
}

/*----------- 실린더 이동 시작  -----------------------*/
/**
* Cylinder를 Up으로 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartUp()
{
	return Up(TRUE);
}

/**
* Cylinder를 Down으로 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartDown()
{
	return Down(TRUE);
}

/**
* Cylinder를 Left로 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartLeft()
{
	return Up(TRUE);
}

/**
* Cylinder를 Right로 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartRight()
{
	return Down(TRUE);
}

/**
* Cylinder를 Front로 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartFront()
{
	return Up(TRUE);
}

/**
* Cylinder를 Back으로 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartBack()
{
	return Down(TRUE);
}

/**
* Cylinder를 Downstr으로 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartDownstr()
{
	return Up(TRUE);
}

/**
* Cylinder를 Upstr으로 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartUpstr()
{
	return Down(TRUE);
}

/**
* Cylinder를 CW로 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartCW()
{
	return Up(TRUE);
}

/**
* Cylinder를 CCW으로 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartCCW()
{
	return Down(TRUE);
}

/**
* Cylinder를 Open으로 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartOpen()
{
	return Up(TRUE);
}

/**
* Cylinder를 Close으로 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartClose()
{
	return Down(TRUE);
}

/**
* Cylinder를 중간 위치에서 정지 시킨다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartMiddle()	//중간정지..3way sv만허용...
{
     return Middle(TRUE);
}

/**
* Cylinder Expand 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartExpand()
{
	return Up(TRUE);
}

/**
* Cylinder Shrink 이동을 시작한다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::StartShrink()
{
	return Down(TRUE);
}


/*----------- 실린더 동작완료때까지 Sleep   -----------------------*/

/**
* Cylinder가 Up 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4UpComplete()
{
#ifdef SIMULATION
	try
	{
		EnterCriticalSection(&m_csSimul);
	}
	catch (CException* e)
	{
		TRACE0("EXCEPTION\n");

		// Handle the exception here.
		// "e" contains information about the exception.
		e->Delete();
	}

	if (TRUE == m_bSimulUpState)
	{
		m_tmSimulTimer.StopTimer();
		m_bSimulDownState = FALSE;
		m_bCylinderOnBeingUpState = FALSE;
		m_bCylinderOnBeingMiddleState = FALSE;
		m_bCylinderOnBeingDownState = FALSE;
		LeaveCriticalSection(&m_csSimul);
		return ERR_CYLINDER_SUCCESS;
	}

	// 다른 방향으로 움직이고 있는 경우.
	if (FALSE == m_bCylinderOnBeingUpState)
	{
		LeaveCriticalSection(&m_csSimul);
		return ERR_CYLINDER_SUCCESS;
	}

	if (m_rgusUpSensor[0] != 0)	// 센서가 지정되어 있음
	{
		if (TRUE == m_tmSimulTimer.IsTimerStarted())
		{
			LeaveCriticalSection(&m_csSimul);

			ASSERT(m_CylParameter.m_dSimulationTime >= 0.0);
			while (m_tmSimulTimer.LessThan(m_CylParameter.m_dSimulationTime))
			{
				Sleep(1);
			}

			try
			{
				EnterCriticalSection(&m_csSimul);
			}
			catch (CException* e)
			{
				TRACE0("EXCEPTION\n");
				
				// Handle the exception here.
				// "e" contains information about the exception.
				e->Delete();
			}

			// Up 도중 다른 동작 명령 시작된 경우.
			if (TRUE == m_bCylinderOnBeingMiddleState || TRUE == m_bCylinderOnBeingDownState)
			{
				LeaveCriticalSection(&m_csSimul);
				return ERR_CYLINDER_SUCCESS;
			}
		}
	}
	else
	{
		Sleep(UINT(m_CylParameter.m_dNoSenMovingTime * 1000));
	}

	m_tmSimulTimer.StopTimer();
	m_bSimulUpState = TRUE;
	m_bSimulDownState = FALSE;
	m_bCylinderOnBeingUpState = FALSE;
	m_bCylinderOnBeingMiddleState = FALSE;
	m_bCylinderOnBeingDownState = FALSE;
	LeaveCriticalSection(&m_csSimul);
	return ERR_CYLINDER_SUCCESS;
#endif

	MTickTimer CylinderTimer;
	CylinderTimer.StartTimer();

    if (m_rgusUpSensor[0] != 0)	// 센서가 지정되어 있음
    {
		while (TRUE)
	    {
			// IO 동작이 완료 되었는지 체크한다.
			if (IsUp())
				break;

			// Cylinder Timeout 을 체크함
	        if (CylinderTimer.MoreThan(m_CylParameter.m_dMovingTime))
	        {
				switch (m_eSolenoidType)
				{
				case SINGLE_SOLENOID:
				case REVERSE_SINGLE_SOLENOID:
					break;
				case DOUBLE_SOLENOID:
				case DOUBLE_3WAY_SOLENOID:
					m_gpIIO->OutputOff(m_rgusSolenoid[0]);
					break;
				case DOUBLE_SOLENOID_VARIOUS_VELOCITY:
					m_gpIIO->OutputOff(m_rgusSolenoid[0]);
					m_gpIIO->OutputOff(m_rgusAccSolenoid[0]);
					break;
				default:
					break;
				}
				// 101001 = Cylinder 동작 시간을 초과하였습니다. [첫번째 동작]
                return generateErrorCode(101001);
	        }

            // Decel Sol On
            if (m_eSolenoidType == DOUBLE_SOLENOID_VARIOUS_VELOCITY)
            {
				if (m_gpIIO->IsOn(m_rgusAccSensor[0]))
					m_gpIIO->OutputOn(m_rgusAccSolenoid[0]);
            }
	        Sleep(5);
	    }
	}
    // Sensor가 없을때는 Delay 처리
	else
	{
        Sleep(UINT(m_CylParameter.m_dNoSenMovingTime * 1000));
		if (m_rgusDownSensor[0] != NULL)
		{
			if (m_gpIIO->IsOn(m_rgusDownSensor[0]))
				// 101001 = Cylinder 동작 시간을 초과하였습니다. [첫번째 동작]
				return generateErrorCode(101001);
		}
	}

    // MCylinder 동작완료를 위한 Delay
	Sleep(UINT(m_CylParameter.m_dSettlingTime1 * 1000));

    // 단동식이 아닐 경우 Solenoid Off
    if (m_eSolenoidType == DOUBLE_SOLENOID)
		m_gpIIO->OutputOff(m_rgusSolenoid[0]);

    // 감속 Solenoid Off
    if (m_eSolenoidType == DOUBLE_SOLENOID_VARIOUS_VELOCITY)
		m_gpIIO->OutputOff(m_rgusAccSolenoid[0]);

	m_dUpElapseTime = m_tmUpTimer.GetElapseTime();

    return ERR_CYLINDER_SUCCESS;
}

/**
* Cylinder가 Down 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4DownComplete()
{
#ifdef SIMULATION
	try
	{
		EnterCriticalSection(&m_csSimul);
	}
	catch (CException* e)
	{
		TRACE0("EXCEPTION\n");

		// Handle the exception here.
		// "e" contains information about the exception.
		e->Delete();
	}

	if (TRUE == m_bSimulDownState)
	{
		m_tmSimulTimer.StopTimer();
		m_bSimulUpState = FALSE;
		m_bCylinderOnBeingUpState = FALSE;
		m_bCylinderOnBeingMiddleState = FALSE;
		m_bCylinderOnBeingDownState = FALSE;
		LeaveCriticalSection(&m_csSimul);
		return ERR_CYLINDER_SUCCESS;
	}

	// 다른 방향으로 움직이고 있는 경우.
	if (FALSE == m_bCylinderOnBeingDownState)
	{
		LeaveCriticalSection(&m_csSimul);
		return ERR_CYLINDER_SUCCESS;
	}

	if (m_rgusDownSensor[0] != 0)	// 센서가 지정되어 있음
	{
		if (m_tmSimulTimer.IsTimerStarted())
		{
			LeaveCriticalSection(&m_csSimul);

			ASSERT(m_CylParameter.m_dSimulationTime >= 0.0);
			while (m_tmSimulTimer.LessThan(m_CylParameter.m_dSimulationTime))
			{
				Sleep(1);
			}

			try
			{
				EnterCriticalSection(&m_csSimul);
			}
			catch (CException* e)
			{
				TRACE0("EXCEPTION\n");
				
				// Handle the exception here.
				// "e" contains information about the exception.
				e->Delete();
			}

			// Down 도중 다른 동작 명령 시작된 경우.
			if (TRUE == m_bCylinderOnBeingUpState || TRUE == m_bCylinderOnBeingMiddleState)
			{
				LeaveCriticalSection(&m_csSimul);
				return ERR_CYLINDER_SUCCESS;
			}
		}
	}
	else
	{
		Sleep(UINT(m_CylParameter.m_dNoSenMovingTime*1000));
	}

	m_tmSimulTimer.StopTimer();

	m_bSimulUpState = FALSE;
	m_bSimulDownState = TRUE;
	
	m_bCylinderOnBeingUpState = FALSE;
	m_bCylinderOnBeingMiddleState = FALSE;
	m_bCylinderOnBeingDownState = FALSE;

	LeaveCriticalSection(&m_csSimul);
	return ERR_CYLINDER_SUCCESS;
#endif

	MTickTimer CylinderTimer;
	CylinderTimer.StartTimer();

    if (m_rgusDownSensor[0] != 0)
    {
		while (TRUE)
	    {
			// IO 동작이 완료 되었는지 체크한다.
			if (IsDown()) 
				break; // IO 동작이 완료 되었음

	        if (CylinderTimer.MoreThan(m_CylParameter.m_dMovingTime))
	        {
				switch (m_eSolenoidType)
				{
				case SINGLE_SOLENOID:
				case REVERSE_SINGLE_SOLENOID:
					break;
				case DOUBLE_SOLENOID:
				case DOUBLE_3WAY_SOLENOID:
					m_gpIIO->OutputOff(m_rgusSolenoid[1]);
					break;
				case DOUBLE_SOLENOID_VARIOUS_VELOCITY:
					m_gpIIO->OutputOff(m_rgusSolenoid[1]);
					m_gpIIO->OutputOff(m_rgusAccSolenoid[1]);
					break;
				default:
					break;
				}
				// 101002 = Cylinder 동작 시간을 초과하였습니다. [두번째 동작]
                return generateErrorCode(101002);
	        }
            // Decel Sol On
            if (m_eSolenoidType == DOUBLE_SOLENOID_VARIOUS_VELOCITY)
            {
				if (m_gpIIO->IsOn(m_rgusAccSensor[1]))
					m_gpIIO->OutputOn(m_rgusAccSolenoid[1]);
            }
	        Sleep(5);
	    }
	}
    // Sensor가 없을때는 Delay 처리
	else
	{
        Sleep(UINT(m_CylParameter.m_dNoSenMovingTime * 1000));
		if (m_rgusUpSensor[0] != NULL)
		{
			if (m_gpIIO->IsOn(m_rgusUpSensor[0]))
			{
				// 101002 = Cylinder 동작 시간을 초과하였습니다. [두번째 동작]
				return generateErrorCode(101002);
			}
		}
	}

    // MCylinder 동작완료를 위한 Delay
	Sleep(UINT(m_CylParameter.m_dSettlingTime2 * 1000));

    // Sol Off
    if (m_eSolenoidType == DOUBLE_SOLENOID)
		m_gpIIO->OutputOff(m_rgusSolenoid[1]);

    // Decel Sol Off
    if (m_eSolenoidType == DOUBLE_SOLENOID_VARIOUS_VELOCITY)
		m_gpIIO->OutputOff(m_rgusAccSolenoid[1]);

	m_dDownElapseTime = m_tmDownTimer.GetElapseTime();

    return ERR_CYLINDER_SUCCESS;
}

/**
* Cylinder가 Middle Point 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4MiddleComplete(BOOL bDir)
{
#ifdef SIMULATION
	try
	{
		EnterCriticalSection(&m_csSimul);
	}
	catch (CException* e)
	{
		TRACE0("EXCEPTION\n");

		// Handle the exception here.
		// "e" contains information about the exception.
		e->Delete();
	}

	if (FALSE == m_bSimulUpState && FALSE == m_bSimulDownState)
	{
		m_tmSimulTimer.StopTimer();
		m_bCylinderOnBeingUpState = FALSE;
		m_bCylinderOnBeingMiddleState = FALSE;
		m_bCylinderOnBeingDownState = FALSE;
		LeaveCriticalSection(&m_csSimul);
		return ERR_CYLINDER_SUCCESS;
	}

	// 다른 방향으로 움직이고 있는 경우.
	if (FALSE == m_bCylinderOnBeingMiddleState)
	{
		LeaveCriticalSection(&m_csSimul);
		return ERR_CYLINDER_SUCCESS;
	}

	if (m_rgusMiddleSensor[0] != 0)	// 센서가 지정되어 있음
	{
		if (m_tmSimulTimer.IsTimerStarted())
		{
			LeaveCriticalSection(&m_csSimul);

			ASSERT(m_CylParameter.m_dSimulationTime >= 0.0);
			while (m_tmSimulTimer.LessThan(m_CylParameter.m_dSimulationTime))
			{
				Sleep(1);
			}

			try
			{
				EnterCriticalSection(&m_csSimul);
			}
			catch (CException* e)
			{
				TRACE0("EXCEPTION\n");
				
				// Handle the exception here.
				// "e" contains information about the exception.
				e->Delete();
			}

			// Middle 도중 다른 동작 명령 시작된 경우.
			if (TRUE == m_bCylinderOnBeingUpState || TRUE == m_bCylinderOnBeingDownState)
			{
				LeaveCriticalSection(&m_csSimul);
				return ERR_CYLINDER_SUCCESS;
			}
		}
	}
	else
	{
		Sleep(UINT(m_CylParameter.m_dNoSenMovingTime*1000));
	}

	m_tmSimulTimer.StopTimer();

	m_bSimulUpState = FALSE;
	m_bSimulDownState = FALSE;
	
	m_bCylinderOnBeingUpState = FALSE;
	m_bCylinderOnBeingMiddleState = FALSE;
	m_bCylinderOnBeingDownState = FALSE;

	LeaveCriticalSection(&m_csSimul);
	return ERR_CYLINDER_SUCCESS;
#endif

	MTickTimer CylinderTimer;
	CylinderTimer.StartTimer();

	ASSERT(m_eSolenoidType == DOUBLE_3WAY_SOLENOID);

	while (IsMiddle() == FALSE)
    {
        if (CylinderTimer.MoreThan(m_CylParameter.m_dMovingTime))	// Timeout 체크
        {
			m_gpIIO->OutputOff(m_rgusSolenoid[0]);
			m_gpIIO->OutputOff(m_rgusSolenoid[1]);
			// 101003 = Cylinder 동작 시간을 초과하였습니다. [세번째 동작]
            return generateErrorCode(101003);
        }
        Sleep(5);
    }

	m_gpIIO->OutputOff(m_rgusSolenoid[0]);
	m_gpIIO->OutputOff(m_rgusSolenoid[1]);

	if (bDir)
		Sleep(UINT(m_CylParameter.m_dSettlingTime1 * 1000));	// Cylinder 동작 완료 Delay
	else	
		Sleep(UINT(m_CylParameter.m_dSettlingTime2 * 1000));

    return ERR_CYLINDER_SUCCESS;
}

/**
* Cylinder가 Left 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4LeftComplete()
{
	return(Wait4UpComplete());
}

/**
* Cylinder가 Right 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4RightComplete()
{
	return(Wait4DownComplete());
}

/**
* Cylinder가 Front 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4FrontComplete()
{
	return(Wait4UpComplete());
}

/**
* Cylinder가 Back 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4BackComplete()
{
	return(Wait4DownComplete());
}

/**
* Cylinder가 CW 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4CWComplete()
{
	return(Wait4UpComplete());
}

/**
* Cylinder가 CCW 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4CCWComplete()
{
	return(Wait4DownComplete());
}

/**
* Cylinder가 Open 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4OpenComplete()
{
	return(Wait4UpComplete());
}

/**
* Cylinder가 Close 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4CloseComplete()
{
	return(Wait4DownComplete());
}

/**
* Cylinder가 Downstr 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4DownstrComplete()
{
	return(Wait4UpComplete());
}

/**
* Cylinder가 Upstr 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4UpstrComplete()
{
	return(Wait4DownComplete());
}

/**
* Cylinder가 Expand 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4ExpandComplete()
{
	return(Wait4UpComplete());
}

/**
* Cylinder가 Shrink 동작이 완료될때까지 기다린다.
* @return 0 = Success, 그 외 = Error
*/
int MCylinder::Wait4ShrinkComplete()
{
	return(Wait4DownComplete());
}

/**
 * Solenoid을 Off한다.
 *
 * @param   bDir : TRUE -> 1동작, FALSE -> 2동작
 */
void MCylinder::OffSolenoid(BOOL bDir)
{
	switch (m_eSolenoidType)
	{
	case SINGLE_SOLENOID:
	case REVERSE_SINGLE_SOLENOID:
		// Single Solenoid는 Solenoid를 Off 할 수 없다.
		break;
	case DOUBLE_SOLENOID:
	case DOUBLE_3WAY_SOLENOID:
		if (bDir)
			m_gpIIO->OutputOff(m_rgusSolenoid[0]);
		else	
			m_gpIIO->OutputOff(m_rgusSolenoid[1]);
		break;
	case DOUBLE_SOLENOID_VARIOUS_VELOCITY:
		if (bDir)
		{
			m_gpIIO->OutputOff(m_rgusSolenoid[0]);
			m_gpIIO->OutputOff(m_rgusAccSolenoid[0]);	// 감속센서 Disable
		}
		else
		{
			m_gpIIO->OutputOff(m_rgusSolenoid[1]);
			m_gpIIO->OutputOff(m_rgusAccSolenoid[1]);	// 감속센서 Disable
		}
		break;
	default:
		break;
	}
}

/**
 * 모든 Solenoid를 Off한다.
 */
void MCylinder::OffSolenoid()
{
	switch (m_eSolenoidType)
	{
	case SINGLE_SOLENOID:
	case REVERSE_SINGLE_SOLENOID:
		// Single Solenoid는 Solenoid를 Off 할 수 없다.
		break;
	case DOUBLE_SOLENOID:
	case DOUBLE_3WAY_SOLENOID:
		m_gpIIO->OutputOff(m_rgusSolenoid[0]);
		m_gpIIO->OutputOff(m_rgusSolenoid[1]);
		break;
	case DOUBLE_SOLENOID_VARIOUS_VELOCITY:
		m_gpIIO->OutputOff(m_rgusSolenoid[0]);
		m_gpIIO->OutputOff(m_rgusSolenoid[1]);
		m_gpIIO->OutputOff(m_rgusAccSolenoid[0]);
		m_gpIIO->OutputOff(m_rgusAccSolenoid[1]);
		break;
	default:
		break;
	}
}

/**
 * 실린더 동작 완료를 확인한다.
 *
 * @param   bDir  : TRUE -> 1동작, FALSE -> 2동작
 * @return  TRUE  : 동작완료 확인
            FALSE : 동작완료 확인 안됨
 */
BOOL MCylinder::IsMoveComplete(BOOL bDir)
{
	unsigned short usSensor,usSensorDecel,usSolDecel;

	// 방향에 따라 확인해야 될 센서 지정
	if (bDir)
	{
		usSensor = m_rgusUpSensor[0];
		usSensorDecel = m_rgusAccSensor[0];
		usSolDecel = m_rgusSolenoid[0];
	}
	else
	{
		usSensor = m_rgusDownSensor[1];
		usSensorDecel = m_rgusAccSensor[1];
		usSolDecel = m_rgusAccSolenoid[1];
	}

	// Decel Sol On
	if (m_eSolenoidType == DOUBLE_SOLENOID_VARIOUS_VELOCITY)
	{
		if (usSensorDecel)
			if (m_gpIIO->IsOn(usSensorDecel))
				m_gpIIO->OutputOn(usSolDecel);
	}

    if (usSensor != 0)	// 센서를 지정하지 않을 수도 있음
    {
		return	m_gpIIO->IsOn(usSensor);
	}

    return TRUE;
}

/**
 * Assign component linkage
 * 
 * @param	pIO	: 참조할 IO Component Pointer
 */
int MCylinder::AssignComponents(IIO *pIO)
{
	ASSERT(pIO != NULL);

	m_gpIIO = pIO;
		
	return ERR_CYLINDER_SUCCESS;
}

/** 
 * Component Data 처리 
 *
 * @param	datComponent : 기록할 데이타
 * @return	Error : 0 = Success, 그외=기타
 */
int MCylinder::SetData(SCylinderData datComponent)
{
	m_iCylID = datComponent.m_sCylVal.m_iCylID;
	m_strCylName.Format(_T("%s"), datComponent.m_sCylVal.m_szName);

	for (int i = 0; i < 2; i++)
	{
		m_rgusSolenoid[i] = datComponent.m_sCylVal.m_rgusSolenoid[i];
		m_rgusAccSolenoid[i] = datComponent.m_sCylVal.m_rgusAccSolenoid[i];
		m_rgusAccSensor[i] = datComponent.m_sCylVal.m_rgusAccSensor[i];
	}

	for (int i = 0; i < DEF_MAX_CYLINDER_SENSOR; i++)
	{
		m_rgusUpSensor[i] = datComponent.m_sCylVal.m_rgusUpSensor[i];
		m_rgusDownSensor[i] = datComponent.m_sCylVal.m_rgusDownSensor[i];
		m_rgusMiddleSensor[i] = datComponent.m_sCylVal.m_rgusMiddleSensor[i];
	}

	m_eCylinderType = datComponent.m_sCylVal.m_lnkECylinderType;
	m_eSolenoidType = datComponent.m_sCylVal.m_lnkESolenoidType;

	m_strFileName = datComponent.m_strFileName;

	return ERR_CYLINDER_SUCCESS;
}

/** 
 * Component Data 읽어올 데이타 인터 
 *
 * @param	datComponent : MCylinderData Class에 대한 포인터
 * @return	Error : 0 = Success, 그외=기타
 */
int MCylinder::GetData(SCylinderData* datComponent)
{
	for (int i = 0; i < 2; i++)
	{
		 datComponent->m_sCylVal.m_rgusSolenoid[i] = m_rgusSolenoid[i];
		 datComponent->m_sCylVal.m_rgusAccSolenoid[i] = m_rgusAccSolenoid[i];
		 datComponent->m_sCylVal.m_rgusAccSensor[i] = m_rgusAccSensor[i];
	}

	for (int i = 0; i < DEF_MAX_CYLINDER_SENSOR; i++)
	{
		 datComponent->m_sCylVal.m_rgusUpSensor[i] = m_rgusUpSensor[i];
		 datComponent->m_sCylVal.m_rgusDownSensor[i] = m_rgusDownSensor[i];
		 datComponent->m_sCylVal.m_rgusMiddleSensor[i] = m_rgusMiddleSensor[i];
	}

	datComponent->m_sCylVal.m_lnkECylinderType = m_eCylinderType;
	datComponent->m_sCylVal.m_lnkESolenoidType = m_eSolenoidType;

	datComponent->m_strFileName = m_strFileName;
	return ERR_CYLINDER_SUCCESS;
}

/**
 * Cylinder 관련 Data를 File에서 읽어온다.
 *
 * @param	pcylTimerData (읽어올 Data가 저장될 변수)
 * @return	int (0 = Success, Error Code = 그 외)
 */
int MCylinder::LoadParameter()
{
	BOOL bResult;

	MCylinderData cylTimerData(m_strCylName, m_strFileName);

	bResult = cylTimerData.ReadData();
	m_CylParameter = cylTimerData;

	if (!bResult)
	{
		// 101005 = Cylinder parameter road failure
		return generateErrorCode(101005);
	}	

	return ERR_CYLINDER_SUCCESS;
}

/**
 * Cylinder 관련 Data를 File에 저장한다.
 *
 * @param	pcylTimerData (저장할 Data)
 * @return	int (0 = Success, Error Code = 그 외)
 */
int MCylinder::SaveParameter(MCylinderData* pcylTimerData)
{	
	BOOL bResult;

	MCylinderData cylTimerData(m_strCylName, m_strFileName);

	m_CylParameter = *pcylTimerData;

	cylTimerData =  m_CylParameter;
	
	bResult = cylTimerData.WriteData();
	if (!bResult)
	{
		// 101006 = Cylinder parameter save failure
		return generateErrorCode(101006);
	}

	return ERR_CYLINDER_SUCCESS;
}

/**
 * Cylinder 관련 Data를 얻어 온다.
 *
 * @param	pcylTimerData (읽어올 Data가 저장될 변수)
 */
void MCylinder::GetParameter(MCylinderData* pcylParameter)
{
	*pcylParameter = m_CylParameter;
}

/**
 * Cylinder 이름을 Return 한다.
 * @return : Cylinder Name
 */
CString MCylinder::GetCylinderName()
{
	return m_strCylName;
}

/** 
 * Cylinder의 UP동작 시간을 Return한다.
 * @return : UP elapse Time
 */
double MCylinder::GetUpElapseTime()
{
	return m_dUpElapseTime;
}

/** 
 * Cylinder의 DOWN동작 시간을 Return한다.
 * @return : DOWN elapse Time
 */
double MCylinder::GetDownElapseTime()
{
	return m_dDownElapseTime;
}

/**
 * Cylinder SolValve 배열을 리턴한다.
 */
unsigned short* MCylinder::GetSolAddr()
{
	return m_rgusSolenoid;
}

/**
 * Cylinder Up Sensor 배열을 리턴한다.
 */
unsigned short* MCylinder::GetUpSensorAddr()
{
	return m_rgusUpSensor;
}

/**
 * Cylinder Down Sensor 배열을 리턴한다.
 */
unsigned short* MCylinder::GetDownSensorAddr()
{
	return m_rgusDownSensor;
}
/* End Of Code */