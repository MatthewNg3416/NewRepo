/* Generated by Together */
/* written by jsMoon on 2004.03.17 */

#ifndef MHILSCHERDNET_H
#define MHILSCHERDNET_H

#include "IIO.h"

#define INPUT_ORIGIN		1000
#define OUTPUT_ORIGIN		2000
#define OUTPUT_END			3000

#define MAX_EXPLICIT_LEN	239

//#define DEF_ID_SUCCESS		0
#define ERROR_ID			-1

#define TRUE				1
#define FALSE				0

const BYTE highbitsMask[8] =
{
	0x00,  //0000 0000
	0x01,  //0000 0001
	0x03,  //0000 0011
	0x07,  //0000 0111
	0x0F,  //0000 1111
	0x1F,  //0001 1111
	0x3F,  //0011 1111
	0x7F,  //0111 1111
};

const BYTE lowbitsMask[8] =
{
	0xFE,  //1111 1110
	0xFC,  //1111 1100
	0xF8,  //1111 1000
	0xF0,  //1111 0000
	0xE0,  //1110 0000
	0xC0,  //1100 0000
	0x80,  //1000 0000
	0x00,  //0000 0000
};

typedef
/**
* Devicenet의 Master와 Slave의 상태를 Devicenet 모듈로 부터 읽어오기 위한 데이타 구조체이다. 
*/
struct DNM_DIAGNOSTICStag
{
	/** bit field to show network and DEVICE main errors */
	struct  GLOBAL_BITS
	{
		unsigned char bCtrl     : 1; /* wrong parameterization                  */
		unsigned char bAClr     : 1; /* auto_clear activated                    */
		unsigned char bNonExch  : 1; /* no data exchange to at least on station */
		unsigned char bFatal    : 1; /* fatal error occured                     */
		unsigned char bEvent    : 1; /* bus error events occured                */
		unsigned char bNRdy     : 1; /* host program not ready                  */
		unsigned char bDupMAC   : 1; /* duplicate MAC id detected check failed  */
		unsigned char bPerDup   : 1; /* duplicate MAC Id check active           */
	} bGlobalBits;
	
	/** global state for the different DEVICE main states */
	unsigned char   bDNM_state;

	#define OFFLINE  0x00
	#define STOP     0x40
	#define CLEAR    0x80
	#define OPERATE  0xC0
	
	/** location of error and error code */
	struct T_ERRORS
	{
		unsigned char bErrDevAdr; /* 0-63, 255 */
		#define MST_ERR  0xFF
		
		unsigned char bErrEvent;   /* see #defines */
		
		/* DEVICE internal errors */
		
		#define TASK_F_UNKNOWN_MODE                     52 /* unknown handshake mode configured */
		#define TASK_F_BAUDRATE_OUT_RANGE               53 /* configured batudrate not supported */
		#define TASK_F_OWN_MAC_ID_OUT_RANGE             54 /* DEVICE MAC-ID out of range */
		#define TASK_F_DUPLICATE_MAC_ID                 57 /* a duplicate MAC-ID detected */
		#define TASK_F_NO_DEV_TAB                       58 /* data base in the DEVICE has no entries included */
		#define TASK_F_ADR_DOUBLE                       59 /* double MAC-ID configured internally */
		#define TASK_F_DATA_SET_FIELD_LEN               60 /* size of one device data set invalid */
		#define TASK_F_PRED_MST_SL_ADD_LEN              61 /* offset table for predef.mst slave conn. invalid */
		#define TASK_F_PRED_MSTSL_CFG_FIELD_LEN         62 /* configur. table length for predef.mst.slave conn. invalid */
		#define TASK_F_PRED_MST_SL_ADD_TAB_INCONS       63 /* offset table do not correspond to I/O configuration table */
		#define TASK_F_EXPL_PRM_FIELD_LEN               64 /* size indicator of parameter data table corrupt */
		#define TASK_F_PRED_MSTSL_CFG_ADD_INPUT_INCONS  65 /* num of inputs in add tab not equal I/O configuration */
		#define TASK_F_PRED_MSTSL_CFG_ADD_OUTPUT_INCONS 66 /* num of outputs in add tab not equal I/O configuration */
		#define TASK_F_UNKNOWN_DATA_TYPE                67 /* unknown data type in I/O configuration */
		#define TASK_F_MODULE_DATA_SIZE                 68 /* data type does not correspond to its configured length */
		#define TASK_F_OUTPUT_OFF_RANGE                 69 /* configured output offset address out of range */
		#define TASK_F_INPUT_OFF_RANGE                  70 /* configured input offset address out of */
		#define TASK_F_WRONG_TYPE_OF_CONNECTION         71 /* one predefined connection type is unknown */
		#define TASK_F_TYPE_CONNECTION_REDEFINITION     72 /* multiple connections defined in parallel */
		#define TASK_F_EXP_PACKET_LESS_PROD_INHIBIT     73 /* configured EXP_PCKT_RATE less then PROD_INHIBIT_TIME */
		#define TASK_F_PRM_FIELD_LEN_INCONSISTENT       74 /* parameter field DNM_SET_ATTR_DATA in data set inconsitent */
		#define TASK_F_NO_CAN                           75 /* no device responding on CAN network at cfg.baudrate */
		#define TASK_F_REG_FRAG_TIMEOUT_OUT_OF_RANGE    76 /* usRegFragTimeout out of range */
		
	} tError;
	
	/** counter for the bus error events */
	unsigned short  usBus_Error_Cnt;
	
	/** counter of bus off reports of the CAN chip */
	unsigned short  usBus_Off_Cnt;
	
	/** reserved area */
	struct SVR_STATUS
	{
		unsigned char bSrvExpl   : 1; /* server explicit connection established */
		unsigned char bSrvIO     : 1; /* server I/O poll connection established */
		unsigned char bReserved  : 6; /* reserved bits */
	} bSrvStatus;

	#define SRV_EXPL 0x01
	#define SRV_IO   0x02
	
	unsigned char   abReserved[7];
	
	/* Bit-Ready, Cfg-Ready and diagnostic display of the devices */
	/** device configuration area */
	unsigned char   abDv_cfg  [16];  /* device configuration area */
	/** device state information area */
	unsigned char   abDv_state[16];  /* device state information area */
	/** device diagnostic area */
	unsigned char   abDv_diag [16];  /* device diagnostic area */
	
} DNM_DIAGNOSTICS;

class MHilscherDnet : public IIO
{
private:
    /** Board number (0..3)   */
    unsigned short m_usBoardNumber;
	
    /**
	* Device가 Open 되었는지를 확인하는 Flag
	* : m_BDeviceOpened = TRUE if it is opened;
	*   m_BDeviceOpened = FALSE if it is not opened.
	*/
    BOOL m_bDeviceOpened;
	
    /** I/O Device의 status가 Update되는 배열 */
    BYTE m_ucOutgoingBuffer[MAX_DEVICE * 4];
	
    /** I/O Device에 적용될 Digital Command를 담고있는 배열 */
	BYTE m_ucIncomingBuffer[MAX_DEVICE * 4];
	
	/* Device의 상태 정보를 저장한 영역 */
	DN_STATUS m_tblDnStatus;
	
	LPDWORD m_lpthreadID;
	HANDLE m_hHandle;

	BYTE m_bMsgId;

	/**	Input IO Table */
	SIOTABLE InputIOTable[INPUT_MAX_NUM_ADDRESS];
	
	/**	Output IO Table	 */
	SIOTABLE OutputIOTable[OUTPUT_MAX_NUM_ADDRESS];

	CRITICAL_SECTION m_csOutput;
	
public:
	MHilscherDnet();
	
	MHilscherDnet( SCommonAttribute commonData, unsigned short	usBoardNumber = 0 );
	
	MHilscherDnet(unsigned short usBoardNumber);
	
	virtual ~MHilscherDnet();
	
    int Initialize();
	
	int GetBit(unsigned short usIOAddr, BOOL* pbval);
	
    int Terminate();
	
    BOOL IsOn(unsigned short usIOAddr);
	
    BOOL IsOff(unsigned short usIOAddr);
	
    int OutputOn(unsigned short usIOAddr);
	
    int OutputOff(unsigned short usIOAddr);
	
    int OutputToggle(unsigned short usIOAddr);
	
    int GetByte(unsigned short usIOAddr, BYTE & pcValue);
	
    int PutByte(unsigned short usIOAddr, BYTE pcValue);
	
    int GetWord(unsigned short usIOAddr, WORD & pwValue);
	
    int PutWord(unsigned short usIOAddr, WORD pwValue);
	
    int GetBit(CString strIOAddr, BOOL* pbVal);
	
    int IsOn(CString strIOAddr, BOOL* pbVal);
	
    int IsOff(CString strIOAddr, BOOL* pbVal);
	
    int OutputOn(CString strIOAddr);
	
    int OutputOff(CString strIOAddr);
	
    int OutputToggle(CString strIOAddr);
	
    int GetByte(CString strIOAddr, BYTE & pcValue);
	
    int PutByte(CString strIOAddr, BYTE pcValue);
	
    int GetWord(CString strIOAddr, WORD & pwValue);
	
    int PutWord(CString strIOAddr, WORD pwValue);
	
    void RunIOThread();
	
	int DnStatusGet(DN_STATUS DnStatus);
	
	int	GetIOTable(SIOTABLE* Input, SIOTABLE* Output);
	
	int LoadIOMap(CString strFileName = "IO.Dat");

	int SendExplicitMsg(MSG_ID_STRUC* psMsgID, MSG_STRUC* psReceiveMsg);
	
	//110613.KKY_____
	int UpdateIO();
	//_______________
private:
    int IOAddrInterpreter(CString strIOAddr, unsigned short & usIOAddr);
	
	UINT IOThread(LPVOID lParam);
	
	static DWORD WINAPI EntryPoint(LPVOID pParam);
	
	int dnStatusCheck(unsigned char ucMacID = 0xff);
	
	int returnDnetStatus();

	BYTE getMessageId(void);

	int setExplicitErrMessage(unsigned char revF);
};
#endif //MHILSCHERDNET_H
