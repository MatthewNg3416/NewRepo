/* Generated by Together */
#include "stdafx.h"
#include "MFileManager.h"

#include "MPlatformOlbSystem.h"
#include "MLCNet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


extern MPlatformOlbSystem	MOlbSystemPre;

// Data File 이 정상적으로 생성되지 않았을 경우, 이로 인한 File Read Error 를 무시하기 위한 Option.
//#define DEF_IGNORE_FILE_READ_ERROR

BOOL MFileManager::m_bResizeFile = FALSE;

MFileManager::MFileManager(CString strFileName)
{
/*	CreateDirectory(_T("..\\Log\\Data"), NULL);
	CreateDirectory(_T("..\\Log\\Data\\ModelData"), NULL);
	m_strPath = ".\\Data";
    m_strFileName = strFileName;
	m_strFile = m_strPath + "\\" + m_strFileName;

	if (m_bResizeFile != TRUE)
	{
		resizeFile("..\\Log\\Data\\*.*");
		m_bResizeFile = TRUE;
	}
*/
	CreateDirectory(_T("..\\Log\\Data"), NULL);
	CreateDirectory(_T("..\\Log\\Data\\ModelData"), NULL);
	m_strPath = _T(".\\Data");
    m_strFileName = strFileName;
	m_strFile = m_strPath + _T("\\") + m_strFileName;

	if (m_bResizeFile != TRUE)
	{
		resizeFile("..\\Log\\Data\\*.*");
		m_bResizeFile = TRUE;
	}

}

MFileManager::MFileManager(CString strFileName, CString strPath)
{
	m_strPath = strPath;
    m_strFileName = strFileName;
	m_strFile = m_strPath + "\\" + m_strFileName;
	
	if (m_bResizeFile != TRUE)
	{
		resizeFile("..\\Log\\Data\\*.*");
		m_bResizeFile = TRUE;
	}
}

MFileManager::MFileManager()
{
	WCHAR chPath[256];
	GetCurrentDirectory(256, chPath);
	
	m_strPath.Format(_T("%s"), chPath);

    m_strFileName = "Data.dat";
	m_strFile = m_strPath + "\\" + m_strFileName;
}

MFileManager::~MFileManager()
{
}

void MFileManager::SetFilePath(CString strPath)
{
	m_strPath = strPath;
	m_strFile = m_strPath + "\\" + m_strFileName;
}

int MFileManager::SetValue(CString strSection, CString strItem, int nValue, BOOL bMakeHistory)
{
    CString strValue;
	int iResult = 0;
    strValue.Format(_T("%d"), nValue);
	if (bMakeHistory)	
		checkValue(strSection, strItem, strValue);
    iResult = WritePrivateProfileString(strSection, strItem, LPCTSTR(strValue),LPCTSTR(m_strFile));
	if (!iResult)
	{
		// Doolin kwangilshin 2017. 10. 24.
		// Test.
		//
		DWORD	dwLastErrCode	= 0x00;
		DWORD	dwApiRet		= 0;
		LPVOID	lpvLastErrMsg	= NULL;
		CString strLastMessage;
		CString strMsgTemp;
	
		dwLastErrCode	= ::GetLastError();
		dwApiRet		= ::FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL, dwLastErrCode, 0, (LPTSTR)&lpvLastErrMsg, 0, NULL);
	
		if (dwApiRet && lpvLastErrMsg != NULL)
		{
			strLastMessage.Empty();
			strLastMessage = static_cast<LPCTSTR>(lpvLastErrMsg);
			
			LocalFree(lpvLastErrMsg);
			
			strMsgTemp.Empty();
			strMsgTemp.Format(_T("\nWritePrivateProfileString : [Path : %s] %s, %s, %d / [ErrCode : %d ] %s\n"), m_strFile, strSection, strItem, iResult, dwLastErrCode, strLastMessage);
		}
		else
		{
			strMsgTemp.Empty();
			strMsgTemp.Format(_T("\nWritePrivateProfileString : [Path : %s] %s, %s, %d.!\n\n"), m_strFile, strSection, strItem, iResult);
		}
		
		TRACE (strMsgTemp);
		// End.
		
		return FALSE;
	}

    return TRUE;
}

int MFileManager::SetValue(CString strSection, CString strItem, UINT nValue, BOOL bMakeHistory)
{
	CString strValue;
	int iResult;
    strValue.Format(_T("%d"), nValue);
    if (bMakeHistory)
		checkValue(strSection, strItem, strValue);
	iResult = WritePrivateProfileString(strSection, strItem, LPCTSTR(strValue), LPCTSTR(m_strFile));
	if (!iResult)
		return FALSE;

    return TRUE;
}

int MFileManager::SetValue(CString strSection, CString strItem, double dValue, BOOL bMakeHistory)
{
    CString strValue;
    strValue.Format(_T("%lf"), dValue);
    if (bMakeHistory)
		checkValue(strSection, strItem, strValue);
    int iResult = WritePrivateProfileString(strSection, strItem, LPCTSTR(strValue), LPCTSTR(m_strFile));
	if (!iResult)
		return FALSE;

    return TRUE;
}

int MFileManager::SetValue(CString strSection, CString strItem, CString strValue, BOOL bMakeHistory)
{
	int iResult;
    if (bMakeHistory)
		checkValue(strSection, strItem, strValue);
    iResult = WritePrivateProfileString(strSection, strItem, LPCTSTR(strValue), LPCTSTR(m_strFile));
	if (!iResult)
		return FALSE;

    return TRUE;
}

int MFileManager::SetValue(CString strSection, CString strItem, WCHAR* pchValue, UINT nSize, BOOL bMakeHistory)
{
	CString strValue;
	int iResult;
	strValue.Format(_T("%s"), pchValue);
    if (bMakeHistory)
		checkValue(strSection, strItem, strValue);
	iResult = WritePrivateProfileString(strSection, strItem, LPCTSTR(strValue),LPCTSTR(m_strFile));
	if (!iResult)
		return FALSE;

    return TRUE;
}

int MFileManager::GetValue(CString strSection, CString strItem, int* pnValue)
{
    *pnValue = GetPrivateProfileInt(strSection, strItem, -99, m_strFile);
	if (*pnValue == -99)
	{
#ifdef DEF_IGNORE_FILE_READ_ERROR
		return TRUE;
#endif

		// Doolin kwangilshin 2017. 10. 24.
		// Test.
		//
		DWORD	dwLastErrCode	= 0x00;
		DWORD	dwApiRet		= 0;
		LPVOID	lpvLastErrMsg	= NULL;
		CString strLastMessage;
		CString strMsgTemp;
	
		dwLastErrCode	= ::GetLastError();
		dwApiRet		= ::FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL, dwLastErrCode, 0, (LPTSTR)&lpvLastErrMsg, 0, NULL);
	
		if (dwApiRet && lpvLastErrMsg != NULL)
		{
			strLastMessage.Empty();
			strLastMessage = static_cast<LPCTSTR>(lpvLastErrMsg);
			
			LocalFree(lpvLastErrMsg);
			
			strMsgTemp.Empty();
			strMsgTemp.Format(_T("GetPrivateProfileInt : [Path : %s] %s, %s, %d / [ErrCode : %d ] %s\n"), m_strFile, strSection, strItem, *pnValue, dwLastErrCode, strLastMessage);
		}
		else
		{
			strMsgTemp.Empty();
			strMsgTemp.Format(_T("GetPrivateProfileInt : [Path : %s] %s, %s, %d.!\n\n"), m_strFile, strSection, strItem, *pnValue);
		}
		
		TRACE (strMsgTemp);
		// End.
		
		return FALSE;
	}

    return TRUE;
}

int MFileManager::GetValue(CString strSection, CString strItem, UINT* pnValue)
{
	int nTemp = GetPrivateProfileInt(strSection, strItem, -99, m_strFile);
	if (nTemp == -99)
	{
		*pnValue = 0;
		
#ifdef DEF_IGNORE_FILE_READ_ERROR
		return TRUE;
#endif
		return FALSE;
	}
	ASSERT(nTemp >= 0);  
	*pnValue = nTemp;
    return TRUE;
}

int MFileManager::GetValue(CString strSection, CString strItem, double* pdValue)
{
    WCHAR chrData[256];
    memset(chrData, NULL, sizeof(chrData));
    GetPrivateProfileString(strSection, strItem, _T("ERROR"), chrData, 256, m_strFile);
	
	if (lstrcmp(chrData, _T("ERROR")) == 0) 
	{
		*pdValue = 0;

#ifdef DEF_IGNORE_FILE_READ_ERROR
		return TRUE;
#endif
		return FALSE;
	}

 //   *pdValue = atof(chrData);
	*pdValue = wcstod(chrData, NULL);
    return TRUE;
}

int MFileManager::GetValue(CString strSection, CString strItem, CString* pstrValue)
{
    WCHAR chrData[256];
    memset(chrData, NULL, sizeof(chrData));
    GetPrivateProfileString(strSection, strItem, _T("ERROR"), chrData, 256, m_strFile);

	if (lstrcmp(chrData, _T("ERROR")) == 0)
	{
#ifdef DEF_IGNORE_FILE_READ_ERROR
		return TRUE;
#endif
		return FALSE;
	}

    pstrValue->Format(_T("%s"), chrData);
    return TRUE;
}

int MFileManager::GetValue(CString strSection, CString strItem, WCHAR* pchValue, UINT nSize)
{
	WCHAR chrData[256];
    memset(chrData, NULL, sizeof(chrData));
    GetPrivateProfileString(strSection, strItem, _T("ERROR"), chrData, 256, m_strFile);

	if (lstrcmp(chrData, _T("ERROR")) == 0)
	{
#ifdef DEF_IGNORE_FILE_READ_ERROR
		return TRUE;
#endif
		return FALSE;
	}

	if (_tcslen(chrData) > nSize) return FALSE;

	_tcscpy(pchValue, chrData);
    return TRUE;
}

int MFileManager::MakeBackUpFile()
{
	CString strSrcFile = m_strFile;
	int nIndex = strSrcFile.Find(_T(".dat"));

	if (nIndex == -1 || nIndex == 0)
		return FALSE;

	CString strDestFile = strSrcFile.Left(nIndex) + ".bak";
	
	if (!CopyFile(strSrcFile, strDestFile, FALSE))
	{
		DWORD dwordErrorCode = GetLastError();
		return FALSE;
	}
	
	return TRUE;
}

void MFileManager::CreateBackupFolder(LPCTSTR strDest, LPCTSTR strSrc, BOOL bOverWrite)
{
	int			bMoreFile = 0;
	CFileFind	ff;
	CFileFind	fn;
	CString		strSearchFile;	
	CString		strDestFile;	
	CString		strSrcFile;		
	CString		strDestSubFolder;
	CString		strSrcSubFolder;

	if (!fn.FindFile(strDest))
	{
		if (!CreateDirectory(strDest, NULL))
			return;
	}

	strSearchFile.Format(_T("%s\\*.*"),strDest);
	if (bOverWrite && fn.FindFile(strSearchFile,0)) 
	{
		while (TRUE)
		{
			bMoreFile = fn.FindNextFile();

			// 디렉토리가 아닌 파일들을 삭제한다.
			if (!fn.IsDirectory() && !fn.IsHidden() && !fn.IsReadOnly() && !fn.IsSystem())
			{
				strDestFile = fn.GetFilePath();
				CFile::Remove(strDestFile);
			}

			if (!bMoreFile)
				break;
		}
	}

	strSearchFile.Format(_T("%s\\*.*"),strSrc);
	if (!ff.FindFile(strSearchFile,0)) 
		return;

	while (TRUE)
	{
		bMoreFile = ff.FindNextFile();

		if (!ff.IsDirectory())
		{
			strSrcFile = ff.GetFilePath();
			strDestFile.Format(_T("%s\\%s"),strDest,ff.GetFileName());
			SetFileAttributes(strSrcFile, FILE_ATTRIBUTE_NORMAL);
			if (!CopyFile(strSrcFile, strDestFile, FALSE))
				return;
		}
		else if (!ff.IsDots())
		{
			strDestSubFolder.Format(_T("%s\\%s"),strDest,ff.GetFileName());
			strSrcSubFolder.Format(_T("%s\\%s"),strSrc,ff.GetFileName());
			CreateBackupFolder(strDestSubFolder, strSrcSubFolder, TRUE);
		}

		if (!bMoreFile)
			break;
	}
}

void MFileManager::AutoDeleteFile(CString strTarget, int Duration, BOOL bDelelteDir)
{
	CFileFind	fn;
	CFileStatus	rStatus;
	CString		strFileName;
	BOOL		bMoreFile = 0;

	struct tm when;
	time_t	now, result;

	time(&now);
	when = *localtime(&now);
	when.tm_mday = when.tm_mday - Duration;
	result = mktime(&when);

	if (!fn.FindFile(strTarget))
		return;

	while (TRUE) 
	{
		bMoreFile = fn.FindNextFile();

		if (!fn.IsDots())
		{
			strFileName	= fn.GetFilePath();
			CFile::GetStatus(strFileName, rStatus);
			if (rStatus.m_mtime.GetTime() < result)
			{
				if (!fn.IsDirectory())
					DeleteFile(strFileName);

				else if (!fn.IsDots() && bDelelteDir)
				{
					CString strDirName = strFileName;
					strDirName+="\\*.*";
					AutoDeleteFile(strDirName,Duration);
					RemoveDirectory(strFileName);
				}
			}
		}

		if (!bMoreFile)
			break;
	}
}

void MFileManager::checkValue(CString strSection, CString strItem, CString strValue)
{
    WCHAR chrBeforData[256];
    memset(chrBeforData, NULL, sizeof(chrBeforData));
	GetPrivateProfileString(strSection, strItem, _T("ERROR"), chrBeforData, 256, m_strFile);

	if (lstrcmp(chrBeforData, _T("ERROR")) == 0) 
		return;

	if (lstrcmp(chrBeforData, strValue) != 0)
	{
		//SJ_YYK 110421 Add.. ELLAS
		CString csTemp;
		csTemp.Format(_T("%s##%s##%s##%s##%s##%s"),m_strPath,m_strFileName,strSection,strItem,chrBeforData,strValue); 
		MOlbSystemPre.GetLCNetComponent()->EqSpecialStateReport(eProcessConditionChangeStart, eMaterial_Nothing, csTemp);

		writeChangeHistory(strSection, strItem, chrBeforData, strValue);  // 추후 수정
		//cys_100420 : 변경사항을 한 파일에 통합
		writeChangeWholeHistory(strSection, strItem, chrBeforData, strValue);
	}
}

void MFileManager::writeChangeHistory(CString strSection, CString strItem, WCHAR* chrBeforData, CString strValue)
{
	FILE*		fsource;
	CFileFind	fn;
	CString		strFileName;
	CString		strMsg;

	strFileName = m_strPath;
	strFileName.Remove('.');

	//WCHAR buf[500];
	//size_t strSize;
	int count = 0;

	CTime tmCurr = CTime::GetCurrentTime();

	//LKH_20090129 : ModelData를 Unicode로 저장
	//strMsg = tmCurr.Format("[%m/%d-%H:%M:%S] ") + "[" + strSection + "] " + strItem + ": " + chrBeforData + ", " + strValue;
	strMsg = tmCurr.Format(_T("[%m/%d-%H:%M:%S] ")) + _T("[") + strSection + _T("] ") + strItem + _T(": ") + chrBeforData + _T(", ") + strValue;
	strFileName = _T("..\\Log") + strFileName;

	if (!fn.FindFile(strFileName))
	{
		if (!CreateDirectory(strFileName, NULL))
			return;
	}

	strFileName = strFileName + _T("\\") + m_strFileName;

//	if ((fsource = _wfopen(strFileName, _T("a"))) == NULL)
	if ((fsource = _wfopen(strFileName, _T("ab+,ccs=UNICODE"))) == NULL)
	{
		return;
	}
	
	//현재 발생 로그 기록
	fwprintf(fsource, _T("%s\r\n"), strMsg.GetBuffer());
	/*
	wcscpy(buf,strMsg);
	strSize = wcslen(buf);
	fwrite(buf, sizeof(WCHAR), strSize, fsource);
	*/

	fclose(fsource);

}

void MFileManager::resizeFile(CString strTarget)
{
	CFileFind	fn;
	CString		strSrcFile,strDestFile;
	CFileStatus statusFile; 
	CTime		tmCurr;
	BOOL		bMoreFile;

	tmCurr = CTime::GetCurrentTime();
	strSrcFile = strTarget;

	if (!fn.FindFile(strSrcFile))
		return;

	while (TRUE)
	{
		bMoreFile = fn.FindNextFile();

		strSrcFile = fn.GetFilePath();
		CFile::GetStatus(strSrcFile, statusFile); 

		if (!fn.IsDirectory())
		{
			if (statusFile.m_size > 1000000 && strSrcFile.Find(_T(".bak")) == -1)
			{
				strDestFile = strSrcFile + "-" + tmCurr.Format("%y%m%d") +".bak";
				if (!CopyFile(strSrcFile, strDestFile, TRUE))
					return;
				DeleteFile(strSrcFile);
			}
		}
		else if (!fn.IsDots())
		{
			CString strDirName = strSrcFile;
			strDirName += "\\*.*";
			resizeFile(strDirName);
		}

		if (!bMoreFile)
			break;
	}
}
//cys_100420
CString MFileManager::getModelName()
{
	CString strSection = _T("Common");
	CString strItem = _T("ModelName");
	CString strFileName = _T(".\\data\\System.dat");

    WCHAR chrData[256];
    memset(chrData, NULL, sizeof(chrData));
	GetPrivateProfileString(strSection, strItem, _T("No Model Name"), chrData, 256, strFileName);

	return chrData;
}

//cys_100420
void MFileManager::writeChangeWholeHistory(CString strSection, CString strItem, WCHAR* chrBeforData, CString strValue)
{
	CString strModelName;
	strModelName = getModelName();

	FILE *fpRead, *fpWrite;
	CFileFind fn;
	WCHAR szDataName[100] = _T("..\\Log\\DataHistory.dat");
	WCHAR szBackupName[100] = _T("..\\Log\\DataHistory.bak");

	CString strErrorMsg;
	strErrorMsg = _T("[") + strModelName + _T("] ") + _T("[") + strSection + _T("] ") + strItem + _T(" : ") + chrBeforData + _T(" ==> ") + strValue;

	CTime tmCurr = CTime::GetCurrentTime();
	strErrorMsg = tmCurr.Format(_T("[%m/%d-%H:%M:%S] ")) + strErrorMsg;

	if (fn.FindFile(szDataName,0))
	{
		if (!CopyFile(szDataName, szBackupName, FALSE))
		{
			return;
		}
		if (!DeleteFile(szDataName))
		{
			return;
		}
	}
	
	if ((fpWrite = _wfopen(szDataName, _T("ab+,ccs=UNICODE"))) == NULL)
	{
		return;
	}

	WCHAR buf[500];
	int count = 0;
	size_t strSize;
	
	//현재 발생한 Error 기록
	wcscpy(buf,strErrorMsg);
	strSize = wcslen(buf);
	fwrite(buf, sizeof(WCHAR), strSize, fpWrite);
	fwprintf(fpWrite, _T("\r\n"));

	if (!fn.FindFile(szBackupName,0))
	{
		fclose(fpWrite);
		return;
	}
	else if ((fpRead = _wfopen(szBackupName, _T("ab+,ccs=UNICODE"))) == NULL)
	{
		return;
	}

	CString strMsg;

	while (!feof(fpRead))
	{
		if (count > 500)
			break;

		fgetws(buf, 500, fpRead);
		strSize = wcslen(buf);
		if(feof(fpRead))
			break;
		fwrite(buf, sizeof(WCHAR), strSize, fpWrite);
		
		count += 1;
	}

	fclose(fpWrite);
	fclose(fpRead);
}
