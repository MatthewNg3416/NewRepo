/* Generated by Together */

#include "stdafx.h"
#include <mbstring.h>
#include "MComThread.h"

MComThread::MComThread(SCommonAttribute commonData, SSerialPortData datComponent)
: ICommon(commonData)
{
	// ML_hongju
//	m_sPortName.Format("COM%d",datComponent.m_uPortNo);
//170927 JSH.s
// 	if(datComponent.m_uPortNo < 10)
// 		m_sPortName.Format(_T("COM%d"),datComponent.m_uPortNo);
	// 	else
//170927 JSH.e
		m_sPortName.Format(_T("\\\\.\\COM%d"),datComponent.m_uPortNo);
	m_wPortID = datComponent.m_uPortNo;
	m_uBaud = datComponent.m_uBaud;
	m_uDatabits = datComponent.m_uDatabits;
	m_uParity = datComponent.m_uParity;
	m_uStopbits = datComponent.m_uStopbits;
	m_uWritebuffersize = datComponent.m_uWritebuffersize;		
	m_szEnd = datComponent.m_szEnd;
	m_QueueRead.SetEndChar(m_szEnd);	//@121210.KKY
}

int MComThread::OpenPort()
{
	// Local 변수.
	COMMTIMEOUTS	timeouts;
	DCB				dcb;

	DWORD iCts=CTS_DONE;
	DWORD iDsr=DSR_DONE;

	// 변수 초기화
	m_bConnected = FALSE;

	// overlapped structure 변수 초기화.
	m_osRead.Offset = 0;
	m_osRead.OffsetHigh = 0;
	m_osRead.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (! (m_osRead.hEvent))	
		return 1;
	m_osWrite.Offset = 0;
	m_osWrite.OffsetHigh = 0;
	m_osWrite.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (! (m_osWrite.hEvent))
		return 1;
/*	
	// 포트 열기
	m_hComm = CreateFile(	m_sPortName, 
							GENERIC_READ | GENERIC_WRITE, 
							0, 
							NULL,
							OPEN_EXISTING, 
							FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, 
							NULL);
*/
	m_hComm = CreateFile(m_sPortName, 
					     GENERIC_READ | GENERIC_WRITE,			// 접근모드 읽기쓰기인가 읽기 전용인가
					     FILE_SHARE_READ | FILE_SHARE_WRITE ,   // 다른 프로그램과 공유를 할것인가 아닌가.
						 NULL,									// 보안에 관한 속성(현재 개방된 파일이 다른 사람들에게 오픈되지 못하게 잠그는 속성)
					     OPEN_ALWAYS,							// 어떻게 열것인가(새로 만들것인가, 기존에 있는 파일을 열것인가[OPEN_EXISTING])
					     FILE_FLAG_OVERLAPPED,					// 파일 속성(보통 파일이면서 overlapped 되게 한다.)
						 0);									// 템플릿 파일 핸들러

	if (m_hComm == (HANDLE) -1) return 1;

	// 포트 상태 설정.

	// EV_RXCHAR event 설정
//	SetCommMask(m_hComm, EV_RXCHAR);	
	SetCommMask(m_hComm, EV_BREAK | EV_ERR | EV_RXCHAR | EV_TXEMPTY);	

	// InQueue, OutQueue 크기 설정.
	SetupComm(m_hComm, 4096, 4096);	

	// 포트 비우기.
	PurgeComm(m_hComm,					
		PURGE_TXABORT | PURGE_TXCLEAR | PURGE_RXABORT | PURGE_RXCLEAR);

	// timeout 설정.
	timeouts.ReadIntervalTimeout = 0xFFFFFFFF;
	timeouts.ReadTotalTimeoutMultiplier = 0;
	timeouts.ReadTotalTimeoutConstant = 0;
	timeouts.WriteTotalTimeoutMultiplier = 2*CBR_9600 / m_uBaud;
	timeouts.WriteTotalTimeoutConstant = 0;
	SetCommTimeouts(m_hComm, &timeouts);

	// dcb 설정
	dcb.DCBlength = sizeof(DCB);
	GetCommState(m_hComm, &dcb);	// 예전 값을 읽음.
	dcb.BaudRate = m_uBaud;
	dcb.ByteSize = m_uDatabits;
	dcb.Parity = m_uParity;
	dcb.StopBits = m_uStopbits;
	dcb.fOutxCtsFlow = iCts;
	dcb.fOutxDsrFlow = iDsr;
	dcb.fInX = dcb.fOutX = 1;		// Xon, Xoff 사용.
	dcb.XonChar = ASCII_XON;
	dcb.XoffChar = ASCII_XOFF;
	dcb.XonLim = 100;
	dcb.XoffLim = 100;
	if (! SetCommState(m_hComm, &dcb))	return 1;

	// 포트 감시 쓰레드 생성.
	m_bConnected = TRUE;
	m_Thread = AfxBeginThread(ThreadWatchComm, this);
	if (!(m_Thread))
		return 1;

	if (!m_Thread)
	{
		ClosePort();
		return 1;
	}
    
	return DEF_SERIALPORT_SUCCESS;
}

MComThread::~MComThread()
{
#ifndef SIMULATION
	ClosePort();
#endif
}

int MComThread::ClosePort()
{
	if (FALSE == m_bConnected)
		return DEF_SERIALPORT_SUCCESS;
	m_bConnected = FALSE;
	SetCommMask(m_hComm, 0);
	PurgeComm(m_hComm, PURGE_TXABORT | PURGE_TXCLEAR | PURGE_RXABORT | PURGE_RXCLEAR);
	CloseHandle(m_hComm);

	if (m_Thread == NULL)
		return DEF_SERIALPORT_SUCCESS; //아무것도 없는 상태에서는 리턴한다.

	DWORD exitcode;
	exitcode = ::WaitForSingleObject(m_Thread->m_hThread, 5000);
	if (exitcode == WAIT_TIMEOUT)
		::TerminateThread(m_Thread->m_hThread, exitcode);
	m_Thread = NULL;

	return DEF_SERIALPORT_SUCCESS;
}

//_____________________________________________________________________________________________________________
int MComThread::WriteComm(BYTE * pBuff, DWORD nToWrite)
{
	DWORD	dwWritten, dwError, dwErrorFlags;
	COMSTAT	comstat;
    //AfxMessageBox(pBuff);
	if (! WriteFile(m_hComm, pBuff, nToWrite, &dwWritten, &m_osWrite))
	{  
	
		if (GetLastError() == ERROR_IO_PENDING)
		{  
			// 읽을 문자가 남아 있거나 전송할 문자가 남아 있을 경우 Overapped IO의
			// 특성에 따라 ERROR_IO_PENDING 에러 메시지가 전달된다.
			//timeouts에 정해준 시간만큼 기다려준다.
			while (! GetOverlappedResult(m_hComm, &m_osWrite, &dwWritten, TRUE))
			{
				dwError = GetLastError();
				if (dwError != ERROR_IO_INCOMPLETE)
				{
					ClearCommError(m_hComm, &dwErrorFlags, &comstat);
					break;
				}
				Sleep(10);
			}
		}
		else
		{ 
			dwWritten = 0;
			ClearCommError(m_hComm, &dwErrorFlags, &comstat);
		}
	}

	return dwWritten;
}
int MComThread::ReadComm(BYTE * pBuff, DWORD nToRead)
{
	DWORD	dwRead, dwError, dwErrorFlags;
	COMSTAT	comstat;


	//----------------- system queue에 도착한 byte수만 미리 읽는다.
	ClearCommError(m_hComm, &dwErrorFlags, &comstat);
	dwRead = comstat.cbInQue;

	if (dwRead > 0)
	{
		if (! ReadFile(m_hComm, pBuff, nToRead, &dwRead, &m_osRead))
		{
			if (GetLastError() == ERROR_IO_PENDING)
			{
				//--------- timeouts에 정해준 시간만큼 기다려준다.
				while (! GetOverlappedResult(m_hComm, &m_osRead, &dwRead, TRUE))
				{
					dwError = GetLastError();
					if (dwError != ERROR_IO_INCOMPLETE)
					{
						ClearCommError(m_hComm, &dwErrorFlags, &comstat);
						break;
					}
					Sleep(10);
				}
			}
			else
			{
				dwRead = 0;
				ClearCommError(m_hComm, &dwErrorFlags, &comstat);
			}
		}
	}

	return dwRead;
}

void MComThread::ClearRecvQueue()
{
	m_QueueRead.Clear();
}

int MComThread::GetPortNo()
{
	return m_wPortID;
}

//_____________________________________________________________________________________________________________
UINT MComThread::ThreadWatchComm(LPVOID pParam)
{
	DWORD		dwEvent;
	OVERLAPPED	os;
	BOOL		bOk = TRUE;
	BYTE		buff[2048];	 // 읽기 버퍼
	DWORD		dwRead;	 // 읽은 바이트수.

	MComThread* pComm = (MComThread *)pParam;
	
	// Event, OS 설정.
	memset(&os, 0, sizeof(OVERLAPPED));
	os.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (! (os.hEvent))
		bOk = FALSE;
	if (! SetCommMask(pComm->m_hComm, EV_RXCHAR))
		bOk = FALSE;
	if (! bOk)
	{
		AfxMessageBox(_T("Error while creating ThreadWatchComm, ") + pComm->m_sPortName);
		return 1;
	}

	// 포트를 감시하는 루프.
	while (pComm->m_bConnected)
	{
		dwEvent = 0;

		// 포트에 읽을 거리가 올때까지 기다린다.
		WaitCommEvent(pComm->m_hComm, &dwEvent, NULL);
		
		if ((dwEvent & EV_RXCHAR) == EV_RXCHAR)
		{
			// 포트에서 읽을 수 있는 만큼 읽는다.
			do	
			{
				memset(buff, 0, sizeof(buff));
				dwRead = pComm->ReadComm(buff, 2048);
				
				if (BUFF_SIZE - pComm->m_QueueRead.GetSize() > (int)dwRead)
				{
					for (WORD i = 0; i < dwRead; i++)
						pComm->m_QueueRead.PutByte(buff[i]);
				}
				else
				{
//					AfxMessageBox("m_QueueRead FULL!");
					BYTE	tmp[100];
					pComm->m_QueueRead.GetByte(tmp);
					pComm->m_QueueRead.Clear();
				}
			} while (dwRead);
			//	읽어 가도록 메시지를 보낸다.
	//	::PostMessage(hCommWnd,WM_COMM_READ, pComm->m_wPortID, 0);
		}
		Sleep(10);
	}	
	
	// 포트가 ClosePort에 의해 닫히면 m_bConnected 가 FALSE가 되어 종료.

	CloseHandle(os.hEvent);

	TRACE(_T("MComThread Thread Stop\n"));
	return DEF_SERIALPORT_SUCCESS;
}

int MComThread::RestartThread()
{
	m_Thread->ResumeThread();
	return DEF_SERIALPORT_SUCCESS;	
}

int MComThread::PauseThread()
{
	m_Thread->SuspendThread(); 
	return DEF_SERIALPORT_SUCCESS;	
}

//_____________________________________________________________________________________________________________
int MComThread::ReceiveData(unsigned char * buf, int iBufSize)
{
	//Queue buffer에 String의 끝단 NULL이 있는가 확인 할 필요가 있음
	if (!m_QueueRead.HaveString())
		return 1;

	for (; *buf; buf++)
	{
		if ((--iBufSize) <= 0)			return 1;
		
		if (!m_QueueRead.GetByte(buf))	return 1;
	}

	return DEF_SERIALPORT_SUCCESS;
}

int MComThread::SendData(unsigned char * buf)
{
//	DWORD bufLength = strlen(buf);
	DWORD bufLength = _mbslen(buf);
	
	if (WriteComm(buf, sizeof(bufLength)))
		return 1;
	else
		return DEF_SERIALPORT_SUCCESS;
}

int MComThread::ReceiveData(char * buf, int iBufSize)
{
	//Queue buffer에 String의 끝단 NULL이 있는가 확인 할 필요가 있음
	BOOL bResult = FALSE;
	bResult = m_QueueRead.HaveString();
	if (!bResult)
		return 1;

	unsigned char tmpBuf[1024];
	memset(tmpBuf, 0, 1024);
	int CountBuf=0;

	if (m_szEnd == NOTUSE)
	{
		//@바뀐 Barcode에서 ETX가 없이 ComThread에 두번에 걸쳐 Data를 보내줌.
		//@	따라서 Buffer에 Data가 다 들어올때까지 기다린후 Read함
		Sleep(500);
		int iSize = m_QueueRead.GetSize();
		for (int i=0; i<iSize; i++, buf++)
		{
			if (!m_QueueRead.GetByte(tmpBuf))
				return 1;
			*buf = *tmpBuf;
		}
	}
	else
	{
		for (; *tmpBuf != m_szEnd; buf++)
		{
			//Buffer Full이 되지 않토록 한다.
			if ((CountBuf >= 1023) || (CountBuf++ >= iBufSize))
				return 1;
			
			if (!m_QueueRead.GetByte(tmpBuf))
				return 1;
			*buf = *tmpBuf;
		}
	}

	return DEF_SERIALPORT_SUCCESS;

}

int MComThread::SendData(char * buf)
{
	DWORD bufLength = strlen(buf);
	BYTE strSendBuf[1024];
	memset(strSendBuf, NULL, sizeof(strSendBuf));
	for (DWORD i=0; i<bufLength; i++)
		strSendBuf[i] = *buf++;
	
	if (WriteComm(strSendBuf, bufLength))		
		return DEF_SERIALPORT_SUCCESS;
	else 
		return 1;
}
