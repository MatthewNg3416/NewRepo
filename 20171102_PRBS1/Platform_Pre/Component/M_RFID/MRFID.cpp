/* Generated by Together */

#include "stdafx.h"
#include "MRFID.h"
#include "IComThread.h"
#include "MTickTimer.h"

#include "common.h"

// Unicode WCHAR -> char
#include "atlconv.h"//꼭 해줘야 함

#define MAP_SHIFT 0 // 전체적으로 맵이 밀렸을때 몇 비트 만큼 밀릴것인지 확인  
                     // 기본적으로 0이나, 0001번지는 쓰면 안되므로 10비트 밀었음 (현석)   

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

/** @stereotype constructor */
MRFID::MRFID(SCommonAttribute commonData,SRFIDRefCompList listRefComponent, SRFIDData datComponent)
: ICommon(commonData)
{
	m_bBatteryState = DEF_BATTERY_STATE_GOOD;
	InitializeCriticalSection(&m_Sync);

	m_plnkSerialPort = listRefComponent.m_plnkSerialPort;
	m_iHeadNo = datComponent.m_iHeadNo;

	initializeItem();
}

MRFID::~MRFID()
{
	DeleteCriticalSection(&m_Sync);
}

void MRFID::GetFrameCheckSequence(const char *pFrame,char *pFCS)
{
	char FCS[2];
	int	iLen = 0, iSum = 0;
	memset(FCS, 0x00, sizeof(FCS));
	memset(pFCS, 0x00, sizeof(char));

	iLen = strlen(pFrame);
	for (int i=0 ; i <iLen ; i++)
		iSum^=pFrame[i];	//exclusive OR
	sprintf(FCS,"%2x", iSum);
	strcpy(pFCS, FCS);
}

int MRFID::MakeRequestCommand(ECommandType iCommandType, char *pFrameMessage, const char *pData, int iHeadNo, int iStartAddress, int iReadByte,EDataCodeSpec iDataCodeType, int iUnitNo)
{
	char szHeader[10];	// Header
	char szCodeSpec[10];	// Code Specification
	char szFrameMessage[DEF_MAX_FRAME_MESSAGE_SIZE];
	CString strLogMsg;

	memset(szFrameMessage, 0x00, sizeof(szFrameMessage));

#if defined(V600)

	if ((iDataCodeType == DEF_INVALID_CODE_SPEC) && (iCommandType != DEF_COMMAND_DATA_LIMIT))
		// 206001 = CodeSpec Type Error
		return generateErrorCode(206001);

	switch (iDataCodeType)
	{
	case DEF_ASCII:							strcpy(szCodeSpec, DEF_ASCII_CODE);						break;
	case DEF_HEX:							strcpy(szCodeSpec, DEF_HEX_CODE);						break;
	case DEF_PROCESSING_RESULT_INQUIRY:		strcpy(szCodeSpec, DEF_PROCESSING_RESULT_INQUIRY_CODE); break;
	case DEF_CANCEL:						strcpy(szCodeSpec, DEF_CANCEL_CODE);					break;
	case DEF_COLLATION:						strcpy(szCodeSpec, DEF_COLLATION_CODE);					break;
	case DEF_CALCULATION:					strcpy(szCodeSpec, DEF_CALCULATION_CODE);				break;
	default: 
		//strLogMsg.Format(_T("MakeRequestCommand() : Data Code Type Error"));
		//WriteErrorLog(strLogMsg);

		// 206002 = Data Code Type Error
		return generateErrorCode(206002);
	}

	switch (iCommandType)
	{
	case DEF_COMMAND_READ:
	case DEF_COMMAND_AUTO_READ:
	case DEF_COMMAND_POLLING_AUTO_READ:
		if (iCommandType == DEF_COMMAND_READ)
			strcpy(szHeader, DEF_HEADER_READ); 	
		else if (iCommandType == DEF_COMMAND_AUTO_READ)
			strcpy(szHeader, DEF_HEADER_AUTO_READ);
		else
			strcpy(szHeader, DEF_HEADER_POLLING_AUTO_READ);
		
#if defined(OneToOne)
		sprintf(szFrameMessage, "%s%s%d%04X%02X%s%c", szHeader, szCodeSpec, iHeadNo, iStartAddress,iReadByte, DEF_ETX, 13);
		strcpy(pFrameMessage, szFrameMessage);
		return DEF_RFID_SUCCESS;
#endif
		break;

	case DEF_COMMAND_WRITE:
	case DEF_COMMAND_AUTO_WRITE:
	case DEF_COMMAND_POLLING_AUTO_WRITE:
		if (iCommandType == DEF_COMMAND_WRITE)
			strcpy(szHeader, DEF_HEADER_WRITE); 
		else if (iCommandType == DEF_COMMAND_AUTO_WRITE)
			strcpy(szHeader, DEF_HEADER_AUTO_WRITE);
		else
			strcpy(szHeader, DEF_HEADER_POLLING_AUTO_WRITE);
	
#if defined(OneToOne)
		sprintf(szFrameMessage, "%s%s%d%04x%s%s%c", szHeader, szCodeSpec, iHeadNo, iStartAddress, pData, DEF_ETX,13);
		strcpy(pFrameMessage, szFrameMessage);
		return DEF_RFID_SUCCESS;
#endif
		break;
	
	case DEF_COMMAND_CANCEL:
		strcpy(szHeader, DEF_HEADER_COMMAND_CANCEL);
#if defined(OneToOne)
		sprintf(szFrameMessage, "%s%s", szHeader, DEF_ETX);
		strcpy(pFrameMessage, szFrameMessage);
		return DEF_RFID_SUCCESS;
#endif
		break;
	case DEF_COMMAND_DATA:
		strcpy(szHeader, DEF_HEADER_DATA_COMMAND);
#if defined(OneToOne)
		sprintf(szFrameMessage, "%s%s%d%04x%s%s", szHeader, szCodeSpec, iHeadNo, iStartAddress, pData, DEF_ETX);
		strcpy(pFrameMessage, szFrameMessage);
		return DEF_RFID_SUCCESS;
#endif
		break;
	case DEF_COMMAND_DATA_LIMIT:
		strcpy(szHeader, DEF_HEADER_MANAGEMENT_DATA_LIMIT); 
#if defined(OneToOne)
		sprintf(szFrameMessage, "%s%d%04x%s%s", szHeader, iHeadNo, iStartAddress, pData, DEF_ETX);
		strcpy(pFrameMessage, szFrameMessage);
		return DEF_RFID_SUCCESS;
#endif

	case DEF_COMMAND_DATA_TEST:
		strcpy(szHeader, DEF_HEADER_DATA_TEST_COMMAND);

#if defined(OneToOne)
		sprintf(szFrameMessage, "%s%s%s", szHeader, pData, DEF_ETX);
		strcpy(pFrameMessage, szFrameMessage);
		return DEF_RFID_SUCCESS;
#endif
		break;
	case DEF_COMMAND_RESET:
	case DEF_COMMAND_NOT_DEFINED:
		if (iCommandType == DEF_COMMAND_RESET)
			strcpy(szHeader, DEF_HEADER_RESET_COMMAND);
		else
			strcpy(szHeader, DEF_HEADER_COMMAND_NOT_DEFINED);
#if defined(OneToOne)
		sprintf(szFrameMessage, "%s%s", szHeader, DEF_ETX);
		strcpy(pFrameMessage, szFrameMessage);
		return DEF_RFID_SUCCESS;
#endif
		break;
	default: 
		//strLogMsg.Format(_T("MakeRequestCommand() : UnKnown Command Error"));
		//WriteErrorLog(strLogMsg);
		// 206003 = UnKnown Command Error
		return generateErrorCode(206003);
	}
#endif

	return DEF_RFID_SUCCESS;
}

int MRFID::MakeResponseCommand(ECommandType iCommandType,
							   int iEndCode,
							   char *pFrameMessage,
							   char *pData,
							   int iUnitNo)
{
	char szHeader[2];	// Header
	char szFrameMessage[DEF_MAX_FRAME_MESSAGE_SIZE];
	memset(szFrameMessage, 0x00, sizeof(szFrameMessage));
	CString strLogMsg;

#if defined(V600)
	switch (iCommandType)
	{
	case DEF_COMMAND_READ:					strcpy(szHeader, DEF_HEADER_READ); break;
	case DEF_COMMAND_WRITE:					strcpy(szHeader, DEF_HEADER_WRITE); break;
	case DEF_COMMAND_AUTO_READ:				strcpy(szHeader, DEF_HEADER_AUTO_READ);break;
	case DEF_COMMAND_AUTO_WRITE:			strcpy(szHeader, DEF_HEADER_AUTO_WRITE);break;
	case DEF_COMMAND_POLLING_AUTO_READ:		strcpy(szHeader, DEF_HEADER_POLLING_AUTO_READ);break;
	case DEF_COMMAND_POLLING_AUTO_WRITE:	strcpy(szHeader, DEF_HEADER_POLLING_AUTO_WRITE);break;
	case DEF_COMMAND_CANCEL:				strcpy(szHeader, DEF_HEADER_COMMAND_CANCEL);break;
	case DEF_COMMAND_DATA:					strcpy(szHeader, DEF_HEADER_DATA_COMMAND);break;

	default: 

		// 206003 = UnKnown Command Error
		return generateErrorCode(206003);
	}
#endif

#if defined(OneToOne)

	switch (iCommandType)
	{
	case DEF_COMMAND_READ:
	case DEF_COMMAND_AUTO_READ:
	case DEF_COMMAND_POLLING_AUTO_READ:
		if (pData == NULL)
			// 206004 = Null Data Error
			return generateErrorCode(206004);
		sprintf(szFrameMessage, "%s%2d%s%s", szHeader, iEndCode, pData, DEF_ETX);
		strcpy(pFrameMessage, szFrameMessage);
		break;
	
	case DEF_COMMAND_WRITE:
	case DEF_COMMAND_AUTO_WRITE:
	case DEF_COMMAND_POLLING_AUTO_WRITE:
	case DEF_COMMAND_CANCEL:
	case DEF_COMMAND_DATA:
		sprintf(szFrameMessage, "%s%2d%s", szHeader, iEndCode, DEF_ETX);
		strcpy(pFrameMessage, szFrameMessage);
		break;
	default: 

		// 206003 = UnKnown Command Error
		return generateErrorCode(206003);
	}
#endif

	return DEF_RFID_SUCCESS;
}

int MRFID::ResponseCommandInterpretation(const char *pFrameMessage, char *pData, int *iUnit)
{
	char szMessage[DEF_MAX_FRAME_MESSAGE_SIZE];
	char szData[DEF_MAX_COMMAND_MESSAGE_SIZE];
	int	 iLen = 0;
	char szHeader[3];
	char szEndCode[3];

	CString strLogMsg;

	memset(szMessage, 0x00, sizeof(szMessage));
	memset(szData, 0x00, sizeof(szData));

	strcpy(szMessage, pFrameMessage);
	iLen = strlen(pFrameMessage);

#if defined(OneToOne)
#	if defined(V600)
	strncpy(szHeader, szMessage, 2);
	szHeader[2] = '\0';
	strncpy(szEndCode, szMessage + 2, 2);
	szEndCode[2] = '\0';
#	endif
#endif

	if (!strcmp(szEndCode, DEF_NORMAL_COMPLETION))
	{
		strcpy(pData, "00 : SUCCESS");
		m_bBatteryState = DEF_BATTERY_STATE_GOOD;
		
		return DEF_RESULT_NORMAL_COMPLETION;
	}	
	else if (!strcmp(szEndCode, DEF_PARITY_ERROR))
	{
		strcpy(pData, "10 : Parity Error");
		// 206009 = Parity Error
		return generateErrorCode(206009);
	}
	else if (!strcmp(szEndCode, DEF_FRAMING_ERROR))
	{
		strcpy(pData, "11 : Framing Error");

		// 206010 = Result Framing Error
		return generateErrorCode(206010);
	}
	else if (!strcmp(szEndCode, DEF_OVERRUN_ERROR))
	{
		strcpy(pData, "12 : Over Run Error");

		// 206011 = Result Overrun Error
		return generateErrorCode(206011);
	}
	else if (!strcmp(szEndCode, DEF_FCS_ERROR))
	{
		strcpy(pData, "FCS Error");

		// 206012 = FCS Error
		return generateErrorCode(206012);
	}
	else if (!strcmp(szEndCode, DEF_COMMAND_INPUT_ERROR))
	{
		strcpy(pData, "14 : Message Format Error");

		// 206013 = Result Format Error
		return generateErrorCode(206013);
	}
	else if (!strcmp(szEndCode, DEF_FRAME_LENGTH_MAXIMUM_ERROR))
	{
		strcpy(pData, "18 : Framing Length Error");

		// 206014 = Result Framing Length Error
		return generateErrorCode(206014);
	}
	else if (!strcmp(szEndCode, DEF_DC_COMMUNICATION_ERROR))
	{
		strcpy(pData, "70 : DC Comm Error");

		// 206015 = Result DC Comm Error
		return generateErrorCode(206015);
	}
	else if (!strcmp(szEndCode, DEF_DIS_AGREEMENT_ERROR))
	{
		strcpy(pData, "71 : Dis Agreement Error");

		// 206016 = Result Disagreement Error
		return generateErrorCode(206016);
	}
	else if (!strcmp(szEndCode, DEF_DC_NOT_PRESENT_ERROR))
	{
		strcpy(pData, "72 : DC Not Present Error");
		
		// 206017 = Result DC Not Present Error
		return generateErrorCode(206017);
	}
	else if (!strcmp(szEndCode, DEF_COMMAND_RECEIVED))
	{
		strcpy(pData, "Command Received Error");

		// 206018 = Result Command Received
		return generateErrorCode(206018);
	}
	else if (!strcmp(szEndCode, DEF_COMMAND_AUTO_PROCESSING_CANCELED_BEFOR_COMM))
	{
		strcpy(pData, "Command Auto Processing Canceled Before Comm");

		// 206019 = Result Command Auto Processing Canceled Before Comm
		return generateErrorCode(206019);
	}
	else if (!strcmp(szEndCode, DEF_COMMAND_AUTO_PROCESSING_CANCELED_AFTER_COMM))
	{
		strcpy(pData, "Command Auto Processing Canceled After Comm");

		// 206020 = Result Command Auto Processing Canceled After Comm
		return generateErrorCode(206020);
	}
	else if (!strcmp(szEndCode, DEF_ADDRESS_TOO_HIGH))
	{
		strcpy(pData, "7A : Address Too High");

		// 206021 = Result Address Too High
		return generateErrorCode(206021);
	}
	else if (!strcmp(szEndCode, DEF_LOWER_BATTERY))
	{
		m_bBatteryState = DEF_BATTERY_STATE_SHORTAGE;

		// 206022 = Result Lower Battery
		return generateErrorCode(206022);
	}
	else if (!strcmp(szEndCode, DEF_READ_WRITE_HEAD_NOT_CONNECTED))
	{
		strcpy(pData, "7C : Read/Write Head Not Connected");

		// 206023 = Result Read Write Head Not Connected
		return generateErrorCode(206023);
	}
	else if (!strcmp(szEndCode, DEF_WRITE_PROTECT_ERROR))
	{
		strcpy(pData, "7D : Write Protected Error");

		// 206024 = Result Write Protect Error
		return generateErrorCode(206024);
	}
	else
	{
		strcpy(pData, "Invalid Error");

		// 206025 = Result Invalid Error
		return generateErrorCode(206025);
	}

	strcpy(pData, "Invalid Error");
	return DEF_RESULT_INVALID_ERROR;
}

CString MRFID::ReadData(EZigItemType eZigItemType)
{
	MTickTimer	timerTimeOutCheck;
	char strReceiveResponse[DEF_MAX_FRAME_MESSAGE_SIZE];
	CString strLogMsg;
	char strResponse[100];

	char szFrameMessage[DEF_MAX_FRAME_MESSAGE_SIZE];
	int iResult = 0;
	CString strResult;
	strResult.Empty();

	memset(strResponse,0,sizeof(strResponse));
	memset(strReceiveResponse,0,sizeof(strReceiveResponse));
	EnterCriticalSection((RTL_CRITICAL_SECTION*)&m_Sync);

	// Make Read Command
	memset(szFrameMessage,0,sizeof(szFrameMessage));
	MakeRequestCommand(DEF_COMMAND_READ,	
						szFrameMessage,		
						NULL,				
						m_iHeadNo, 
						m_sZigItem[eZigItemType].m_iStartAddress+MAP_SHIFT, 
						m_sZigItem[eZigItemType].m_iDataLength, 
						m_sZigItem[eZigItemType].m_eDataCodeSpec);
	
	//2005.02.02 hyun szFrameMessage의 소문자 값을 대문자로 변환.... (Command는 대문자만 먹어요.)
	USES_CONVERSION;
	WCHAR* pstWTemp1 = NULL;
	pstWTemp1 = A2W(szFrameMessage);

	CString strCommand;
	strCommand.Format(_T("%s"), pstWTemp1);
//	strCommand.Format(_T("%s"), szFrameMessage);
	strCommand.MakeUpper(); 
	
	WCHAR  pstWTemp[500];
	wcscpy(pstWTemp, strCommand);
	char* pszTemp = NULL;
	pszTemp = W2A(pstWTemp);

	strcpy(szFrameMessage,pszTemp);
		
	// Write command buffer to Serial Port(Actually to Serial Component Queue)
	m_plnkSerialPort->ClearRecvQueue();
	iResult = m_plnkSerialPort->SendData(szFrameMessage);
	Sleep(30);
	if (iResult != DEF_RFID_SUCCESS)
	{
		LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_Sync);	
		return "Data Read Error";
	}

	timerTimeOutCheck.StartTimer();
	while(m_plnkSerialPort->ReceiveData(strReceiveResponse,sizeof(strReceiveResponse)) != DEF_RFID_SUCCESS)
	{
		if (timerTimeOutCheck.MoreThan(1.5))
		{
			LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_Sync);	
			return "Data Read Error";
		}
		Sleep(10);
	}

	iResult = ResponseCommandInterpretation(strReceiveResponse,strResponse);
	if (iResult && generateErrorCode(206022) != iResult)
	{
		LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_Sync);	
		return "Data Read Error";
	}

	LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_Sync);	

	// ML_hongju
	WCHAR* pstWTemp2 = NULL;
	pstWTemp2 = A2W(strReceiveResponse);

	strResult.Format(_T("%s"),pstWTemp2);
//	strResult.Format(_T("%s"),strReceiveResponse);
	
	strResult.Delete(0,4);
	strResult = RemoveSpecialChar(strResult);
	strResult.Remove(' ');
	strResult.Remove('*');
	Sleep(0);
	
	return strResult;
}

int MRFID::WriteData(EZigItemType eZigItemType, char *pData)
{
	MTickTimer	timerTimeOutCheck;
	char strReceiveResponse[DEF_MAX_FRAME_MESSAGE_SIZE];
	CString strLogMsg;

	char szFrameMessage[DEF_MAX_FRAME_MESSAGE_SIZE];
	int iResult = 0;
	CString strResult;
	strResult.Empty();

	int iLength = strlen(pData);
	if (m_sZigItem[eZigItemType].m_iDataLength < iLength)
		// 206008 = Wrong Data Length
		return generateErrorCode(206008);

	memset(strReceiveResponse,0,sizeof(strReceiveResponse));
	EnterCriticalSection((RTL_CRITICAL_SECTION*)&m_Sync);

	// Make Write Command
	memset(szFrameMessage,0,sizeof(szFrameMessage));
	MakeRequestCommand(DEF_COMMAND_WRITE,	
						szFrameMessage,		
						pData,				
						m_iHeadNo, 
						m_sZigItem[eZigItemType].m_iStartAddress+MAP_SHIFT, 
						m_sZigItem[eZigItemType].m_iDataLength, 
						m_sZigItem[eZigItemType].m_eDataCodeSpec);

	//2005.02.02 hyun szFrameMessage의 소문자 값을 대문자로 변환.... (Command는 대문자만 먹어요.)
	USES_CONVERSION;
	WCHAR* pstWTemp1 = NULL;
	pstWTemp1 = A2W(szFrameMessage);

	CString strCommand;
	strCommand.Format(_T("%s"), pstWTemp1);
//	strCommand.Format(_T("%s"), szFrameMessage);
	strCommand.MakeUpper(); 
	
	WCHAR  pstWTemp[500];
	wcscpy(pstWTemp, strCommand);
	char* pszTemp = NULL;
	pszTemp = W2A(pstWTemp);

	strcpy(szFrameMessage,pszTemp); 
	
	// Write command buffer to Serial Port(Actually to Serial Component Queue)
	m_plnkSerialPort->ClearRecvQueue();
	iResult = m_plnkSerialPort->SendData(szFrameMessage);
	Sleep(30);
	if (iResult != DEF_RFID_SUCCESS)
	{
		strLogMsg.Format(_T("WriteData() : Serial Component Data Send Error"));
		LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_Sync);	
		return iResult;
	}

	timerTimeOutCheck.StartTimer();
	while(m_plnkSerialPort->ReceiveData(strReceiveResponse,sizeof(strReceiveResponse)) != DEF_RFID_SUCCESS)
	{
		if (timerTimeOutCheck.MoreThan(1.5))
		{
			//strLogMsg.Format(_T("WriteData() : Timeout(%fmsec) Error"), 500);
			//WriteErrorLog(strLogMsg);
			LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_Sync);

			// 206007 = Data Write Time Out
			return generateErrorCode(206007);
		}
		Sleep(10);
	}

	iResult = ResponseCommandInterpretation(strReceiveResponse, pData);
	if (iResult && generateErrorCode(206022) != iResult)
	{
		strLogMsg.Format(_T("WriteData() : Response Command Error"));
		LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_Sync);	
		return iResult;
	}

	LeaveCriticalSection((RTL_CRITICAL_SECTION*)&m_Sync);	
	return DEF_RFID_SUCCESS;
}

CString MRFID::RemoveSpecialChar(CString sRcvStr)
{
	CString	sOneChar;
	CString sRtnStr=_T("");
	
	//LKH_20090115 : VC++ 2008 충돌
	//CString sC1,sC2,sCt;
	//sC1.Format(_T("%c"),0x20);
	//sC2.Format(_T("%c"),0x7E);
	//sCt.Format(_T("%c"),0x20);
	
	for (int i=0; i<sRcvStr.GetLength(); i++)
	{
		sOneChar = sRcvStr.Mid(i, 1);
		//LKH_20090115 : RFID Test 필요
		//sRtnStr += (0x20<=sOneChar && 0x7E>=sOneChar) ? sOneChar : 0x20;
		sRtnStr += ((WCHAR)0x20<=sOneChar && (WCHAR)0x7E>=sOneChar) ? sOneChar : (WCHAR)0x20;
		//sRtnStr += (sC1<=sOneChar && sC2>=sOneChar) ? sOneChar : sCt;
	}
	sRtnStr.TrimLeft();
	sRtnStr.TrimRight(); 
	
	return sRtnStr;
}

void MRFID::initializeItem()
{
/** V720 적용 맵 */
	SZigRFIDMap sZigItem[DEF_MAX_RFID_ITEM] = 
	{
			//Type					//Start			//End			//Length			//Spec
		{	ZIGID,					0x0006,			0x0011,			12,					DEF_ASCII },	// ZIG ID		
		{	TOT_QTY_AFTER_REG,		0x0012,			0x0019,			8,					DEF_ASCII },	// REGRINDING후 최대 사용 가능 수량
		{	REG_QTY,				0x001A,			0x001B,			2,					DEF_ASCII },	// REGRINDING 횟수
		{	REG_DATE,				0x001C,			0x0023,			8,					DEF_ASCII },	// REGRINDING DATE
		{	MATCODE,				0x0024,			0x002F,			12,					DEF_ASCII },	// MATERIAL CODE
		{	TOT_QTY_ZIG,			0x0030,			0x003F,			16,					DEF_ASCII },	// ZIG 총 사용 가능 수량
		{	ZIG_USED_QTY,			0x0040,			0x0047,			8,					DEF_ASCII },	// ZIG의 총 사용 수량
		{	REG_USED_QTY,			0x0048,			0x004F,			8,					DEF_ASCII }		// REGRIND후 사용 수량
	};

/* V713 적용 맵
	SZigRFIDMap sZigItem[DEF_MAX_RFID_ITEM] = 
	{
			//Type			//Start			//End			//Length			//Spec
		{	ZIGID,			0x0006,			0x0011,			12,					DEF_ASCII },			
		{	TOT_QTY,		0x0012,			0x0019,			8,					DEF_ASCII },			
		{	REG_TQTY,		0x001A,			0x001B,			2,					DEF_ASCII },			
		{	REG_DATE,		0x001C,			0x0023,			8,					DEF_ASCII },			
		{	MATCODE,		0x0024,			0x002F,			12,					DEF_ASCII },			
		{	RESERVED,		0x0030,			0x003F,			16,					DEF_ASCII },			
		{	USED_QTY,		0x0040,			0x0047,			8,					DEF_ASCII },			
		{	REG_UQTY,		0x0048,			0x0049,			2,					DEF_ASCII },			
		{	EQPID_1,		0x004A,			0x004B,			2,					DEF_ASCII },			
		{	EQPID_1_QTY,	0x004C,			0x0053,			8,					DEF_ASCII },			
		{	EQPID_2,		0x0054,			0x0055,			2,					DEF_ASCII },			
		{	EQPID_2_QTY,	0x0056,			0x005D,			8,					DEF_ASCII },			
		{	EQPID_3,		0x005E,			0x005F,			2,					DEF_ASCII },			
		{	EQPID_3_QTY,	0x0060,			0x0067,			8,					DEF_ASCII },			
		{	EQPID_4,		0x0068,			0x0069,			2,					DEF_ASCII },			
		{	EQPID_4_QTY,	0x006A,			0x0071,			8,					DEF_ASCII },			
		{	EQPID_5,		0x0072,			0x0073,			2,					DEF_ASCII },			
		{	EQPID_5_QTY,	0x0074,			0x007B,			8,					DEF_ASCII },			
		{	EQPID_6,		0x007C,			0x007D,			2,					DEF_ASCII },			
		{	EQPID_6_QTY,	0x007E,			0x0085,			8,					DEF_ASCII },			
		{	EQPID_7,		0x0086,			0x0087,			2,					DEF_ASCII },			
		{	EQPID_7_QTY,	0x0088,			0x008F,			8,					DEF_ASCII },			
		{	EQPID_8,		0x0090,			0x0091,			2,					DEF_ASCII },			
		{	EQPID_8_QTY,	0x0092,			0x0099,			8,					DEF_ASCII },			
		{	EQPID_9,		0x009A,			0x009B,			2,					DEF_ASCII },			
		{	EQPID_9_QTY,	0x009C,			0x00A3,			8,					DEF_ASCII },			
		{	EQPID_10,		0x00A4,			0x00A5,			2,					DEF_ASCII },			
		{	EQPID_10_QTY,	0x00A6,			0x00AD,			8,					DEF_ASCII },			
		{	EQPID_11,		0x00AE,			0x00AF,			2,					DEF_ASCII },			
		{	EQPID_11_QTY,	0x00B0,			0x00B7,			8,					DEF_ASCII },			
		{	EQPID_12,		0x00B8,			0x00B9,			2,					DEF_ASCII },			
		{	EQPID_12_QTY,	0x00BA,			0x00C1,			8,					DEF_ASCII },			
		{	EQPID_13,		0x00C2,			0x00C3,			2,					DEF_ASCII },			
		{	EQPID_13_QTY,	0x00C4,			0x00CB,			8,					DEF_ASCII }		
*/

	for (int i=0; i<DEF_MAX_RFID_ITEM; i++)
		m_sZigItem[i] = sZigItem[i];
}
