/* Generated by Together */

#include "StdAfx.h"
#include "MPlatformOlb.h" //100807.ECID
#include "MProductInfoData.h"
#include "MSystemInfo.h"
#include "CommonErrMsgDlg.h"
#include "DataModelDlg.h"
#include "DataModelDlgNew.h"
#include "MTrsAutoManager.h"
#include "DefIOAddrPreBonder.h"
#include "MPlatformOlbSystem.h"
#include "IIO.h"
#include "IAxis.h"
#include "MAxisData.h"
#include "MOpPanel.h"
#include "MManageOpPanel.h"
#include "MCtrlTabFeeder.h"
#include "MTrsPanelAligner.h"
#include "MTrsPanelTransfer.h"
#include "MTrsPanelTransferCenter.h"
#include "MTrsPanelTransferOut.h"
#include "MTrsLoadConveyor.h"
#include "MTrsUnloadConveyor.h"
#include "MTrsTabFeeder.h"
#include "MTrsTabCarrier.h"
#include "MTrsInspectionCamera.h"
#include "MTrsTabMounter.h"
#include "MTrsTHandler.h" //SJ_YYK 161104 Add..
#include "MTabMounter.h"
#include "MPanelAligner.h"
#include "MPanelTransfer.h"
#include "MTabFeeder.h"
#include "MTabCarrier.h"
#include "MProcessData.h"
#include "MFileUtil.h"
#include "MPanelData.h"
#include "MSercosSetup.h"
#include "IVision.h"
#include "MTabData.h"
#include "MAutoAlignData.h" //SJ_YYK 150318 Add..
#include "MHandler.h" //170919 JSH

#include "MRS_NMC_Setup.h"


extern MPlatformOlbSystem	MOlbSystemPre;

//const double DEF_ERROR_REPORT_ENABLE_TIME		= 30.0;
//const int DEF_VALID_TIME_GAP_FOR_ERROR_REPORT	= 5;
const double DEF_ERROR_REPORT_ENABLE_TIME		= 300.0;
const int DEF_VALID_TIME_GAP_FOR_ERROR_REPORT	= 10;

/** 생성자
 * @param commonData		: Component의 CommonData
 * @param listRefComponent	: 참조할 Component 포인터 리스트
 * @param datComponent		: Component 설정 데이타
 */
MTrsAutoManager::MTrsAutoManager(SCommonAttribute commonData, STrsAutoManageRefCompList listRefComponents, STrsAutoManageData datComponent)
: ICommon(commonData)
{//
	m_eOPStatus = STEP_STOP;
	m_eOPMode = MANUAL_MODE;

	m_bThreadLife = FALSE;
	m_pThread = NULL;
	m_pRealTimeThread = NULL;
	m_pMonitoringThread = NULL;
	m_pDoorMonitoringThread	= NULL;	//@DoorLock

	m_pAutoAlignThread = NULL; //SJ_YYK 150318 Add..

	m_hAutoViewWnd = NULL;
	m_hTitleViewWnd = NULL;
	m_plnkManageOpPanel = NULL;
	m_plnkOpPanel = NULL;
	m_plnkMotion = NULL;

	//20100212.kms._______
	m_iStopBtnOnStatus = DEF_STOP_BTN_NONE;
	//____________________

	m_bAutoReady = FALSE;
	m_bErrorProcessing = FALSE;
	m_bMaterialExchange = FALSE;
	m_bEStopPressed = FALSE;
	m_bTPConnected = FALSE;
	m_bDisplayErrorImage = FALSE;
	m_bDisplayManualModeChangeMsg = FALSE;

	m_bStepStopPressed = FALSE; //syr..090508

	m_tmLastError = CTime::GetCurrentTime();
	m_iLastErrorNo = 0;
	m_bPMMode = FALSE;
	m_bOperatorCall = FALSE;

	SetData(datComponent);
	AssignComponents(listRefComponents);

	m_plnkTrsPanelAligner = NULL;
#ifdef DEF_SOURCE_SYSTEM
#	ifdef DEF_USE_TRANSFER_CENTER
	m_plnkTrsPanelTransferCenter = NULL;
#	endif
	m_plnkTrsPanelTransfer = NULL;
#endif
	m_plnkTrsPanelTransferOut = NULL;
	
	for (int i = 0; i < DEF_MAX_TABCARRIER; i++)
	{
		m_plnkTrsTabCarrier[i] = NULL;
		m_plnkTrsRTabCarrier[i] = NULL;
	}
	
	for (int i = 0; i < DEF_MAX_TABFEEDER; i++)
		m_plnkTrsTabFeeder[i] = NULL;
	
	for (int i = 0; i < DEF_MAX_INSPECTION_CAM_CARRIER; i++)
	{
		m_plnkTrsInspectionCamera[i] = NULL;
		m_plnkTrsRInspectionCamera[i] = NULL;
	}

	for (int i = 0; i < DEF_MAX_TABMOUNTER; i++)
	{
		m_plnkTrsTabMounter[i] = NULL;
		m_plnkTrsRTabMounter[i] = NULL;
	}

	m_iHeaterAlarmCount = 0;

	m_iMoldCountAlarmCount1 = -1;
	m_iMoldCountAlarmCount2 = -1;

	for (int i = 0; i < DEF_MAX_PANEL_UNIT; i++)
	{
		m_pGlassData[i] = new MGlassDatas;
		*m_pGlassData[i] = m_plnkProductInfoData->m_Glass[i];
	}

	//20121004 SJ_HJG 횡전개
	m_dTabEndMarkDistance1 = 0.0;
	m_dTabEndMarkDistance2 = 0.0;
	//_________________________
	InitializeCriticalSection(&m_csAlarmProcess);
	InitializeCriticalSection(&m_csMonitoringLog);
	InitializeCriticalSection(&m_csMonitoringLogOp);

	// Melsec 감지 신호 초기화 
	m_bMelsecSwitch = FALSE;
	m_iMelsecAlarmCount = 0;
	m_plnkMelsecIF->SetHandShakeRecoveryAckReply_ToUpperEqBit(FALSE); 
	m_iMonitoringCount = 0;
	m_bEmptyPanel = TRUE;

	m_bManufacturingEmpty = FALSE;

	MFileManager::AutoDeleteFile("..\\Log\\*.*", 50);

	m_iVacuumErrorCounter = 0;

	// TT_Alarm
	m_bTactTimeLogSave = FALSE;
	m_ucLevel = DEF_MLOG_NONE_LOG_LEVEL;

	// NSMC
	m_bInputLastGlass = FALSE;
	m_strNewModelFolderName.Empty();
	m_strNewDeviceID.Empty();
	m_bModelChangeStart = FALSE;
	m_bPanelInStopBeforeAutoMC = FALSE;
	m_bPanelInStopNSMC	= FALSE;
	m_pNSMCLocalData = new MModelChangeWordDatas;
	m_pNSMCLocalData->ResetData();
	m_pNSMCControlData = new MModelChangeWordDatas;
	m_pNSMCControlData->ResetData();
	m_bOldModelChangeDisable = FALSE;
	m_bNSMCTabICChange = FALSE;
	m_iNSMCControlNo = NSMC_CONTROL_EQUIP;
	m_iModelChangeDisableState = DEF_NOT_USE; //syr..SESL 090610
	m_bNSMCWaitingCheckMaterial = FALSE;

	//110324_____
	m_iFeederUseMode = DEF_TABFEEDER_ALL;
	m_b1FeederAllMounterInitStart = FALSE;
	//___________

	//120116.kms_____
	m_bMountAutoChangeInitStart = FALSE;



	//EQ_STOP Report Flag 추가 100121 SJ_YYK
	m_bStepStopState = FALSE;
	m_bErrorStopState = FALSE;

	// hongju_MC : Auto NSMC_INFO에서 입력받은 New Model 정보를 Setting 해주는 부분..
	m_strNewModelName	= _T("");//_T("NONE");

	//110114.kms______
	m_strNewDeviceID	= _T("");//_T("NONE");

	//101204.kms____________
	m_bDoorCheck = FALSE;
	//______________________

	//110721. SJ_YTH_________
	m_bDoorLockCheck = FALSE;
	//_______________________

	//110623________________
	m_bManualPlanMode = FALSE;
	//______________________

	//110624________________
	m_bLastPanelCurProductPlan = FALSE;
	//______________________

	m_strEquipModelName = "";

	
//20110914 SJ_HJG
	m_bLCConnected = TRUE;
	m_bAirCVBlowOff = FALSE;
	//111022 sj_kjs
	IonaizerBlowOnOff(FALSE);
	//___________________________

	// 2011.11.05 Park, YK - //ELLAS_111103
	m_bOldUpperSendAble = FALSE;
	m_bNewUpperSendAble = FALSE;
	m_bOldLowerReceiveAble = FALSE;
	m_bNewLowerReceiveAble = FALSE;

	//120113.kms_________
	m_bModelChangeFlg = FALSE;


	//120116.KMS____________
	m_bMountAutoChangeFlg = FALSE;
	//______________________

	/*/
	//20120126 SJ_HJG
#ifndef DEF_GATE_SYSTEM
	MFileUtil	FileUtil;
	CString strPath;
	strPath.Format(_T("%s"),_T("..\\Log\\AutoAlignLog\\"));
	FileUtil.MakeDir(strPath,FALSE); // 로깅 디렉토리가 존재하지 않을 경우 Directory를 만든다.
#endif
	//___________________
	/*/
	
		//170214 SJ_YSH
	MFileUtil	FileUtil;
	CString strPath;

	strPath.Format(_T("%s"),_T("..\\LogImage\\F_TabAlignImage\\"));
	FileUtil.MakeDir(strPath,FALSE); // 로깅 디렉토리가 존재하지 않을 경우 Directory를 만든다.

	strPath.Format(_T("%s"),_T("..\\LogImage\\F_InspectionImage\\"));
	FileUtil.MakeDir(strPath,FALSE); // 로깅 디렉토리가 존재하지 않을 경우 Directory를 만든다.

	strPath.Format(_T("%s"),_T("..\\LogImage\\R_TabAlignImage\\"));
	FileUtil.MakeDir(strPath,FALSE); // 로깅 디렉토리가 존재하지 않을 경우 Directory를 만든다.

	strPath.Format(_T("%s"),_T("..\\LogImage\\R_InspectionImage\\"));
	FileUtil.MakeDir(strPath,FALSE); // 로깅 디렉토리가 존재하지 않을 경우 Directory를 만든다.

	
	//170927 JSH.s
	strPath.Format(_T("%s"),_T("..\\LogImage\\F_MountAfterImage\\"));
	FileUtil.MakeDir(strPath,FALSE); // 로깅 디렉토리가 존재하지 않을 경우 Directory를 만든다.
	
	strPath.Format(_T("%s"),_T("..\\LogImage\\R_MountAfterImage\\"));
	FileUtil.MakeDir(strPath,FALSE); // 로깅 디렉토리가 존재하지 않을 경우 Directory를 만든다.
	//170927 JSH.e
	//_____________

	// 091028 공정 Key Parameter 측정...
	m_bMeasureProcessData = FALSE;

	//@DoorLock____________
//	m_bAllDoorOpen	=	IsAllDoorOpen();
	m_bFrontDoorOpen	= IsFrontDoorOpen();
	m_bRearDoorOpen		= IsRearDoorOpen();

	//if(FALSE == m_bAllDoorOpen)
	//	LockAllDoor();
	if(FALSE == m_bFrontDoorOpen)
		LockFrontDoor();
	if(FALSE == m_bRearDoorOpen)
		LockRearDoor();
	//@____________________
	//20130612 SJ_HJG
	for (int i = 0; i < 1000; i++)
	{
		m_dMeasProcessData[i] = 0.0;
	}

	//SJ_YYK 150109 Add..
	for (int i=0; i<DEF_MAX_WORKER_GROUP; i++)
	{
		for(int j=0; j<DEF_MAX_WORKER_PER_GROUP; j++)
		{
			m_dTabCarrierAlignResult[i][j] = 0.0;
		}
	}
	//____________________________*/
	m_bAutoAlignDataUpdate = FALSE; //SJ_YYK 150318 Add...
	m_bSetAutoAlignPanelInStop = FALSE; //SJ_YYK 150318 Add..
}

MTrsAutoManager::~MTrsAutoManager()
{
	for (int i = 0; i < DEF_MAX_PANEL_UNIT; i++)
	{
		if (m_pGlassData[i] != NULL)
			delete m_pGlassData[i];
	}

	if (m_pThread != NULL || m_pRealTimeThread != NULL || m_pMonitoringThread != NULL || m_pDoorMonitoringThread != NULL
		|| m_pAutoAlignThread != NULL) //SJ_YYK 150318 Add..
		ThreadStop();

	if (m_pNSMCLocalData != NULL)
		delete m_pNSMCLocalData;

	if (m_pNSMCControlData != NULL)
		delete m_pNSMCControlData;
	
	WriteMonitoringLog("Program End");
}

/**
 * MTrsAutoManage에 Data Parameter를 설정한다. 
 * @param	datcomponent : 설정할 MTrsAutoManage Parameter
 */
int	MTrsAutoManager::SetData(STrsAutoManageData datComponent)
{
	int i = 0;
	m_plnkSystemData		= datComponent.m_plnkSystemData;
	m_plnkProcessData		= datComponent.m_plnkProcessData;
	for (int i = 0; i < DEF_MAX_WORKER_GROUP; i++)
	{
		m_plnkWorkSchedule[i]		= datComponent.m_plnkWorkSchedule[i];
#ifdef DEF_SOURCE_SYSTEM
		m_plnkWorkScheduleSecond[i]	= datComponent.m_plnkWorkScheduleSecond[i];
#endif
	}
	m_plnkProductInfoData	= datComponent.m_plnkProductInfoData;
	m_plnkPanelData			= datComponent.m_plnkPanelData;

	for (int i = 0; i < DEF_MAX_INTERFACE_IO; i++)
	{
		m_rgusUpperIN[i]	= datComponent.m_rgusUpperIN[i];
		m_rgusUpperOUT[i]	= datComponent.m_rgusUpperOUT[i];
		m_rgusLowerIN[i]	= datComponent.m_rgusLowerIN[i];
		m_rgusLowerOUT[i]	= datComponent.m_rgusLowerOUT[i];
	}

	m_plnkAutoAlignData = datComponent.m_plnkAutoAlignData; //SJ_YYK 150318 Add..

	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

/**
 * MTrsAutoManage에 Component List를 설정한다.
 * @param	SACFToolRefCompList : 설정할 MTrsAutoManage Component List
 */
int	MTrsAutoManager::AssignComponents(STrsAutoManageRefCompList listRefComponents)
{
	m_plnkManageOpPanel			= listRefComponents.m_plnkManageOpPanel;
	m_plnkOpPanel				= listRefComponents.m_plnkOpPanel;
	m_plnkMotion				= listRefComponents.m_plnkMotion;                                                      
	m_plnkSystemInfo			= listRefComponents.m_plnkSystemInfo;
	m_plnkIO					= listRefComponents.m_plnkIO;
	m_plnkMelsecIF				= listRefComponents.m_plnkMelsecIF;
	m_plnkMelsecAOCIF			= listRefComponents.m_plnkMelsecAOCIF; //SJ_YYK 150821 Add...
	m_plnkLCNet					= listRefComponents.m_plnkLCNet;
	m_plnkPanelAligner			= listRefComponents.m_plnkPanelAligner;
#ifdef DEF_SOURCE_SYSTEM
#	ifdef DEF_USE_TRANSFER_CENTER
	m_plnkPanelTransferCenter	= listRefComponents.m_plnkPanelTransferCenter;
#	endif
	m_plnkPanelTransfer			= listRefComponents.m_plnkPanelTransfer;
#endif
	m_plnkPanelTransferOut		= listRefComponents.m_plnkPanelTransferOut;

	for (int i = 0; i < DEF_MAX_TABFEEDER; i++)
	{
		m_plnkTabFeeder[i]		= listRefComponents.m_plnkTabFeeder[i];
		m_plnkCtrlTabFeeder[i]	= listRefComponents.m_plnkCtrlTabFeeder[i];
	}
#ifdef DEF_USE_TURN_HANDLER
	m_plnkTrsTHandler			= listRefComponents.m_plnkTrsTHandler; //SJ_YYK 161104 Add..
#endif
	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}
	
/** 
 * Auto Manager의 Thread를 생성 하고 구동 시킨다.
 */
void MTrsAutoManager::ThreadRun()
{
	if (m_bThreadLife)
	{
		ThreadStop();
		Sleep(100);
	}

	CString strStartLog("Program Start : ");
	strStartLog += DEF_VERSION;
	WriteMonitoringLog(strStartLog);

	m_bThreadLife = TRUE;	
	m_pThread = AfxBeginThread(threadFunction, this);
	m_pRealTimeThread = AfxBeginThread(threadRealTimeFunction, this);
	m_pMonitoringThread = AfxBeginThread(threadMonitoringFunction, this);
	m_pDoorMonitoringThread = AfxBeginThread(threadDoorMonitoringFunction, this);	//@DoorLock
	m_pAutoAlignThread = AfxBeginThread(threadAutoAlignFunction, this); // SJ_YYK 150318 Add..

}

/** 
 * Auto Manager의 Thread를 정지 시킨다.
 */
void MTrsAutoManager::ThreadStop()
{
	DWORD exitcode;

	m_bThreadLife = FALSE;

	if (m_pThread != NULL)
	{
		HANDLE hTrs = m_pThread->m_hThread;
		exitcode = ::WaitForSingleObject(hTrs, 10000);
		if (exitcode == WAIT_TIMEOUT)
			::TerminateThread(hTrs, exitcode);
		m_pThread = NULL;
	}

	if (m_pRealTimeThread != NULL)
	{
		HANDLE hTrs = m_pRealTimeThread->m_hThread;
		exitcode = ::WaitForSingleObject(hTrs, 10000);
		if (exitcode == WAIT_TIMEOUT)
			::TerminateThread(hTrs, exitcode);
		m_pRealTimeThread = NULL;
	}

	if (m_pMonitoringThread != NULL)
	{
		HANDLE hTrs = m_pMonitoringThread->m_hThread;
		exitcode = ::WaitForSingleObject(hTrs, 10000);
		if (exitcode == WAIT_TIMEOUT)
			::TerminateThread(hTrs, exitcode);
		m_pMonitoringThread = NULL;
	}

	if (m_pDoorMonitoringThread != NULL)
	{
		HANDLE hTrs = m_pDoorMonitoringThread->m_hThread;
		exitcode = ::WaitForSingleObject(hTrs, 10000);

		if (exitcode == WAIT_TIMEOUT)
			::TerminateThread(hTrs, exitcode);

		m_pDoorMonitoringThread = NULL;
	}
	//SJ_YYK 150318 Add..
	if (m_pAutoAlignThread != NULL)
	{
		HANDLE hTrs = m_pAutoAlignThread->m_hThread;
		exitcode = ::WaitForSingleObject(hTrs, 10000);

		if (exitcode == WAIT_TIMEOUT)
			::TerminateThread(hTrs, exitcode);

		m_pAutoAlignThread = NULL;
	}
}

/** 
 * Auto Manager의 OP Mode를 Return 한다.
 * @return : MANUAL_MODE = Manual MODE
 *           AUTORUN_MODE = Auto Run MODE
 */

EOpMode MTrsAutoManager::GetOPMode()
{

	
	return m_eOPMode;
}

/** 
 * Auto Manager의 OP Status를 Return 한다.
 * @return : ERROR_STOP = Error가 방생되어 정지된 상태4
 *           STEP_STOP	= Stop S/W를 눌러 정지된 상태
 *			 CYCLE_STOP = Cycle S/W를 눌러진 상태
 *           START_RUN	= Start S/W를 눌러 Run전 상태
 *			 RUN		= 정상 운전 상태
 */
EOPStatus MTrsAutoManager::GetOPStatus()
{
	return m_eOPStatus;
}

/** 
 * Auto Manager의 OP Mode를 변경 한다.
 * @param : eOPMode = 변경할 OP Mode
 */
void MTrsAutoManager::SetOPMode(EOpMode eOPMode)
{
	if (eOPMode == MANUAL_MODE)
	{
		MAxisData::eVelocityMode = VELOCITY_MODE_SLOW;

		// NSMC
		if (FALSE == IsLastGlassInput())
		{
			SetPanelInStopNSMC(FALSE);
		}

//		if (FALSE == m_bPMMode && NULL != m_plnkTrsLoadConveyor)
//			m_plnkTrsLoadConveyor->SetPanelInStop(FALSE);
//		if (FALSE == m_bPMMode && NULL != m_plnkTrsPanelTransferCenter)
//			m_plnkTrsPanelTransferCenter->SetPanelInStop(FALSE);

		::SendMessage(m_hAutoViewWnd, WM_AUTO_STATUS, MANUAL_MODE, 0);

		// sesl_jdy
		WriteMonitoringLog("MANUAL_MODE: " + getCurrentEquipState());
		
		//SJ_YYK 110421 Add.. Ellas...
		m_plnkLCNet->EqSpecialStateReport(eManualModeStart);
		// 2011.11.05 Park, YK - //ELLAS_111103
		//ELLAS_110712
		m_plnkMelsecIF->SetMachinePause_ToUpperEqBit(TRUE);
		m_plnkMelsecIF->SetMachinePause_ToLowerEqBit(TRUE);
	}
	else if (eOPMode == AUTORUN_MODE)
	{
		if (TRUE == m_plnkSystemData->m_iVelocityMode)
			MAxisData::eVelocityMode = VELOCITY_MODE_NORMAL;

		::SendMessage(m_hAutoViewWnd, WM_AUTO_STATUS, AUTORUN_MODE, 0);

		// sesl_jdy
		WriteMonitoringLog("AUTORUN_MODE: " + getCurrentEquipState());
		//SJ_YYK 110421 Add... Ellas..
		m_plnkLCNet->EqSpecialStateReport(eAutoRunModeStart);
		// 2011.11.05 Park, YK - //ELLAS_111103
		//ELLAS_110712
		m_plnkMelsecIF->SetMachinePause_ToUpperEqBit(FALSE);
		m_plnkMelsecIF->SetMachinePause_ToLowerEqBit(FALSE);
	}

	//110406.Add_____
	if (GetOPMode() != eOPMode)
	{
		CString strOpMode;
		CString strRunMode;

		if (eOPMode == MANUAL_MODE)
			strOpMode = _T("MANUAL_MODE");
		else if (eOPMode == AUTORUN_MODE)
			strOpMode = _T("AUTORUN_MODE");

		if (m_plnkSystemData->m_eRunMode == NORMAL_RUN_MODE)
			strRunMode = _T("-Normal Run Mode");
		else if (m_plnkSystemData->m_eRunMode == PASS_RUN_MODE)
			strRunMode = _T("-Pass Run Mode");
		else if (m_plnkSystemData->m_eRunMode == DRY_RUN_MODE)
			strRunMode = _T("-Dry Run Mode");

		WriteMonitoringLogOp(strOpMode+strRunMode);
	}
	//_______________

	m_eOPMode = eOPMode;

	
//	if (m_plnkLCNet->m_eEqState == ePM && m_plnkTrsLoadConveyor != NULL)
//		m_plnkTrsLoadConveyor->SetPanelInStop(TRUE);
//	if (m_plnkLCNet->m_eEqState == ePM && m_plnkTrsPanelTransferCenter != NULL)
//		m_plnkTrsPanelTransferCenter->SetPanelInStop(TRUE);
}

/** 
 * Auto Manager의 OP Status를 변경 한다.
 * @param : eOPStatus = 변경할 OP Status
 */
void MTrsAutoManager::SetOPStatus(EOPStatus eOPStatus)
{
	//110406.Add_____
	if (GetOPStatus() != eOPStatus)
	{
		CString strOpStatus;
		CString strRunMode;

		if (eOPStatus == INIT_STATUS)
			strOpStatus = _T("INIT_STATUS");
		else if (eOPStatus == ERROR_STOP)
			strOpStatus = _T("ERROR_STOP");
		else if (eOPStatus == CYCLE_STOP)
			strOpStatus = _T("CYCLE_STOP");
		else if (eOPStatus == STEP_STOP)
			strOpStatus = _T("STEP_STOP");
		else if (eOPStatus == START_RUN)
			strOpStatus = _T("START_RUN");
		else if (eOPStatus == RUN)
			strOpStatus = _T("RUN");

		if (m_plnkSystemData->m_eRunMode == NORMAL_RUN_MODE)
			strRunMode = _T("-Normal Run Mode");
		else if (m_plnkSystemData->m_eRunMode == PASS_RUN_MODE)
			strRunMode = _T("-Pass Run Mode");
		else if (m_plnkSystemData->m_eRunMode == DRY_RUN_MODE)
			strRunMode = _T("-Dry Run Mode");

		WriteMonitoringLogOp(strOpStatus+strRunMode);
	}
	//_______________
	
	m_eOPStatus = eOPStatus;
}

void MTrsAutoManager::AssignProcess(STrsAutoManagerRefProcess listRefTrs)
{
	m_plnkTrsPanelAligner			= listRefTrs.m_plnkTrsPanelAligner;
#ifdef DEF_SOURCE_SYSTEM
#	ifdef DEF_USE_TRANSFER_CENTER
	m_plnkTrsPanelTransferCenter	= listRefTrs.m_plnkTrsPanelTransferCenter;
#	endif
	m_plnkTrsPanelTransfer			= listRefTrs.m_plnkTrsPanelTransfer;
#endif
	m_plnkTrsPanelTransferOut		= listRefTrs.m_plnkTrsPanelTransferOut;

	for (int i = 0; i < DEF_MAX_TABCARRIER; i++)
	{
		m_plnkTrsTabCarrier[i]	= listRefTrs.m_plnkTrsTabCarrier[i];
		m_plnkTrsRTabCarrier[i]	= listRefTrs.m_plnkTrsRTabCarrier[i];
	}
	for (int i = 0; i < DEF_MAX_TABFEEDER; i++)
		m_plnkTrsTabFeeder[i]	= listRefTrs.m_plnkTrsTabFeeder[i];

	for (int i = 0; i < DEF_MAX_INSPECTION_CAM_CARRIER; i++)
	{
		m_plnkTrsInspectionCamera[i] = listRefTrs.m_plnkTrsInspectionCamera[i];
		m_plnkTrsRInspectionCamera[i] = listRefTrs.m_plnkTrsRInspectionCamera[i];
	}

	for (int i = 0; i < DEF_MAX_TABMOUNTER; i++)
	{
		m_plnkTrsTabMounter[i]	= listRefTrs.m_plnkTrsTabMounter[i];
		m_plnkTrsRTabMounter[i]	= listRefTrs.m_plnkTrsRTabMounter[i];
	}

#ifdef DEF_USE_TURN_HANDLER
	m_plnkTrsTHandler			= listRefTrs.m_plnkTrsTHandler;
#endif
}

void MTrsAutoManager::SetWindowHandle(HWND hWnd)
{
	m_hAutoViewWnd = hWnd;
}

HWND MTrsAutoManager::GetAutoViewHandle()
{
	return m_hAutoViewWnd;
}

// ML_hongju
void MTrsAutoManager::SetManualViewHandle(HWND hWnd)
{
	m_hManualViewWnd = hWnd;
}

HWND MTrsAutoManager::GetManualViewHandle()
{
	return m_hManualViewWnd;
}
void MTrsAutoManager::SetDataViewHandle(HWND hWnd)
{
	m_hDataViewWnd = hWnd;
}

HWND MTrsAutoManager::GetDataViewHandle()
{
	return m_hDataViewWnd;
}
void MTrsAutoManager::SetTeachViewHandle(HWND hWnd)
{
	m_hTeachViewWnd = hWnd;
}

HWND MTrsAutoManager::GetTeachViewHandle()
{
	return m_hTeachViewWnd;
}

void MTrsAutoManager::SetTitleWindowHandle(HWND hWnd)
{
	m_hTitleViewWnd = hWnd;
}

HWND MTrsAutoManager::GetTitleViewHandle()
{
	return m_hTitleViewWnd;
}

/** Log View Window Handler 을 Member 로 저장한다. */
void MTrsAutoManager::SetLogViewHandle(HWND hWnd)
{
	m_hLogViewWnd = hWnd;
}

HWND MTrsAutoManager::GetLogViewHandle()
{
	return m_hLogViewWnd;
}

/** 
 * Auto Manager Alarm 처리 함수
 * @param : iProcessID = Alarm이 발생된 Process ID
 *          iErrorCode = Error Code
 */
int MTrsAutoManager::ProcessAlarm(ErrorInfo errorInfo)
{
	BOOL bDisplayEStopError = FALSE;
	int iEStopError[] =
	{
		400030,	// 400030 = 자동운전 중 비상정지 스위치가 눌려졌습니다.
		400031,	// 400031 = 자동운전 중 Door Open이 감지 되었습니다.
		400033,	// 400033 = 자동운전 중 Air Error가 감지 되었습니다.
		0		// 0은 종료 조건
	};

	for (int i = 0; iEStopError[i] != 0; i++)
	{
		if (iEStopError[i] == int(iErrorCode/1000))
			bDisplayEStopError = TRUE;
	}

	::EnterCriticalSection(&m_csAlarmProcess);
	if (FALSE == m_bErrorProcessing)
	{
		m_bErrorProcessing = TRUE;
	}
	else
	{
		if (iErrorCode == m_iLastErrorNo || FALSE == bDisplayEStopError)
		{
			::LeaveCriticalSection(&m_csAlarmProcess);
			return ERR_TRS_AUTO_MANAGER_SUCCESS;	// 이미 Alarm이 처리 중인 경우
		}
		
		while (TRUE == m_bErrorProcessing)
		{
			Sleep(100);
		}
		m_bErrorProcessing = TRUE;
	}
	::LeaveCriticalSection(&m_csAlarmProcess);
	
	SetOPStatus(ERROR_STOP);	// System을 ERROR_STOP으로 전환한다.

	CString strProcessName	= m_plnkSystemInfo->GetObjectName(iProcessID);
	CString strUnitName		= GetObjectName(iErrorCode);
	CString strErrorMsg		= MOlbSystemPre.GetErrorMessage(iErrorCode);
	//100210.kms.modify
	//

	//100826.KMS
	CString strEngErrMsg	= MOlbSystemPre.GetErrorMessage(iErrorCode, LANGUAGE_ENGLISH);
	CString strReportMsg	= MOlbSystemPre.GetErrorMessage(iErrorCode, LANGUAGE_ENGLISH, TRUE);//170930 JSH
//	CString strEngErrMsg	= MOlbSystemPre.GetErrorMessage(iErrorCode, LANGUAGE_KOREAN);

	/* jdy sesl 081230 : 이 함수 호출 이전에 WriteLog() 호출해서 LogItem 생성해 놓지 않은 이상
	//                   여기서 LogItem 사용하는 것은 아무 의미 없다.
	CString strFileName		= sLogItem.m_strFileName;
	CString strLogItemMsg	= sLogItem.m_strLogMsg;
	int		iLineNumber		= sLogItem.m_iLineNumber;
	*/

	// 자재 교체 및 경고성 Message는 Report 하지 않는다.
	BOOL bReportError = isErrorReportCode(iErrorCode / 1000);


	//130320.kms___________
	//현재 입력 받은 Error Code 와 가지고 있는 Data 와 비교 하여 상위 보고 안한다.
	//최대 갯수:30개
	CString sCompareErrorNo;
	for (int i = 0; i<DEF_MAX_ERROR_NOT_SEND; i++)
	{
		sCompareErrorNo.Format(_T("%d"), iErrorCode / 1000);
		if(m_plnkSystemData->m_strErrorNo[i] == sCompareErrorNo)
		{
			bReportError = FALSE;
			break;
		}
	}
	//_____________________
	
	CTimeSpan tmSpan;
	CTime t = CTime::GetCurrentTime();
	CString strTime = t.Format(", %m/%d-%H:%M:%S");
	tmSpan = t - m_tmLastError;

	// AutoRun 진입 후 Error Reporting 가능 시간이 초과했는지 확인
	if (m_timerSkipError.IsTimerStarted())
	{
		if (m_timerSkipError.LessThan(DEF_ERROR_REPORT_ENABLE_TIME))
			bReportError = FALSE;
		else
			m_timerSkipError.StopTimer();
	}

	// Error 발생 후 5분 이내의 Error 는 Report 하지 않는다.
	if (tmSpan.GetTotalMinutes() < DEF_VALID_TIME_GAP_FOR_ERROR_REPORT
		&& iErrorCode == m_iLastErrorNo)
	{
		bReportError = FALSE;
	}

	//120110.kms_______
	if(m_plnkSystemData->m_dStopperArrivingDelay == 1.1)
		bReportError = FALSE;
	//_________________

	//120113.KMS_________
	if(GetModelChangeAlarmReport() == TRUE)
		bReportError = FALSE;
	//___________________

	//120228.kms_________________
	// Model Change 이후 1시간 동안은 Report하지 않는다.
	// Heater Alarm 및 기타 Change후 안정화 시간
	if(m_tChangeModelTimer.IsTimerStarted())
	{
		if(!m_tChangeModelTimer.MoreThan(3600))
			bReportError = FALSE;
		else
			m_tChangeModelTimer.StopTimer();
	}

	CString strMsg;
	// jdy sesl 081230 : Msg 표시 부분 키우기.
	strMsg.Format(_T("%s (%d)"), strErrorMsg, iErrorCode/1000);

	CCommonErrMsgDlg dlgErrorMsg;
	dlgErrorMsg.SetTextMsg(	strProcessName.GetBuffer(strProcessName.GetLength()),
							strUnitName.GetBuffer(strProcessName.GetLength()),
							strMsg.GetBuffer(strMsg.GetLength()),
							_T(""),
							ML_ERROR);

	// new line 처리.
	strMsg.Replace('\n', ' ');
	strErrorMsg.Replace('\n', ' ');
	strEngErrMsg.Replace('\n', ' ');
	strReportMsg.Replace('\n', ' '); //170930 JSH
	// selsk_jdy
	strMsg.Remove('\r');
	strErrorMsg.Remove('\r');
	strEngErrMsg.Remove('\r');
	strReportMsg.Remove('\r');//170930 JSH
	
	WriteMonitoringLog("alarm On:" + strEngErrMsg + " " + getCurrentEquipState());
 
	// Error Report
	if (GetOPMode() == AUTORUN_MODE && m_plnkLCNet->m_eEqState != ePM)
	{
		m_plnkLCNet->AlarmDataReport(1,				//Alram On/off
									iErrorCode,		//error number
									0,				//Error Category
									strReportMsg//170930 JSH
									);

		if (m_plnkLCNet->m_eEqState != eFault)
		{
			m_plnkLCNet->EqStateReport(eFault, _T("NONE"), iErrorCode, strReportMsg);
			::SendMessage(m_hAutoViewWnd, WM_DISP_EQ_STATE,(WPARAM)(eFault),NULL);
		}

		if (m_plnkLCNet->m_eEqProcState != ePause)
		{
			m_plnkLCNet->EqProcessStateReport(ePause, iErrorCode, strReportMsg);
			::SendMessage(m_hAutoViewWnd, WM_DISP_EQP_STATE,(WPARAM)(ePause),NULL);
		}
	}

	dlgErrorMsg.DoModal();

	//if (GetOPMode() == AUTORUN_MODE && bReportError && m_plnkLCNet->m_eEqState != ePM)
	if (GetOPMode() == AUTORUN_MODE && m_plnkLCNet->m_eEqState != ePM)  //170316 SJ_YSH 박종호K 요청
	{
		m_plnkLCNet->AlarmDataReport(0,				//Alram On/off
									iErrorCode,		//error number
									0,				//Error Category
									//strEngErrMsg	//Error Text
									strReportMsg//170930 JSH
									);

		if (m_plnkLCNet->m_eEqProcState != ePause)
		{
			m_plnkLCNet->EqProcessStateReport(ePause);
			::SendMessage(m_hAutoViewWnd, WM_DISP_EQP_STATE,(WPARAM)(ePause),NULL);
		}
	}

	// ErrorList에 저장하기 Log View에서 보기 위해
	
	//180109_KDH Test
 	//if (GetOPMode() == AUTORUN_MODE || iErrorCode == 400035000 || iErrorCode == 400006000)
	{
		// ErrorList 에 저장하기 : Log View 에서 보기 위해
		CString strErrorCode;
		strErrorCode.Format(_T("[%d]"), iErrorCode);
		CString strSaveErrMsg = strEngErrMsg;

		strSaveErrMsg.Replace('\n', ' ');
		strSaveErrMsg.Remove('\r');

		MLanguageManager::WriteErrorListMessage(strSaveErrMsg);
		WriteMonitoringLog("alarm Off:" + strErrorCode + " " + getCurrentEquipState());
		m_tmLastError = CTime::GetCurrentTime();
		m_iLastErrorNo = iErrorCode;
	}
	//test
	//::SendMessage(m_hLogViewWnd, WM_REFRESH_LOG_MAIN_WINDOW, DEF_ERROR_LOG, NULL);

	m_bErrorProcessing = FALSE;
	SetOPStatus(STEP_STOP);	// STEP STOP으로 전환한다.

	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

/** 
 * Auto Manager OP Panel 감시 함수
 * @param : iErrorCode = Error Code
 */
int	MTrsAutoManager::processOpPanel()
{
	//20100212.kms____________________
	BOOL bIsFrontStopBtn;

	// 장비 STEP_STOP Switch Check	
	if(m_plnkOpPanel->GetStopButtonStatus(&bIsFrontStopBtn))	
	{
		if(bIsFrontStopBtn)
		{
			m_iStopBtnOnStatus = DEF_STOP_BTN_FRONT;
		}
		else
		{
			m_iStopBtnOnStatus = DEF_STOP_BTN_BACK;
		}	
		
		SetOPStatus(STEP_STOP);	// System을 STEP_STOP으로 전환한다.
		Sleep(300);
	}
	else
	{
		m_iStopBtnOnStatus = DEF_STOP_BTN_NONE;
	}
	//____________________________________

//NSMC
	if (TRUE == m_plnkSystemData->m_bUseAutoModelChange
		&& TRUE == GetModelChangeReserveBit())
	{
		if (FALSE == m_bInputLastGlass)	// Last Glass 인 경우.
		{
			m_bInputLastGlass = TRUE;		
			SetPanelInStopNSMC(TRUE);
			m_plnkMelsecIF->SetNSMCBit(eModelChangeReserve, TRUE);

			m_plnkMelsecIF->GetNSMCWord(m_pNSMCControlData, m_iNSMCControlNo);
			m_pNSMCLocalData->m_strDeviceID = m_pNSMCControlData->m_strDeviceID;

			m_plnkSystemData->m_strCurrentDeviceID = m_pNSMCLocalData->m_strDeviceID;
			m_plnkSystemData->WriteData();

			CString strLog;
			strLog.Format(_T("ReserveBit On, EmptyPanel:%d, CurrentDeviceID:%s, NewDeviceID:%s, EQState:%s, ReplyCode:%s, PanelWIPs:%s"),
				m_bEmptyPanel, 
				m_plnkSystemData->m_strCurrentDeviceID,
				m_pNSMCLocalData->m_strDeviceID,
				m_pNSMCLocalData->m_strEQState,
				m_pNSMCLocalData->m_strReplyCode,
				m_pNSMCLocalData->m_strPanelWIP);

			WriteMonitoringLog(strLog);

			// AutoView DeviceID Display
			::SendMessage(m_hAutoViewWnd, WM_DISP_MODEL_DEVICEID, NULL, NULL);
		}
	}

	m_bEmptyPanel = isNoPanelInEquipment();
	
	if (TRUE == m_bEmptyPanel && TRUE == m_bInputLastGlass)
	{
		Sleep(100);
		m_bEmptyPanel = isNoPanelInEquipment();
	}

	// NSMC ________________________________________________________________________________________________________________________
	// Panel 빠진 거 확인해서 처리.
	//NSMC KJS EmptyPanel 확인 
	if (FALSE == m_bModelChangeStart
		&& TRUE == m_plnkSystemData->m_bUseAutoModelChange
		&& TRUE == m_bInputLastGlass
		&& TRUE == m_bEmptyPanel
		)
	{
		// SESL의 경우 OLB Loader, L/C 에게 기종변경 시작했다는 것을 알려줘야함.
		// ManageGlassData에서 하는 일도 이 코드에서 완료 해야 할것 같음..(기존은 Panel 지나갈때마다, SESL은 전체를 한번만 하면 됨)

		// hongju_MC : 수동일때 이 부분만 변경하면 됨...
		m_strNewModelFolderName = GetNewModelName();

		// NSMC KJS 동종 모델 변경
		if (m_plnkSystemData->m_strModelFileName == m_strNewModelFolderName)
		{
			m_plnkMelsecIF->SetNSMCBit(eModelChangeStart, TRUE);
			// 2011.11.05 Park, YK - //ELLAS_111103
			m_plnkLCNet->EqSpecialStateReport(eOneTouchModelChange, EMaterialType(0));
			m_plnkLCNet->ModelChangeReport(eMCStart, m_pNSMCLocalData->m_strDeviceID);
			Sleep(1000);

			m_plnkMelsecIF->SetNSMCBit(eModelChangeStart, FALSE);
			m_plnkMelsecIF->SetNSMCBit(eModelChangeComplete, TRUE);
			// 2011.11.05 Park, YK - //ELLAS_111103
			m_plnkLCNet->EqSpecialStateReport(eOneTouchModelChange, EMaterialType(1));
			m_plnkLCNet->ModelChangeReport(eMCComplete, m_pNSMCLocalData->m_strDeviceID);
	
			MTickTimer tmLoaderInterface;
			tmLoaderInterface.StartTimer();
			while (1)
			{
				if (tmLoaderInterface.MoreThan(5.0))
					break;
				
				if (FALSE == GetModelChangeReserveBit())
					break;
				
				Sleep(100);
			}		
			Sleep(1000);
			
			m_plnkMelsecIF->SetNSMCBit(eModelChangeComplete, FALSE);

			m_plnkMelsecIF->SetNSMCBit(eModelChangeReserve, FALSE);

			SetPanelInStopNSMC(FALSE);
			ResetAutoModelChagneFlag();
			WriteMonitoringLog("동종 모델 변경 완료");
		}
		//NSMC KJS 이종 모델 변경
		else
		{
			if (m_strNewModelFolderName.IsEmpty() || m_strNewDeviceID.IsEmpty())
			{
				ResetAutoModelChagneFlag();

				// 400026 = DeviceID 와 Matching 되는 Model ID 를 찾을 수 없습니다.
				return PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400026));
			}

			// hongju_SELSK : 기종변경후 None으로 바뀌고 다시 기종 변경 명령이 내려 올때 대비해서.
			if (_T("NONE") == m_strNewModelFolderName)
			{
				ResetAutoModelChagneFlag();

				// 400026 = DeviceID 와 Matching 되는 Model ID 를 찾을 수 없습니다.
				return PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400026));
			}
			::SendMessage(m_hAutoViewWnd, WM_DISP_RUN_MODE, NULL, NULL);

			m_bModelChangeStart = TRUE;
			
			Sleep(500);//101007.KKY.다른 Thread에서 m_bModelChangeReady=FALSE 할 시간을 주기 위해...

			::PostMessage(m_hTitleViewWnd, WM_DISP_PROGRESS_DLG_FOR_AUTO_MODEL_CHANGE, TRUE, NULL);

			WriteMonitoringLog("Auto Model Change Start.");
		}
	}

	//NSMC KJS
	if (TRUE == m_bModelChangeStart)
	{
		if (isAllModelChangeReady())
		{
			m_plnkSystemData->m_strCurrentDeviceID = m_pNSMCLocalData->m_strDeviceID;
			m_plnkSystemData->WriteData();

			m_plnkMelsecIF->SetNSMCBit(eModelChangeStart, TRUE);
			// 2011.11.05 Park, YK - //ELLAS_111103
			m_plnkLCNet->EqSpecialStateReport(eOneTouchModelChange, EMaterialType(0));
			m_plnkLCNet->ModelChangeReport(eMCStart, m_pNSMCLocalData->m_strDeviceID);

			int iResult = MOlbSystemPre.RemoveTabIC(DEF_FRONT_GROUP);
			if (iResult)
			{
				SetPanelInStopNSMC(FALSE);
				ResetAutoModelChagneFlag();
				return iResult;
			}
			iResult = MOlbSystemPre.RemoveTabIC(DEF_REAR_GROUP);
			if (iResult)
			{
				SetPanelInStopNSMC(FALSE);
				ResetAutoModelChagneFlag();
				return iResult;
			}

			if (PASS_RUN_MODE != m_plnkSystemData->m_eRunMode
				&& TRUE == m_plnkSystemData->m_bUseMaterialDeviceID)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matTabICInfo[DEF_USING_REEL].m_nM_STATE = eMatStateIdle;
				m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matTabICInfo[DEF_SPARE_REEL].m_nM_STATE = eMatStateIdle;
				/*
#ifdef DEF_GATE_SYSTEM
				m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matTabICInfo[DEF_USING_REEL].m_nM_STATE = eMatStateIdle;
				m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matTabICInfo[DEF_SPARE_REEL].m_nM_STATE = eMatStateIdle;
#endif
				*/
				m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matTabICInfo[DEF_USING_REEL].m_nM_STATE = eMatStateIdle;
				m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matTabICInfo[DEF_SPARE_REEL].m_nM_STATE = eMatStateIdle;

				m_bNSMCWaitingCheckMaterial = TRUE;
			}

			iResult = MOlbSystemPre.ChangeModel(m_strNewModelFolderName, m_bModelChangeStart);
			m_strNewModelFolderName.Empty();

			if (iResult)
			{
				SetPanelInStopNSMC(FALSE);
				ResetAutoModelChagneFlag();
				m_bNSMCWaitingCheckMaterial = FALSE;
				return iResult;
			}

			for (int i = 0; i < DEF_MAX_WORKER_GROUP; i++)
				m_plnkWorkSchedule[i]->ClearWorkSchedule();
			m_plnkWorkSchedule[0]->SetExistWorkPanel(FALSE);
			

			m_plnkMelsecIF->SetNSMCBit(eModelChangeStart, FALSE);
			m_plnkMelsecIF->SetNSMCBit(eModelChangeComplete, TRUE);
			// 2011.11.05 Park, YK - //ELLAS_111103
			m_plnkLCNet->EqSpecialStateReport(eOneTouchModelChange, EMaterialType(1));
			m_plnkLCNet->ModelChangeReport(eMCComplete, m_pNSMCLocalData->m_strDeviceID);
			
			MTickTimer tmLoaderInterface;
			tmLoaderInterface.StartTimer();
			while (1)
			{
				if (tmLoaderInterface.MoreThan(60.0))
					break;
				
				if (FALSE == GetModelChangeReserveBit())
					break;
				
				Sleep(100);
			}
			Sleep(1000);

			m_plnkMelsecIF->SetNSMCBit(eModelChangeComplete, FALSE);
			m_plnkMelsecIF->SetNSMCBit(eModelChangeReserve, FALSE);

			PrepareAfterMC();

			ResetAutoModelChagneFlag();
			
			SetPanelInStopNSMC(FALSE);

			// AutoView Model Name Display
			
			::SendMessage(m_hAutoViewWnd, WM_DISP_MODEL_NAME, NULL, NULL);

			// AutoView DeviceID Display
			::SendMessage(m_hAutoViewWnd, WM_DISP_MODEL_DEVICEID, NULL, NULL);

			::PostMessage(m_hTitleViewWnd, WM_DISP_PROGRESS_DLG_FOR_AUTO_MODEL_CHANGE, FALSE, NULL);

			// SESL의 경우 이 부분에서 OLB Loader에게 기종변경 완료되었다고 알려주어야 함..

			WriteMonitoringLog("Auto Model Change Complete.");
			CString strTemp;
			strTemp.Empty();
			SetNewModelName(strTemp);

			if (PASS_RUN_MODE != m_plnkSystemData->m_eRunMode)
			{
				CString strEqCmd;
				strEqCmd.Format(_T("Check the TABIC Material. After Initialize, Start."));
				
//				::SendMessage(m_hAutoViewWnd, WM_DISP_OPCALL_MSG, (WPARAM)(&strEqCmd), NULL);
				SetOperatorCall(TRUE, strEqCmd);
				SetOPStatus(STEP_STOP);	// System을 STEP_STOP으로 전환한다.

			}
		}
	}

	
	// 장비 STEP_STOP Switch Check	
	if (m_plnkManageOpPanel->GetStopSWStatus())
	{
		if (!m_bStepStopPressed) //syr..090508
		{
			m_bStepStopPressed = TRUE;
		}

		SetOPStatus(STEP_STOP);
		WriteMonitoringLog("StepStop Button Pressed");
	}

	// 장비 E-STOP Switch Check	& Door Open Check
	if (TRUE == m_plnkOpPanel->GetEStopButtonStatus())
	{
		if (TRUE == m_plnkSystemData->m_bSafetySensor && TRUE == IsDoorOpen())
		{
			PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400031));// 400031 = 자동운전 중 Door Open이 감지 되었습니다.
		}
		else
		{
			PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400030)); // Error Display 이외의 다른 처리는 threadRealTimeJob() 에서 담당한다.
		}
	}

	// jdy2
	// 장비 Door Open Check
	//SESL_LKH_090711 : m_bSafetySensor와 통합
	if (TRUE == m_plnkSystemData->m_bSafetySensor
		//&& TRUE == m_plnkOpPanel->GetSafeDoorStatus())
		&& TRUE == IsDoorOpen())
	{
//@		if ((m_plnkIO->IsOff(IN_FRONT_DOOR2_LOCK)
//@			|| m_plnkIO->IsOff(IN_FRONT_DOOR3_LOCK))
//@			)
		{
			CString strDoorStatus;
			strDoorStatus.Format(_T("Door error: %d"),
				m_plnkOpPanel->GetSafeDoorStatus());
			WriteMonitoringLog(strDoorStatus + getCurrentEquipState());
			
			/** 모든 축을 E-Stop 시킨다. */ // 2009.02.12 CYJ
			//EStopAllAxis();
			//		resetAllInitialized();
			
			// 400031 = 자동운전 중 Door Open이 감지 되었습니다.
			PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400031));
		}
	}
/*	
	if (TRUE == m_plnkSystemData->m_bSafetySensor)
	{
		if(m_plnkIO->IsOff(IN_FRONT_RECOVERY_BOX))
		{
			SetErrorLevel(_T("AUTO MANAGER process OpPanel"), 0, __FILE__, __LINE__);
			// 400036 = 자동운전 중 전면부 하부 회수통 Door Open이 감지 되었습니다.
			PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400036));
		}

		if(m_plnkIO->IsOff(IN_REAR_RECOVERY_BOX))
		{
			SetErrorLevel(_T("AUTO MANAGER process OpPanel"), 0, __FILE__, __LINE__);
			// 400037 = 자동운전 중 후면부 하부 회수통 Door Open이 감지 되었습니다.
			PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400037));
		}
	}
*/	

// selsk_jdy
#if (!defined(SIMULATION) && !defined(DEF_SETUP))
	if (TRUE == m_plnkSystemData->m_bSafetySensor)
	{	
		//1. 전 설비 상태 확인
		if (!m_plnkIO->IsOn(m_rgusUpperIN[eNetReady]))
		{
			SetErrorLevel(_T("AUTO MANAGER check Pre Equipment"), 0, __FILE__, __LINE__);
			return PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400040));	
		}

		if (!m_plnkIO->IsOn(m_rgusUpperIN[eEmergency]))
		{
			SetErrorLevel(_T("AUTO MANAGER check Pre Equipment"), 0, __FILE__, __LINE__);
			return PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400041));	
		}

		//2. 다음 설비 상태 확인
		if (!m_plnkIO->IsOn(m_rgusLowerIN[eNetReady]))
		{
			SetErrorLevel(_T("AUTO MANAGER check Next Equipment"), 0, __FILE__, __LINE__);
			return PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400043));	
		}

		if (!m_plnkIO->IsOn(m_rgusLowerIN[eEmergency]))
		{
			SetErrorLevel(_T("AUTO MANAGER check Next Equipment"), 0, __FILE__, __LINE__);
			return PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400044));	
		}
	}

	// selsk_jdy
//#ifndef SIMULATION

	/** Air 확인 */	
/* 20080914 임시
	if (m_plnkOpPanel->GetAirErrorStatus())
	{
		m_plnkIO->OutputOff(m_rgusUpperOUT[eEmergency]);
		m_plnkIO->OutputOff(m_rgusLowerOUT[eEmergency]);
		Sleep(1);

//		resetAllInitialized();

		// 400033 = Main Air 이상이 감지 되었습니다.
		PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400033));
	}
*/
	/** Vacuum 확인 */
	if (m_plnkOpPanel->GetVacuumErrorStatus())
	{
		if (m_iVacuumErrorCounter < 50)
			m_iVacuumErrorCounter++;
		else
		{
			// sesl_jdy 위치 변경.
			// 임시 : H/W 문제 확인 후 제거할 것. 확인 필요.
			CString strVacStatus;
//@			strVacStatus.Format(_T("vacuum error: %d %d %d %d "),
//@				m_plnkIO->IsOff(IN_MAIN_VACUUM1), m_plnkIO->IsOff(IN_MAIN_VACUUM2),
//@				m_plnkIO->IsOff(IN_MAIN_VACUUM3), m_plnkIO->IsOff(IN_MAIN_VACUUM4));
			strVacStatus.Format(_T("vacuum error: %d "), m_plnkIO->IsOff(IN_MAIN_VACUUM1));
			WriteMonitoringLog(strVacStatus + getCurrentEquipState());

			SetErrorLevel(_T("AUTO MANAGER check Vacuum"), 0, __FILE__, __LINE__);
			PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400034));
			m_iVacuumErrorCounter = 0;
		}
	}
	else
		m_iVacuumErrorCounter = 0;
#endif
	
	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

int MTrsAutoManager::processNetState()
{
	int i = 0;
	int iResult = 0;
	// RequestEquipmentCmd
	CString strEqCmd;

	//110808 SJ_KJS
	CString strM_Code;
	BOOL bCodeOK = FALSE;
	CString strPortID1, strPortID2 , strPortID3, strPortID4, strPortID5, strPortID6;
	strPortID1 = m_plnkSystemData->m_strModulePortID[0];
	strPortID2 = m_plnkSystemData->m_strModulePortID[1];
	strPortID3 = m_plnkSystemData->m_strModulePortID[2];
	strPortID4 = m_plnkSystemData->m_strModulePortID[3];
	//20121105 SJ_HJG 추가
	strPortID5 = m_plnkSystemData->m_strModulePortID[4];
	strPortID6 = m_plnkSystemData->m_strModulePortID[5];
	//________________________________________________

	if (m_plnkLCNet->m_iaEquipmentCmd.GetSize() != 0)
	{
		EEqCmd eEqCmd = (EEqCmd)m_plnkLCNet->m_iaEquipmentCmd.GetAt(0);
		strEqCmd = m_plnkLCNet->m_saEquipmentCmd.GetAt(0);
		m_plnkLCNet->m_iaEquipmentCmd.RemoveAt(0);
		m_plnkLCNet->m_saEquipmentCmd.RemoveAt(0);

		switch (eEqCmd)
		{
		case eEqCmdPause:
			//110817 SJ_KJS
			SetOPStatus(CYCLE_STOP);
			m_plnkLCNet->EqProcessStopReport(ePause, 0, m_plnkLCNet->m_strPauseMessage);
			//SetOperatorCall(TRUE, ePause);
//			SetOPStatus(STEP_STOP);
			//_______________________-
			break;

		case eEqCmdResume:
			// 위험하다고 판단되어 막음 - 2007.10.18 한현정선임과 협의됨
			//SetOPMode(AUTORUN_MODE);
			//SetOPStatus(START_RUN);
			break;

		case eEqCmdChgPM:
			m_bPMMode = TRUE;
		    //m_plnkTrsLoadConveyor->SetPanelInStop(TRUE);
//			m_plnkTrsPanelTransferCenter->SetPanelInStop(TRUE);
			WriteMonitoringLog("PM Command Receive");
			Sleep(3000);
			break;

		case eEqCmdChgNormal:
			m_bPMMode = FALSE;
			m_plnkLCNet->EqStateReport(eNormal);
			//m_plnkTrsLoadConveyor->SetPanelInStop(FALSE);
//			m_plnkTrsPanelTransferCenter->SetPanelInStop(FALSE);
			::SendMessage(m_hAutoViewWnd, WM_DISP_EQ_STATE,(WPARAM)(eNormal),NULL);
			WriteMonitoringLog("Normal Command Receive");
			break;

		case eEqCmdTerminalMsg:
			::SendMessage(m_hAutoViewWnd, WM_DISP_TERMINAL_MSG, (WPARAM)(&strEqCmd), NULL);
			break;

		case eEqCmdOperatorCall:
			SetOperatorCall(TRUE, strEqCmd);
			WriteMonitoringLog("OP Call Receive: " + strEqCmd);
			break;

		case eEqCmdLastGlassCancel:
			m_plnkMelsecIF->SetJobOrder_ToLowerEqWord(FALSE);
			for (int i = 0; i < DEF_MAX_PANEL_UNIT; i++)
				m_pGlassData[i]->RstJobOrder();

			WriteMonitoringLog("Last Glass Cancel");
			break;

		default:
			break;
		}
	}

	if (m_plnkLCNet->m_saMultiTerminalCmd.GetSize() != 0)
	{
		CString strMultiTerminalCmd;
		if(m_plnkLCNet->m_saMultiTerminalCmd.GetSize() > 0)
		{
			strMultiTerminalCmd = m_plnkLCNet->m_saMultiTerminalCmd.GetAt(0);
			m_plnkLCNet->m_saMultiTerminalCmd.RemoveAt(0);		
		}
		
		::SendMessage(m_hAutoViewWnd, WM_DISP_TERMINAL_MSG, (WPARAM)(&strMultiTerminalCmd), NULL);
		WriteMonitoringLog(_T("Multi Terminal Receive: ") + strEqCmd);
	}

	// 확인 필요 : 이 부분 정리할 것.
	if (m_bPMMode && m_bEmptyPanel)
	{
		BOOL bIsNoPanelInEquipment = isNoPanelInEquipment();

		if ((bIsNoPanelInEquipment || GetOPMode() == MANUAL_MODE) 
			&& m_plnkLCNet->m_eEqState != ePM)
		// jdy 12pm_e
		{
			m_plnkLCNet->EqStateReport(ePM, strEqCmd);
			::SendMessage(m_hAutoViewWnd, WM_DISP_EQ_STATE, (WPARAM)(ePM), NULL);
			m_bPMMode = FALSE;
			SetOPStatus(STEP_STOP);

			MTickTimer timer;
			timer.StartTimer();
			while (!isAllStepStop())
			{
				if (timer.MoreThan(10))
					break;

				Sleep(100);
			}
			
			WriteMonitoringLog("Convert into PM" + getCurrentEquipState());
		}
	}

	// RequestProcessCmd
	if (m_plnkLCNet->m_iaProcessCmd.GetSize() != 0)
	{
		EProcCmd eProcessCmd = (EProcCmd)m_plnkLCNet->m_iaProcessCmd.GetAt(0);
		CString strProcessCmd = m_plnkLCNet->m_saProcessCmd.GetAt(0);
		m_plnkLCNet->m_iaProcessCmd.RemoveAt(0);
		m_plnkLCNet->m_saProcessCmd.RemoveAt(0);

		switch (eProcessCmd)
		{
		case eProcCmdNothing:
			break;
		case eProcCmdStart:
			break;
		case eProcCmdCancel:
			break;
		case eProcCmdAbort:
			break;
		default:
			break;
		}
	}
	
	// RequestOnlineMode
	if (m_plnkLCNet->m_iaOnlineCmdMode.GetSize() != 0)
	{
		EOnlineMode eOnlineCmdMode = (EOnlineMode)m_plnkLCNet->m_iaOnlineCmdMode.GetAt(0);
		m_plnkLCNet->m_iaOnlineCmdMode.RemoveAt(0);

		switch (eOnlineCmdMode)
		{
		case eOnNothing:
			break;
		case eOffline:
			break;
		case eLocal:
			break;
		case eRemote:
			break;
		default:
			break;
		}
	}

	// RequestMaterialCmd
	if (m_plnkLCNet->m_iaMaterialCmd.GetSize() != 0)
	{
		MCtrlTabFeeder*	plnkCtrlTabFeeder;
		int iSelectedReel;
		BOOL bIsZig = FALSE;
		CString sZigPORTID = "FEEDER1";
		EMaterialStep eMStep = eMatStep_S;

		EMatCmd eMaterialCmd = (EMatCmd)m_plnkLCNet->m_iaMaterialCmd.GetAt(0);
		CString strMaterialCmd = m_plnkLCNet->m_saMaterialCmd.GetAt(0);
		m_plnkLCNet->m_iaMaterialCmd.RemoveAt(0);
		m_plnkLCNet->m_saMaterialCmd.RemoveAt(0);

		switch (eMaterialCmd)
		{
		case eMatCmdNothing:
			break;

		case eMatCmdStart:
			//110808 SJ_KJS
			/*
			if (m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matTabICInfo[DEF_USING_REEL].m_sM_BATCHID == strMaterialCmd)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matTabICInfo[DEF_USING_REEL].m_nM_STATE = eMatStateEnable;
			}
			else if (m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matTabICInfo[DEF_SPARE_REEL].m_sM_BATCHID == strMaterialCmd)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matTabICInfo[DEF_SPARE_REEL].m_nM_STATE = eMatStateEnable;
			}
//KKY.Del #ifdef DEF_GATE_SYSTEM
			else if (m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matTabICInfo[DEF_USING_REEL].m_sM_BATCHID == strMaterialCmd)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matTabICInfo[DEF_USING_REEL].m_nM_STATE = eMatStateEnable;
			}
			else if (m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matTabICInfo[DEF_SPARE_REEL].m_sM_BATCHID == strMaterialCmd)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matTabICInfo[DEF_SPARE_REEL].m_nM_STATE = eMatStateEnable;
			}
//KKY.Del #endif
			if (m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matZigInfo.m_sM_BATCHID == strMaterialCmd)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matZigInfo.m_nM_STATE = eMatStateEnable;
				bIsZig = TRUE;
				sZigPORTID = "FEEDER1";
			}
//KKY.Del #ifdef DEF_GATE_SYSTEM
			else if (m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matZigInfo.m_sM_BATCHID == strMaterialCmd)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matZigInfo.m_nM_STATE = eMatStateEnable;
				bIsZig = TRUE;
				sZigPORTID = "FEEDER2";
			}
//KKY.Del #endif
*/
			break;

		case eMatCmdAbort:
			break;

		case eMatCmdCancel:
			//110808 SJ_KJS
			/*
			if (m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matTabICInfo[DEF_USING_REEL].m_sM_BATCHID == strMaterialCmd)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matTabICInfo[DEF_USING_REEL].m_nM_STATE = eMatStateHold;
			}
			if (m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matTabICInfo[DEF_SPARE_REEL].m_sM_BATCHID == strMaterialCmd)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matTabICInfo[DEF_SPARE_REEL].m_nM_STATE = eMatStateHold;
			}
//KKY.Del #ifdef DEF_GATE_SYSTEM
			else if (m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matTabICInfo[DEF_USING_REEL].m_sM_BATCHID == strMaterialCmd)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matTabICInfo[DEF_USING_REEL].m_nM_STATE = eMatStateHold;
			}
			else if (m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matTabICInfo[DEF_SPARE_REEL].m_sM_BATCHID == strMaterialCmd)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matTabICInfo[DEF_SPARE_REEL].m_nM_STATE = eMatStateHold;
			}
//KKY.Del #endif
			if (m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matZigInfo.m_sM_BATCHID == strMaterialCmd)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matZigInfo.m_nM_STATE = eMatStateHold;
				bIsZig = TRUE;
				sZigPORTID = "FEEDER1";
			}
//KKY.Del #ifdef DEF_GATE_SYSTEM
			else if (m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matZigInfo.m_sM_BATCHID == strMaterialCmd)
			{
				m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matZigInfo.m_nM_STATE = eMatStateHold;
				bIsZig = TRUE;
				sZigPORTID = "FEEDER2";
			}
//KKY.Del #endif
*/
			break;

		case eMatCmdUpdate:
			//110808 SJ_KJS
			if (strPortID1 == m_plnkLCNet->m_MaterialData.m_sPORTID
				|| strPortID3 == m_plnkLCNet->m_MaterialData.m_sPORTID)
			{
				iSelectedReel = DEF_USING_REEL;
				plnkCtrlTabFeeder = m_plnkCtrlTabFeeder[DEF_TABFEEDER1];
			}
			else if (strPortID2 == m_plnkLCNet->m_MaterialData.m_sPORTID
				|| strPortID4 == m_plnkLCNet->m_MaterialData.m_sPORTID)
			{
				iSelectedReel = DEF_USING_REEL;
				plnkCtrlTabFeeder = m_plnkCtrlTabFeeder[DEF_TABFEEDER2];
			}
			//20121105 SJ_HJG
			else if (strPortID5 == m_plnkLCNet->m_MaterialData.m_sPORTID)
			{
				iSelectedReel = DEF_USING_REEL;
				plnkCtrlTabFeeder = m_plnkCtrlTabFeeder[DEF_TABFEEDER1];
			}
			else if (strPortID6 == m_plnkLCNet->m_MaterialData.m_sPORTID)
			{
				iSelectedReel = DEF_USING_REEL;
				plnkCtrlTabFeeder = m_plnkCtrlTabFeeder[DEF_TABFEEDER2];
			}
			//_______________

			else
			{
				//PortID(Feeder)가 불명확합니다.
				MyMessageBox("The PortID of the material information received from the L / C is invalid.\r\nL/C로부터 받은 자재정보의 PortID가 잘못되었습니다.", "Port ID Error!", M_ICONERROR);
				break;
			}
			//iSelectedReel = pTrsFeeder->GetSelectedReel();

			if(m_plnkLCNet->m_MaterialData.m_nM_KIND == 13)  // TAB IC일 경우
			{
//				pTrsFeeder->GetFeederMatInfo()->m_Mat.m_nT_QTY = m_pLCNet->m_MaterialData.m_nT_QTY; // 새로 시작하니까...
				plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_nT_QTY = m_plnkLCNet->m_MaterialData.m_nT_QTY;
//				pTrsFeeder->GetFeederMatInfo()->m_Mat.m_nM_STATE = m_pLCNet->m_MaterialData.m_nM_STATE;
				plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_nU_QTY = m_plnkLCNet->m_MaterialData.m_nU_QTY;
				//plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_nR_QTY = m_plnkLCNet->m_MaterialData.m_nR_QTY;
				plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_nR_QTY = m_plnkLCNet->m_MaterialData.m_nT_QTY;
				plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_nN_QTY = 0;
			
				plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_sC_CODE = m_plnkLCNet->m_MaterialData.m_sC_CODE; //정상적인 동작이라면 ENABLE 상태를 받아야 한다. 
//				pTrsFeeder->GetFeederMatInfo()->m_Mat.m_sM_STEP = m_pLCNet->m_MaterialData.m_sM_STEP; 
				plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_sM_BATCHID = m_plnkLCNet->m_MaterialData.m_sM_BATCHID;
				plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_sM_MAKER = m_plnkLCNet->m_MaterialData.m_sM_MAKER;
				plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_nM_TYPE = m_plnkLCNet->m_MaterialData.m_nM_TYPE;
				plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_nN_QTY = 0; 				
				plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_sM_CODE = m_plnkLCNet->m_MaterialData.m_sM_CODE; 

				if (m_plnkLCNet->m_MaterialData.m_sPORTID == strPortID1)
				{
//					m_plnkTrsTabFeeder->GetFeederMatInfo()->WriteFeederMatInfo();
					//m_plnkProductInfoData->m_matTabICInfo[DEF_TABFEEDER1] = pTrsFeeder->GetFeederMatInfo()->m_Mat;
					m_plnkProductInfoData->WriteMaterialData();
				}
				else if (m_plnkLCNet->m_MaterialData.m_sPORTID == strPortID2)
				{
					//m_plnkTrsTabFeeder->GetFeederMatInfo()->WriteFeederMatInfo();
					//m_plnkProductInfoData->m_matTabICInfo[DEF_TABFEEDER2] = pTrsFeeder->GetFeederMatInfo()->m_Mat;
					m_plnkProductInfoData->WriteMaterialData();
				}
				bCodeOK = FALSE;
#ifdef DEF_SOURCE_SYSTEM
				for(int i=0; i<m_plnkLCNet->m_CurMaterialCodeInfo_S.m_asM_CODE.GetSize(); i++)
				{
					strM_Code = m_plnkLCNet->m_CurMaterialCodeInfo_S.m_asM_CODE.GetAt(i);				
					if(m_plnkLCNet->m_MaterialData.m_sM_CODE == strM_Code)
					{
						bCodeOK = TRUE;
						break;
					}
				}	
#else
				for(int i=0; i<m_plnkLCNet->m_CurMaterialCodeInfo_G.m_asM_CODE.GetSize(); i++)
				{
					strM_Code = m_plnkLCNet->m_CurMaterialCodeInfo_G.m_asM_CODE.GetAt(i);				
					if(m_plnkLCNet->m_MaterialData.m_sM_CODE == strM_Code)
					{
						bCodeOK = TRUE;
						break;
					}
				}
#endif
				//SJ_YYK 현재 받은 자재 Bomb 과 비교..
				if(bCodeOK)
				{
					plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_nM_STATE = eMatStateEnable;
					m_plnkLCNet->MaterialReport(eMatUserCheck, &plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel]);
					m_plnkLCNet->MaterialReport(eMatDockIn, &plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel]);
					m_plnkLCNet->MaterialReport(eMatLocationUpdate, &plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel]);				

				}
				else
				{
					CString strEqCmd;
					plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel].m_nM_STATE = eMatStateHold;
//					m_plnkLCNet->MaterialReport(eMatNG, &plnkCtrlTabFeeder->m_matTabICInfo[iSelectedReel]);
					strEqCmd.Format(_T("Material Code is Not Using. After Initialize, Start."));		
//					::SendMessage(m_hAutoViewWnd, WM_DISP_OPCALL_MSG, (WPARAM)(&strEqCmd), NULL);
					SetOperatorCall(TRUE, strEqCmd);
				}
			}
			else
			{
//				pTrsFeeder->GetZigInfo()->m_Mat.m_nT_QTY = m_pLCNet->m_MaterialData.m_nT_QTY; // 새로 시작하니까...
				plnkCtrlTabFeeder->m_matZigInfo.m_nMAP_STIF = m_plnkLCNet->m_MaterialData.m_nMAP_STIF;
				plnkCtrlTabFeeder->m_matZigInfo.m_nT_QTY = m_plnkLCNet->m_MaterialData.m_nMAP_STIF;
//				pTrsFeeder->GetZigInfo()->m_Mat.m_nM_STATE = m_pLCNet->m_MaterialData.m_nM_STATE;
				plnkCtrlTabFeeder->m_matZigInfo.m_nU_QTY = m_plnkLCNet->m_MaterialData.m_nU_QTY;
				//plnkCtrlTabFeeder->m_matZigInfo.m_nR_QTY = m_plnkLCNet->m_MaterialData.m_nR_QTY;
				plnkCtrlTabFeeder->m_matZigInfo.m_nR_QTY = m_plnkLCNet->m_MaterialData.m_nT_QTY;
				plnkCtrlTabFeeder->m_matZigInfo.m_nN_QTY = 0;
			
				plnkCtrlTabFeeder->m_matZigInfo.m_sC_CODE = m_plnkLCNet->m_MaterialData.m_sC_CODE; //정상적인 동작이라면 ENABLE 상태를 받아야 한다. 
//				pTrsFeeder->GetZigInfo()->m_Mat.m_sM_STEP = m_pLCNet->m_MaterialData.m_sM_STEP; 
				plnkCtrlTabFeeder->m_matZigInfo.m_sM_BATCHID = m_plnkLCNet->m_MaterialData.m_sM_BATCHID;
				plnkCtrlTabFeeder->m_matZigInfo.m_sM_MAKER = m_plnkLCNet->m_MaterialData.m_sM_MAKER;
				plnkCtrlTabFeeder->m_matZigInfo.m_nM_TYPE = m_plnkLCNet->m_MaterialData.m_nM_TYPE;
				plnkCtrlTabFeeder->m_matZigInfo.m_nN_QTY = 0; 
				plnkCtrlTabFeeder->m_matZigInfo.m_sM_CODE = m_plnkLCNet->m_MaterialData.m_sM_CODE; 

				//20121105 SJ_HJG
				//if (m_plnkLCNet->m_MaterialData.m_sPORTID == strPortID3)
				if (m_plnkLCNet->m_MaterialData.m_sPORTID == strPortID5)
				{
					//m_plnkTrsTabFeeder->GetZigInfo()->WriteZigMatInfo();
					//m_plnkProductInfoData->m_matTabICInfo[DEF_TABFEEDER1] = pTrsFeeder->GetFeederMatInfo()->m_Mat;
					m_plnkProductInfoData->WriteMaterialData();
				}
				//else if (m_plnkLCNet->m_MaterialData.m_sPORTID == strPortID4)
				else if (m_plnkLCNet->m_MaterialData.m_sPORTID == strPortID6)
				{
					//m_plnkTrsTabFeeder->GetZigInfo()->WriteZigMatInfo();
					//m_plnkProductInfoData->m_matTabICInfo[DEF_TABFEEDER2] = pTrsFeeder->GetFeederMatInfo()->m_Mat;
					m_plnkProductInfoData->WriteMaterialData();
				}
				bCodeOK = FALSE;
#ifdef DEF_SOURCE_SYSTEM
				//20121105 SJ_HJG
				//for(int i=0; i<m_plnkLCNet->m_CurMaterialCodeInfo_S.m_asM_CODE.GetSize(); i++)
				for(int i=0; i<m_plnkLCNet->m_CurMaterialCodeInfo_ZS.m_asM_CODE.GetSize(); i++)
				{
					//20121105 SJ_HJG
					//strM_Code = m_plnkLCNet->m_CurMaterialCodeInfo_S.m_asM_CODE.GetAt(i);				
					strM_Code = m_plnkLCNet->m_CurMaterialCodeInfo_ZS.m_asM_CODE.GetAt(i);				
					if(m_plnkLCNet->m_MaterialData.m_sM_CODE == strM_Code)
					{
						bCodeOK = TRUE;
						break;
					}
	
				}
#else
				//20121105 SJ_HJG
				//for(int i=0; i<m_plnkLCNet->m_CurMaterialCodeInfo_G.m_asM_CODE.GetSize(); i++)
				for(int i=0; i<m_plnkLCNet->m_CurMaterialCodeInfo_ZG.m_asM_CODE.GetSize(); i++)
				{
					//strM_Code = m_plnkLCNet->m_CurMaterialCodeInfo_G.m_asM_CODE.GetAt(i);				
					strM_Code = m_plnkLCNet->m_CurMaterialCodeInfo_ZG.m_asM_CODE.GetAt(i);				
					if(m_plnkLCNet->m_MaterialData.m_sM_CODE == strM_Code)
					{
						bCodeOK = TRUE;
						break;
					}
	
				}
#endif
				//SJ_YYK 현제 받은 자재 Bomb 과 비교..
				if(bCodeOK)
				{
					plnkCtrlTabFeeder->m_matZigInfo.m_nM_STATE = eMatStateEnable;
					m_plnkLCNet->MaterialReport(eMatUserCheck, &plnkCtrlTabFeeder->m_matZigInfo);
					m_plnkLCNet->MaterialReport(eMatDockIn, &plnkCtrlTabFeeder->m_matZigInfo);
					m_plnkLCNet->MaterialReport(eMatLocationUpdate, &plnkCtrlTabFeeder->m_matZigInfo);
				}
				else
				{
					CString strEqCmd;
					plnkCtrlTabFeeder->m_matZigInfo.m_nM_STATE = eMatStateHold;
//					m_plnkLCNet->MaterialReport(eMatNG, &plnkCtrlTabFeeder->m_matZigInfo);					strEqCmd.Format(_T("Material Code is Not Using. After Initialize, Start."));		
					SetOperatorCall(TRUE, strEqCmd);
				}
			}
			//else
			//{
				//Tab IC Reel 정보를 저장하려는데 PortID(Feeder)가 불명확합니다.
			//	MyMessageBox(MY_MESSAGE_BOX,62001, _T("Reel PORTID Error!"), M_ICONERROR);
			//	break;
			//}
			//m_plnkProductInfoData->WriteMaterialData();
			break;


		case eMatCmdQty:
			m_plnkProductInfoData->m_iPreHandQty = m_plnkLCNet->GetPreHandLimitQty_TABIC();
			m_plnkProductInfoData->m_iWarningQty = m_plnkLCNet->GetWarningLimitQty_TABIC();
			m_plnkProductInfoData->WriteMaterialData();
			break;

		default:
			break;
		}

		// Park, YK - Zig 정보 저장
		if (TRUE == bIsZig)
		{
//KKY.Del #ifdef DEF_SOURCE_SYSTEM
//KKY.Del 			plnkCtrlTabFeeder = m_plnkCtrlTabFeeder[DEF_TABFEEDER1];
//KKY.Del 			m_plnkProductInfoData->m_matZigInfo[DEF_TABFEEDER1] = plnkCtrlTabFeeder->m_matZigInfo;
//KKY.Del 			m_plnkProductInfoData->WriteMaterialData();
//KKY.Del #else // DEF_GATE_SYSTEM
			if ("FEEDER1" == sZigPORTID)
			{
				plnkCtrlTabFeeder = m_plnkCtrlTabFeeder[DEF_TABFEEDER1];
				m_plnkProductInfoData->m_matZigInfo[DEF_TABFEEDER1] = plnkCtrlTabFeeder->m_matZigInfo;
				m_plnkProductInfoData->WriteMaterialData();
			}
			else if ("FEEDER2" == sZigPORTID)
			{
				plnkCtrlTabFeeder = m_plnkCtrlTabFeeder[DEF_TABFEEDER2];
				m_plnkProductInfoData->m_matZigInfo[DEF_TABFEEDER2] = plnkCtrlTabFeeder->m_matZigInfo;
				m_plnkProductInfoData->WriteMaterialData();
			}
			else
			{
				//Tab IC Zig 정보를 저장하려는데 PortID(Feeder)가 불명확합니다.
				MyMessageBox(MY_MESSAGE_BOX,62003, _T("Zig PORTID Error!"), M_ICONERROR);
			}
//KKY.Del #endif
		}
	}

	//110621.KKY.Add_____
	if (m_plnkLCNet->m_caMaterialCodeInfo.GetSize() != 0)
	{
		MMaterialCodeInfo* pMaterialCodeInfo
			= (MMaterialCodeInfo*)m_plnkLCNet->m_caMaterialCodeInfo.GetAt(0);
		m_plnkLCNet->m_caMaterialCodeInfo.RemoveAt(0);

		CreateMCodeInfo(pMaterialCodeInfo);

		if (pMaterialCodeInfo != NULL)
			delete pMaterialCodeInfo;
	}
	//___________________

	//_____________________________________________
	// 100807 SJ_Chi, EC Data Report
	// RequestEquipmentConstant
	EEqConstCmd     eEqConstCmd;
	MEqConstant*    cEqConstData = NULL;

	if (m_plnkLCNet->m_iaEqConstCmd.GetSize() != 0)
	{
		eEqConstCmd = (EEqConstCmd)m_plnkLCNet->m_iaEqConstCmd.GetAt(0);
		m_plnkLCNet->m_iaEqConstCmd.RemoveAt(0);

		if (m_plnkLCNet->m_caEqConstData.GetSize() != 0) {
			cEqConstData = (MEqConstant*)m_plnkLCNet->m_caEqConstData.GetAt(0);
			m_plnkLCNet->m_caEqConstData.RemoveAt(0);
		}

		switch (eEqConstCmd)
		{
		case eInitRequest:
			ReplyEqConstList(); // 전체 EC Data List 전송
			break;
		case eChangeRequest:
			if (cEqConstData != NULL)
				UpdateEqConstData(cEqConstData);
			else
				UpdateEqConstDataList();
			break;
		default:
			break;
		}

		if (cEqConstData != NULL)
			delete cEqConstData;
	}
	//_____________________________________________

	// RequestParamChange
	EParamType eChangeParamType;
	if (m_plnkLCNet->m_iaChangeParamType.GetSize() != 0)
	{
		eChangeParamType = (EParamType)m_plnkLCNet->m_iaChangeParamType.GetAt(0);
		MStateVariable*	cChangeParamStateVariable
			= (MStateVariable*)m_plnkLCNet->m_caChangeParamStateVariable.GetAt(0);
		m_plnkLCNet->m_iaChangeParamType.RemoveAt(0);
		m_plnkLCNet->m_caChangeParamStateVariable.RemoveAt(0);

		switch (eChangeParamType)
		{
		case eParamNothing:
			break;
		case eEqStatus:
			break;
		case eEqConstant:
			break;
		case eEqOnline:
			break;
		default:
			break;
		}

		if (cChangeParamStateVariable != NULL)
			delete cChangeParamStateVariable;
	}

	// RequestProcessProgram
	if (m_plnkLCNet->m_iaProcessProgramMode.GetSize() != 0)
	{
		EPPIDModeType eProcessProgramMode = (EPPIDModeType)m_plnkLCNet->m_iaProcessProgramMode.GetAt(0);
		MProcessProgram* cProcessProgram = (MProcessProgram*)m_plnkLCNet->m_caProcessProgram.GetAt(0);
		m_plnkLCNet->m_iaProcessProgramMode.RemoveAt(0);
		m_plnkLCNet->m_caProcessProgram.RemoveAt(0);

		CString strMsg;
		CString strModelName;
		CString szTextTemp;

		if (GetOPMode() == MANUAL_MODE)
		{
			switch (eProcessProgramMode)
			{
			case ePPIDNothing:
				break;
			case ePPIDCreate:
				break;
			case ePPIDModify:
				break;
			case ePPIDDelete:
				break;
			case ePPIDChange:
				strModelName.Format(_T("%s"), cProcessProgram->m_strPPID);
				ReadDisplayMessage(MY_MESSAGE_BOX, _T("Message_61502"), &szTextTemp);				

				// 로 모델을 변경합니다. 계속 진행하시겠습니까?
				strMsg = strModelName + szTextTemp;
				if (MyMessageBox(strMsg, _T("Question"), M_ICONQUESTION|M_YESNO) == IDNO)
					break;
				
				if (MOlbSystemPre.ChangeModel(cProcessProgram->m_strPPID) != SUCCESS)
				{
					//모델 교체 실패
					ReadDisplayMessage(MY_MESSAGE_BOX, _T("Message_62004"), &strMsg);
				}
				break;
			default:
				break;
			}
		}

		if (cProcessProgram != NULL)
			delete cProcessProgram;
	}

	//RequestProductPlan
	if (m_plnkLCNet->m_iaProductPlanCode.GetSize() != 0)
	{
		UINT iProductPlanCode = m_plnkLCNet->m_iaProductPlanCode.GetAt(0);

		switch (iProductPlanCode)
		{
		case 1:		// Create Product Plan
			CreateProductPlan();//110620.KKY.Add
			break;
		case 2:		// Delete Product Plan
			break;
		case 3:		// Modify Product Plan(Detail Item Modify)
			UpdateProductPlan();//110620.KKY.Add
			m_plnkLCNet->m_iaProductPlanCode.RemoveAt(0);
			m_plnkLCNet->m_caProductPlanBatchData.RemoveAt(0);
			break;
		case 4:		// Change Product Plan(Changed the current product plan)
			break;
		default:
			break;
		}
	}

	// RequestBarCodeParsingInfo
	if (m_plnkLCNet->m_caBarCodeParsingInfo.GetSize() != 0)
	{
		MBarCodeParsingInfo* cBarCodeParsingInfo
			= (MBarCodeParsingInfo*)m_plnkLCNet->m_caBarCodeParsingInfo.GetAt(0);
		m_plnkLCNet->m_caBarCodeParsingInfo.RemoveAt(0);

		if (cBarCodeParsingInfo != NULL)
			delete cBarCodeParsingInfo;
	}

	 // LC <==> 설비 간 시간 동기화
    if (GetOPMode() == MANUAL_MODE)
    {
        if (m_plnkLCNet->m_saLCDateTime.GetSize() != 0)
            m_plnkLCNet->UpdateLCDateTime();
    }

	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

/**
 * AutoManager가 OP State를 변경 하기 위해 
 * Process Layer가 모두 Auto Run 여부를 확인 하는 함수	
 */
BOOL MTrsAutoManager::isAllAutoRun()
{
	BOOL bRet[DEF_MAX_PROCESS_INSTANCE];

	memset(bRet, TRUE, sizeof(bRet));

	GetThreadAutoRunStatus(bRet);
	/*
	if (bRet[0] && bRet[1] && bRet[2] && bRet[3] && bRet[4] && bRet[5]
		&& bRet[6] && bRet[7] && bRet[8] && bRet[9] && bRet[10] && bRet[11]
		&& bRet[12] && bRet[13] && bRet[14] && bRet[15]
#ifdef DEF_GATE_SYSTEM
		&& bRet[16] && bRet[17] && bRet[18] && bRet[19] && bRet[20]
		&& bRet[21] && bRet[22]&& bRet[23] && bRet[24] && bRet[25]
#endif
		)
		return TRUE;
	return FALSE;
	*/
	BOOL isAllRun = TRUE;
	for (int i = 0; i < DEF_MAX_PROCESS_INSTANCE; i++)
		isAllRun &= bRet[i];
	return isAllRun;
}

void MTrsAutoManager::GetThreadAutoRunStatus(BOOL* prgStatus)
{
	// 확인 필요: prgStatus 인자 개수 유효성 확인 작업 필요, 포인터 유효성
	int iCnt = 0;
	prgStatus[iCnt++] = m_plnkTrsPanelAligner->IsAutoRun();
#ifdef DEF_SOURCE_SYSTEM
#	ifdef DEF_USE_TRANSFER_CENTER
	prgStatus[iCnt++] = m_plnkTrsPanelTransferCenter->IsAutoRun();
#	endif
	prgStatus[iCnt++] = m_plnkTrsPanelTransfer->IsAutoRun();
#endif
	prgStatus[iCnt++] = m_plnkTrsPanelTransferOut->IsAutoRun();

	prgStatus[iCnt++] = m_plnkTrsTabMounter[DEF_TABMOUNTER1]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsTabMounter[DEF_TABMOUNTER2]->IsAutoRun();
#ifdef DEF_SOURCE_SYSTEM
	prgStatus[iCnt++] = m_plnkTrsTabMounter[DEF_TABMOUNTER3]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsTabMounter[DEF_TABMOUNTER4]->IsAutoRun();
#endif
	prgStatus[iCnt++] = m_plnkTrsRTabMounter[DEF_TABMOUNTER1]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsRTabMounter[DEF_TABMOUNTER2]->IsAutoRun();
#ifdef DEF_SOURCE_SYSTEM
	prgStatus[iCnt++] = m_plnkTrsRTabMounter[DEF_TABMOUNTER3]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsRTabMounter[DEF_TABMOUNTER4]->IsAutoRun();
#endif
	prgStatus[iCnt++] = m_plnkTrsTabCarrier[DEF_TABCARRIER1]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsTabCarrier[DEF_TABCARRIER2]->IsAutoRun();
#ifdef DEF_SOURCE_SYSTEM
	prgStatus[iCnt++] = m_plnkTrsTabCarrier[DEF_TABCARRIER3]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsTabCarrier[DEF_TABCARRIER4]->IsAutoRun();
#endif
	prgStatus[iCnt++] = m_plnkTrsRTabCarrier[DEF_TABCARRIER1]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsRTabCarrier[DEF_TABCARRIER2]->IsAutoRun();
#ifdef DEF_SOURCE_SYSTEM
	prgStatus[iCnt++] = m_plnkTrsRTabCarrier[DEF_TABCARRIER3]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsRTabCarrier[DEF_TABCARRIER4]->IsAutoRun();	
#endif
	prgStatus[iCnt++] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_1]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_2]->IsAutoRun();
#ifdef DEF_SOURCE_SYSTEM
	prgStatus[iCnt++] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_3]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_4]->IsAutoRun();
#endif
	prgStatus[iCnt++] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_1]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_2]->IsAutoRun();
#ifdef DEF_SOURCE_SYSTEM
	prgStatus[iCnt++] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_3]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_4]->IsAutoRun();
#endif
	prgStatus[iCnt++] = m_plnkTrsTabFeeder[DEF_TABFEEDER1]->IsAutoRun();
	prgStatus[iCnt++] = m_plnkTrsTabFeeder[DEF_TABFEEDER2]->IsAutoRun();

#ifdef DEF_USE_TURN_HANDLER
	prgStatus[iCnt++] = m_plnkTrsTHandler->IsAutoRun();
#endif
}

BOOL MTrsAutoManager::isAllModelChangeReady()
{
	// 모든 Thread Model Change 완료 확인.
	BOOL bModelChangeState[DEF_MAX_PROCESS_INSTANCE];
	memset(bModelChangeState, TRUE, sizeof(bModelChangeState));

	int iCnt = 0;

	bModelChangeState[iCnt++] = m_plnkTrsPanelAligner->IsModelChangeReady();
#ifdef DEF_SOURCE_SYSTEM	
#	ifdef DEF_USE_TRANSFER_CENTER
	bModelChangeState[iCnt++] = m_plnkTrsPanelTransferCenter->IsModelChangeReady();
#	endif
	bModelChangeState[iCnt++] = m_plnkTrsPanelTransfer->IsModelChangeReady();
#endif
	bModelChangeState[iCnt++] = m_plnkTrsPanelTransferOut->IsModelChangeReady();

	bModelChangeState[iCnt++] = m_plnkTrsTabMounter[DEF_TABMOUNTER1]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsTabMounter[DEF_TABMOUNTER2]->IsModelChangeReady();
#ifdef DEF_SOURCE_SYSTEM
	bModelChangeState[iCnt++] = m_plnkTrsTabMounter[DEF_TABMOUNTER3]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsTabMounter[DEF_TABMOUNTER4]->IsModelChangeReady();
#endif

	bModelChangeState[iCnt++] = m_plnkTrsRTabMounter[DEF_TABMOUNTER1]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsRTabMounter[DEF_TABMOUNTER2]->IsModelChangeReady();
#ifdef DEF_SOURCE_SYSTEM
	bModelChangeState[iCnt++] = m_plnkTrsRTabMounter[DEF_TABMOUNTER3]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsRTabMounter[DEF_TABMOUNTER4]->IsModelChangeReady();
#endif

	bModelChangeState[iCnt++] = m_plnkTrsTabCarrier[DEF_TABCARRIER1]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsTabCarrier[DEF_TABCARRIER2]->IsModelChangeReady();
#ifdef DEF_SOURCE_SYSTEM
	bModelChangeState[iCnt++] = m_plnkTrsTabCarrier[DEF_TABCARRIER3]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsTabCarrier[DEF_TABCARRIER4]->IsModelChangeReady();
#endif

	bModelChangeState[iCnt++] = m_plnkTrsRTabCarrier[DEF_TABCARRIER1]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsRTabCarrier[DEF_TABCARRIER2]->IsModelChangeReady();
#ifdef DEF_SOURCE_SYSTEM
	bModelChangeState[iCnt++] = m_plnkTrsRTabCarrier[DEF_TABCARRIER3]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsRTabCarrier[DEF_TABCARRIER4]->IsModelChangeReady();
#endif

	bModelChangeState[iCnt++] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_1]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_2]->IsModelChangeReady();
#ifdef DEF_SOURCE_SYSTEM
	bModelChangeState[iCnt++] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_3]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_4]->IsModelChangeReady();
#endif

	bModelChangeState[iCnt++] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_1]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_2]->IsModelChangeReady();
#ifdef DEF_SOURCE_SYSTEM
	bModelChangeState[iCnt++] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_3]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_4]->IsModelChangeReady();
#endif

	bModelChangeState[iCnt++] = m_plnkTrsTabFeeder[DEF_TABFEEDER1]->IsModelChangeReady();
	bModelChangeState[iCnt++] = m_plnkTrsTabFeeder[DEF_TABFEEDER2]->IsModelChangeReady();

#ifdef DEF_USE_TURN_HANDLER
	bModelChangeState[iCnt++] = m_plnkTrsTHandler->IsModelChangeReady();
#endif
	BOOL bResult = TRUE;
	for (int i=0; i<DEF_MAX_PROCESS_INSTANCE; i++)
	{
		bResult &= bModelChangeState[i];
	}
	if(bResult == TRUE)
		TRACE(_T("Auto Change Ready 완러"));
	return bResult;

}

//110324_____
BOOL MTrsAutoManager::isAll1FeederAllMountInitReady()
{
	/*/
	// 모든 Thread Model Change 완료 확인.
	BOOL bInitReadyState[DEF_MAX_PROCESS_INSTANCE];
	memset(bInitReadyState, TRUE, sizeof(bInitReadyState));
#ifdef DEF_SOURCE_SYSTEM
	bInitReadyState[0] = TRUE;//m_plnkTrsPanelTransferCenter->Is1FeederAllMountInitReady();
	bInitReadyState[1] = TRUE;//m_plnkTrsPanelTransfer->Is1FeederAllMountInitReady();
	bInitReadyState[2] = m_plnkTrsPanelAligner->Is1FeederAllMountInitReady();
	bInitReadyState[3] = TRUE;//m_plnkTrsPanelTransferOut->Is1FeederAllMountInitReady();

	bInitReadyState[4] = m_plnkTrsTabMounter[DEF_TABMOUNTER1]->Is1FeederAllMountInitReady();
	bInitReadyState[5] = m_plnkTrsTabMounter[DEF_TABMOUNTER2]->Is1FeederAllMountInitReady();
	bInitReadyState[6] = m_plnkTrsTabMounter[DEF_TABMOUNTER3]->Is1FeederAllMountInitReady();
	bInitReadyState[7] = m_plnkTrsTabMounter[DEF_TABMOUNTER4]->Is1FeederAllMountInitReady();
	bInitReadyState[8] = m_plnkTrsTabMounter[DEF_TABMOUNTER5]->Is1FeederAllMountInitReady();
	bInitReadyState[9] = m_plnkTrsTabMounter[DEF_TABMOUNTER6]->Is1FeederAllMountInitReady();
	bInitReadyState[10] = m_plnkTrsTabMounter[DEF_TABMOUNTER7]->Is1FeederAllMountInitReady();
	bInitReadyState[11] = m_plnkTrsTabMounter[DEF_TABMOUNTER8]->Is1FeederAllMountInitReady();

	bInitReadyState[12] = m_plnkTrsTabCarrier[DEF_TABCARRIER1]->Is1FeederAllMountInitReady();
	bInitReadyState[13] = m_plnkTrsTabCarrier[DEF_TABCARRIER2]->Is1FeederAllMountInitReady();
	bInitReadyState[14] = m_plnkTrsTabCarrier[DEF_TABCARRIER3]->Is1FeederAllMountInitReady();
	bInitReadyState[15] = m_plnkTrsTabCarrier[DEF_TABCARRIER4]->Is1FeederAllMountInitReady();

	bInitReadyState[16] = m_plnkTrsRTabCarrier[DEF_TABCARRIER1]->Is1FeederAllMountInitReady();
	bInitReadyState[17] = m_plnkTrsRTabCarrier[DEF_TABCARRIER2]->Is1FeederAllMountInitReady();
	bInitReadyState[18] = m_plnkTrsRTabCarrier[DEF_TABCARRIER3]->Is1FeederAllMountInitReady();
	bInitReadyState[19] = m_plnkTrsRTabCarrier[DEF_TABCARRIER4]->Is1FeederAllMountInitReady();

	bInitReadyState[20] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_1]->Is1FeederAllMountInitReady();
	bInitReadyState[21] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_2]->Is1FeederAllMountInitReady();
	bInitReadyState[22] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_3]->Is1FeederAllMountInitReady();
	bInitReadyState[23] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_4]->Is1FeederAllMountInitReady();

	bInitReadyState[24] = m_plnkTrsTabFeeder[DEF_TABFEEDER1]->Is1FeederAllMountInitReady();
	bInitReadyState[25] = m_plnkTrsTabFeeder[DEF_TABFEEDER2]->Is1FeederAllMountInitReady();
#else
	bInitReadyState[0] = m_plnkTrsPanelAligner->Is1FeederAllMountInitReady();
	bInitReadyState[1] = m_plnkTrsPanelTransferOut->Is1FeederAllMountInitReady();

	bInitReadyState[2] = m_plnkTrsTabMounter[DEF_TABMOUNTER1]->Is1FeederAllMountInitReady();
	bInitReadyState[3] = m_plnkTrsTabMounter[DEF_TABMOUNTER2]->Is1FeederAllMountInitReady();
	bInitReadyState[4] = m_plnkTrsTabMounter[DEF_TABMOUNTER3]->Is1FeederAllMountInitReady();
	bInitReadyState[5] = m_plnkTrsTabMounter[DEF_TABMOUNTER4]->Is1FeederAllMountInitReady();

	bInitReadyState[6] = m_plnkTrsRTabMounter[DEF_TABMOUNTER1]->Is1FeederAllMountInitReady();
	bInitReadyState[7] = m_plnkTrsRTabMounter[DEF_TABMOUNTER2]->Is1FeederAllMountInitReady();
	bInitReadyState[8] = m_plnkTrsRTabMounter[DEF_TABMOUNTER3]->Is1FeederAllMountInitReady();
	bInitReadyState[9] = m_plnkTrsRTabMounter[DEF_TABMOUNTER4]->Is1FeederAllMountInitReady();

	bInitReadyState[10] = m_plnkTrsTabCarrier[DEF_TABCARRIER1]->Is1FeederAllMountInitReady();
	bInitReadyState[11] = m_plnkTrsTabCarrier[DEF_TABCARRIER2]->Is1FeederAllMountInitReady();
	bInitReadyState[12] = m_plnkTrsTabCarrier[DEF_TABCARRIER3]->Is1FeederAllMountInitReady();
	bInitReadyState[13] = m_plnkTrsTabCarrier[DEF_TABCARRIER4]->Is1FeederAllMountInitReady();

	bInitReadyState[14] = m_plnkTrsRTabCarrier[DEF_TABCARRIER1]->Is1FeederAllMountInitReady();
	bInitReadyState[15] = m_plnkTrsRTabCarrier[DEF_TABCARRIER2]->Is1FeederAllMountInitReady();
	bInitReadyState[16] = m_plnkTrsRTabCarrier[DEF_TABCARRIER3]->Is1FeederAllMountInitReady();
	bInitReadyState[17] = m_plnkTrsRTabCarrier[DEF_TABCARRIER4]->Is1FeederAllMountInitReady();

	bInitReadyState[18] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_1]->Is1FeederAllMountInitReady();
	bInitReadyState[19] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_2]->Is1FeederAllMountInitReady();
	bInitReadyState[20] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_3]->Is1FeederAllMountInitReady();
	bInitReadyState[21] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_4]->Is1FeederAllMountInitReady();

	bInitReadyState[22] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_1]->Is1FeederAllMountInitReady();
	bInitReadyState[23] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_2]->Is1FeederAllMountInitReady();
	bInitReadyState[24] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_3]->Is1FeederAllMountInitReady();
	bInitReadyState[25] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_4]->Is1FeederAllMountInitReady();

	bInitReadyState[26] = m_plnkTrsTabFeeder[DEF_TABFEEDER1]->Is1FeederAllMountInitReady();
	bInitReadyState[27] = m_plnkTrsTabFeeder[DEF_TABFEEDER2]->Is1FeederAllMountInitReady();
#endif

	BOOL bResult = TRUE;
	for (int i=0; i<DEF_MAX_PROCESS_INSTANCE; i++)
	{
		bResult &= bInitReadyState[i];
	}

	return bResult;
	/*/

	return FALSE;
}
//___________

//120116.kms_______
BOOL MTrsAutoManager::isMountAutoChangeReady()
{
	/*/
	BOOL bInitReadyState[DEF_MAX_PROCESS_INSTANCE];
	memset(bInitReadyState, TRUE, sizeof(bInitReadyState));

#ifdef DEF_SOURCE_SYSTEM
	bInitReadyState[0] = TRUE;//m_plnkTrsPanelTransferCenter->IsMountAutoChangeReady();
	bInitReadyState[1] = TRUE;//m_plnkTrsPanelTransfer->IsMountAutoChangeReady();
	bInitReadyState[2] = m_plnkTrsPanelAligner->IsMountAutoChangeReady();
	bInitReadyState[3] = TRUE;//m_plnkTrsPanelTransferOut->Is1FeederAllMountInitReady();

	bInitReadyState[4] = m_plnkTrsTabMounter[DEF_TABMOUNTER1]->IsMountAutoChangeReady1();
	bInitReadyState[5] = m_plnkTrsTabMounter[DEF_TABMOUNTER2]->IsMountAutoChangeReady1();
	bInitReadyState[6] = m_plnkTrsTabMounter[DEF_TABMOUNTER3]->IsMountAutoChangeReady1();
	bInitReadyState[7] = m_plnkTrsTabMounter[DEF_TABMOUNTER4]->IsMountAutoChangeReady1();
	bInitReadyState[8] = m_plnkTrsTabMounter[DEF_TABMOUNTER5]->IsMountAutoChangeReady2();
	bInitReadyState[9] = m_plnkTrsTabMounter[DEF_TABMOUNTER6]->IsMountAutoChangeReady2();
	bInitReadyState[10] = m_plnkTrsTabMounter[DEF_TABMOUNTER7]->IsMountAutoChangeReady2();
	bInitReadyState[11] = m_plnkTrsTabMounter[DEF_TABMOUNTER8]->IsMountAutoChangeReady2();

	bInitReadyState[12] = m_plnkTrsTabCarrier[DEF_TABCARRIER1]->IsMountAutoChangeReady1();
	bInitReadyState[13] = m_plnkTrsTabCarrier[DEF_TABCARRIER2]->IsMountAutoChangeReady1();
	bInitReadyState[14] = m_plnkTrsTabCarrier[DEF_TABCARRIER3]->IsMountAutoChangeReady1();
	bInitReadyState[15] = m_plnkTrsTabCarrier[DEF_TABCARRIER4]->IsMountAutoChangeReady1();

	bInitReadyState[16] = m_plnkTrsRTabCarrier[DEF_TABCARRIER1]->IsMountAutoChangeReady2();
	bInitReadyState[17] = m_plnkTrsRTabCarrier[DEF_TABCARRIER2]->IsMountAutoChangeReady2();
	bInitReadyState[18] = m_plnkTrsRTabCarrier[DEF_TABCARRIER3]->IsMountAutoChangeReady2();
	bInitReadyState[19] = m_plnkTrsRTabCarrier[DEF_TABCARRIER4]->IsMountAutoChangeReady2();

	bInitReadyState[20] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_1]->IsMountAutoChangeReady();
	bInitReadyState[21] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_2]->IsMountAutoChangeReady();
	bInitReadyState[22] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_3]->IsMountAutoChangeReady();
	bInitReadyState[23] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_4]->IsMountAutoChangeReady();

	bInitReadyState[24] = m_plnkTrsTabFeeder[DEF_TABFEEDER1]->IsMountAutoChangeReady1();
	bInitReadyState[25] = m_plnkTrsTabFeeder[DEF_TABFEEDER2]->IsMountAutoChangeReady2();
#endif

	BOOL bResult = TRUE;
	for (int i=0; i<DEF_MAX_PROCESS_INSTANCE; i++)
	{
		bResult &= bInitReadyState[i];
	}

	return bResult;
	/*/

	return FALSE;
}
//_________________

/**
 * AutoManager가 OP State를 변경 하기 위해 
 * Process Layer가 모두 Step Stop 여부를 확인 하는 함수	
 */
BOOL MTrsAutoManager::isAllStepStop()
{
	BOOL bRet[DEF_MAX_PROCESS_INSTANCE];

	memset(bRet, FALSE, sizeof(bRet));

	GetThreadAutoRunStatus(bRet);
	BOOL isAllRun = FALSE;
	for (int i = 0; i < DEF_MAX_PROCESS_INSTANCE; i++)
		isAllRun |= bRet[i];
	return !isAllRun;
}

/** 
 * 모든 축에 Origin Flag를 Reset 한다.
 */
int MTrsAutoManager::ResetOriginAllAxis()
{
	for (int i = 0; i < DEF_AXIS_MAX_AXIS; i++)
	{
		if (TRUE == MOlbSystemPre.IsSkipAxis(i))
			continue;

		m_plnkMotion[i]->ResetOrigin();
	}
	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

/** 
 * 모든 Process Layer에 초기화 완료 Flag를 Reset 한다.
 */
void MTrsAutoManager::ResetUnitInitialFlag()
{
	resetAllInitialized();
}

/**
 * AutoManager가 OP State를 Start Run 전 상태를 점검 한다.
 * @return int : 0 = Success, 그외 Error Code
 */
int MTrsAutoManager::checkStartRunCondition()
{
//090701 shim 임시로
//090911 탕정2호기 이정용 수정 : 작업 편의
#ifndef DEF_SETUP
//	if (TRUE == m_plnkSystemData->m_bSafetySensor && TRUE == m_plnkOpPanel->GetSafeDoorStatus())
	if( TRUE == IsDoorOpen())
	{
		// 400002 = Door Open 이 감지되어 자동운전을 시작할 수 없습니다.
		return generateErrorCode(400002);
	}
#endif
	int iResult = ERR_TRS_AUTO_MANAGER_SUCCESS;

	if (TRUE == m_plnkSystemData->m_bSafetySensor)
	{
		//if (TRUE == m_plnkOpPanel->GetSafeDoorStatus())
		if(TRUE == IsDoorOpen())
			// 400002 = Door Open 이 감지되어 자동운전을 시작할 수 없습니다.
			return generateErrorCode(400002);
#ifndef DEF_SETUP
		// 20080718
		if (TRUE == m_plnkIO->IsOff(m_rgusUpperIN[eEmergency]))
			// 400020 = 이전 설비 안전 플러그 확인해 주세요.
			return generateErrorCode(400020);

		if (TRUE == m_plnkIO->IsOff(m_rgusLowerIN[eEmergency]))
			// 400021 = 다음 설비 안전 플러그 확인해 주세요.
			return generateErrorCode(400021);
#endif
	}

	if (TRUE == m_plnkOpPanel->GetEStopButtonStatus())
		// 400001 = 비상정지 스위치가 눌러져 있어 자동운전을 시작할 수 없습니다.
		return generateErrorCode(400001);

	if (!m_plnkTrsPanelAligner->IsInitialized())
		// 400010 = Panel Aligner가 자동운전 초기화 되어 있지 않아 자동운전을 시작할 수 없습니다.
		return generateErrorCode(400010);

#ifdef DEF_SOURCE_SYSTEM
#	ifdef DEF_USE_TRANSFER_CENTER
	if (!m_plnkTrsPanelTransferCenter->IsInitialized())
		// 400022 = Panel Transfer 가 자동운전 초기화 되어 있지 않아 자동운전을 시작할 수 없습니다.
		return generateErrorCode(400022);
#	endif
	
	if (!m_plnkTrsPanelTransfer->IsInitialized())
		// 400022 = Panel Transfer 가 자동운전 초기화 되어 있지 않아 자동운전을 시작할 수 없습니다.
		return generateErrorCode(400022);
#endif

	if (!m_plnkTrsPanelTransferOut->IsInitialized())
		// 400022 = Panel Transfer 가 자동운전 초기화 되어 있지 않아 자동운전을 시작할 수 없습니다.
		return generateErrorCode(400022);
#ifdef DEF_USE_TURN_HANDLER
	if (!m_plnkTrsTHandler->IsInitialized())
		// 400027 = Turn Handler 가 자동운전 초기화 되어 있지 않아 자동운전을 시작할 수 없습니다.
		return generateErrorCode(400027);
#endif

	for (int i = 0; i < DEF_MAX_TABMOUNTER; i++)
	{
		if (!m_plnkTrsTabMounter[i]->IsInitialized())
			// 400019 = Mounter가 자동운전 초기화 되어 있지 않아 자동운전을 시작할 수 없습니다.
			return generateErrorCode(400019);
	}

	for (int i = 0; i < DEF_MAX_TABFEEDER; i++)
	{
		if (!m_plnkTrsTabFeeder[i]->IsInitialized())
			// 400012 = Feeder가 자동운전 초기화 되어 있지 않아 자동운전을 시작할 수 없습니다.
			return generateErrorCode(400012);
	}

	for (int i = 0; i < DEF_MAX_TABCARRIER; i++)
	{
		if (!m_plnkTrsTabCarrier[i]->IsInitialized())
			// 400013 = Carrier가 자동운전 초기화 되어 있지 않아 자동운전을 시작할 수 없습니다.
			return generateErrorCode(400013);
		if (!m_plnkTrsRTabCarrier[i]->IsInitialized())
			// 400013 = Carrier가 자동운전 초기화 되어 있지 않아 자동운전을 시작할 수 없습니다.
			return generateErrorCode(400013);
	}

	// Feeder 상태 확인
	if (m_plnkSystemData->m_eRunMode == NORMAL_RUN_MODE
		|| m_plnkSystemData->m_eRunMode == REPAIR_RUN_MODE)
	{
		iResult = CheckFeederEnable();
		if (iResult)
			return iResult;
	}
	else if (m_plnkSystemData->m_eRunMode == DRY_RUN_MODE)
	{
		BOOL bEmptyPanel = m_plnkTrsPanelAligner->IsEmptyPanel()
#ifdef DEF_SOURCE_SYSTEM
//@						&& m_plnkTrsPanelTransferCenter->IsEmptyPanel()
						&& m_plnkTrsPanelTransfer->IsEmptyPanel()
#endif
						&& m_plnkTrsPanelTransferOut->IsEmptyPanel();

		if (FALSE == bEmptyPanel)
			// 400025 = Panel이 감지되어 공운전을 시작할 수 없습니다.
			return generateErrorCode(400025);
	}

	/*/
	//SJ_YYK 110516 Add.. Dump Basket Always Backward to be Start
#ifdef DEF_SOURCE_SYSTEM
	if(FALSE == MOlbSystemPre.GetTabCarrierComponent(0)->IsBackwardDumpBasket())
	{
		if(iResult = MOlbSystemPre.GetTabCarrierComponent(0)->BackwardDumpBasket())
			return generateErrorCode(iResult);	
	}

	if(FALSE == MOlbSystemPre.GetRTabCarrierComponent(0)->IsBackwardDumpBasket())
	{
		if(iResult = MOlbSystemPre.GetRTabCarrierComponent(0)->BackwardDumpBasket())
			return generateErrorCode(iResult);	
	}
#endif
	/*/
	//__________________________________________________
	
	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

BOOL MTrsAutoManager::IsMaterialExchange()
{ 
	return m_bMaterialExchange; 
}

/**
 * EStopAllAxis 동작 수행
 * @return int 0=Success, 그외 = Error Code
 */
int MTrsAutoManager::EStopAllAxis()
{
	for (int i = 0; i < DEF_AXIS_MAX_AXIS; i++)
	{
		if (TRUE == MOlbSystemPre.IsSkipAxis(i))
			continue;

		m_plnkMotion[i]->EStop();
		Sleep(30);//2009.09.09 CYJ
	}

	ResetOriginAllAxis();

	resetAllInitialized();

	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

/**
 * Auto Ready 동작 수행
 * @return int 0=Success, 그외 = Error Code
 */
int	MTrsAutoManager::AutoReady()
{
	int iResult = checkStartRunCondition();
	if (iResult != ERR_TRS_AUTO_MANAGER_SUCCESS)
		return iResult;

	m_bAutoReady = TRUE;
	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

/** 
 * Auto Manager의 Auto Ready 여부
 * @param : TRUE = Ready , FALSE = Not Ready
 */
BOOL MTrsAutoManager::IsAutoReady()
{
	return m_bAutoReady;
}

void MTrsAutoManager::threadMonitoringJob()
{
	// 091028 공정 Key Parameter 측정...
	/*
	if (m_bMeasureProcessData)
	{
		// Parameter Data 측정
		m_iMeasParamError = MeasureProcessParameter();
		m_bMeasureProcessData = FALSE;
	}
	*/
	
	//ionizer 1200902 yh
	
	if (m_plnkSystemData->m_bUseIonizerCheck)
	{
		if (m_plnkIO->IsOff(IN_IONIZER_STATE_ONOFF) && IsOperatorCall()==FALSE)
		{
			CString strEqCmd;
			strEqCmd.Format(_T("Check the Ionizer. After Confirm, Start."));
			
//			::SendMessage(m_hAutoViewWnd, WM_DISP_OPCALL_MSG, (WPARAM)(&strEqCmd), NULL);
			SetOperatorCall(TRUE, strEqCmd);	
		}
	}

	//130517.kms_________
	//금형 인식 안되면 현재 상태 의 MOLD의 상태를 Disable 로 변경 한다.
	//___________________

	//______________________________________________
	// Add. 110525 기종변경 예약 Bit 추가
	if (TRUE == m_plnkSystemData->m_bUseAutoModelChange
		&& TRUE == GetNewModelReserveBit())
	{
		if (FALSE == m_bModelReserveStart)
		{
			m_plnkMelsecIF->GetNSMCWord(m_pNSMCControlData, m_iNSMCControlNo);
			m_strNewDeviceID = m_pNSMCControlData->m_strDeviceID;

			// Find Model for New DeviceID
			m_strNewModelFolderName.Empty();
			m_strNewModelFolderName = GetNewModelDataFolderName(m_strNewDeviceID);
			if (!m_strNewModelFolderName.IsEmpty())
			{
				SetNewModelName(m_strNewModelFolderName);
				//m_plnkSystemData->m_strNextModelFileName = m_strNewModelFolderName;

				// 기종변경 예약 완료 신호
				m_plnkMelsecIF->SetNSMCBit(eModelReserveComplete, TRUE);
				m_plnkMelsecIF->SetNSMCBit(eModelReserveDisable, FALSE);
			}
			else
			{
				m_strNewModelFolderName = _T("NONE");
				// 기종변경 예약 실패 신호
				m_plnkMelsecIF->SetNSMCBit(eModelReserveComplete, FALSE);
				m_plnkMelsecIF->SetNSMCBit(eModelReserveDisable, TRUE);


				MyMessageBox(_T("DeviceID received from Loader does not exist.\r\nLoader 로부터 받은 DeviceID가 존재 하지 않습니다."), _T("Can Not Read DeviceID!"), M_ICONERROR);
			}

			// 예약 Bit Off 확인
			m_timerModelReserve.StartTimer();
			m_bModelReserveStart = TRUE;
		}
		else
		{
			// 예약 Bit Off 확인
			if (m_timerModelReserve.IsTimerStarted())
			{
				if (FALSE == GetNewModelReserveBit() || m_timerModelReserve.MoreThan(5.0))
				{
					m_plnkMelsecIF->SetNSMCBit(eModelReserveComplete, FALSE);
					m_plnkMelsecIF->SetNSMCBit(eModelReserveDisable, FALSE);
					m_timerModelReserve.StopTimer();
					m_bModelReserveStart = FALSE;
				}
			}
		}
	}
	else
	{
		m_plnkMelsecIF->SetNSMCBit(eModelReserveComplete, FALSE);
		m_plnkMelsecIF->SetNSMCBit(eModelReserveDisable, FALSE);
		m_timerModelReserve.StopTimer();
		m_bModelReserveStart = FALSE;
	}
	//______________________________________________

	// 무언정지 감시 5초마다 한번씩 로그를 저장한다.
	m_iMonitoringCount++;
	if (m_iMonitoringCount % 10 == 0)
	{
		WriteMonitoringLog(getCurrentEquipState());
		m_iMonitoringCount = 0;
	}

	//SJ_YYK 150908 Add...
	if (GetOPMode() == MANUAL_MODE)
	{
		if(MOlbSystemPre.GetTabCarrierComponent(0)->IsDown() == TRUE)
			MOlbSystemPre.GetMelsecComponent2()->SetUpperEqBit(eTurnSafetyAOC1, TRUE, DEF_AOC_UNIT_NO_1,TRUE);
		else
			MOlbSystemPre.GetMelsecComponent2()->SetUpperEqBit(eTurnSafetyAOC1, FALSE, DEF_AOC_UNIT_NO_1,TRUE);

		if(MOlbSystemPre.GetTabCarrierComponent(0)->IsDown2() == TRUE)
			MOlbSystemPre.GetMelsecComponent2()->SetUpperEqBit(eTurnSafetyAOC1, TRUE, DEF_AOC_UNIT_NO_2,TRUE);
		else
			MOlbSystemPre.GetMelsecComponent2()->SetUpperEqBit(eTurnSafetyAOC1, FALSE, DEF_AOC_UNIT_NO_2,TRUE);
	}

	if (GetOPMode() != AUTORUN_MODE || GetOPStatus() != RUN)
		return;

	short bState;
	CString strMonitoringLog;
	m_plnkMelsecIF->GetHandShakeRecoveryAckReply_ToUpperEqBit(&bState);
	if (m_bMelsecSwitch && !bState)
	{
		m_iMelsecAlarmCount++;
		strMonitoringLog.Format(_T("Melsec Error: m_bMelsecswitch (%d) bState(%d). Times:%d"), m_bMelsecSwitch, bState, m_iMelsecAlarmCount);
		WriteMonitoringLog(strMonitoringLog);
	}
	if (!m_bMelsecSwitch && bState)
	{
		m_iMelsecAlarmCount++;
		strMonitoringLog.Format(_T("Melsec Error: m_bMelsecswitch (%d) bState(%d). Times:%d"), m_bMelsecSwitch, bState, m_iMelsecAlarmCount);
		WriteMonitoringLog(strMonitoringLog);
	}
	if (m_bMelsecSwitch)
	{
		m_plnkMelsecIF->SetHandShakeRecoveryAckReply_ToUpperEqBit(FALSE);
		m_plnkMelsecIF->SetHandShakeRecoveryAckReply_ToLowerEqBit(FALSE);//110223
		m_bMelsecSwitch = FALSE;
	}
	else
	{
		m_plnkMelsecIF->SetHandShakeRecoveryAckReply_ToUpperEqBit(TRUE);
		m_plnkMelsecIF->SetHandShakeRecoveryAckReply_ToLowerEqBit(TRUE);//110223
		m_bMelsecSwitch = TRUE;
	}

	
}

void MTrsAutoManager::CheckModelChangeDisable() //syr..SESL 090610
{
	//Empty 처리
	if (FALSE == m_bEmptyPanel && TRUE == m_bInputLastGlass) 
	//LastGlass 신호가 들어오고 Panel 있으면(즉 Empty가 아니면)..Timer Start
	{
      		if (FALSE == m_bEqpEmptyCheckTimerStarted)
		{
			m_bEqpEmptyCheckTimerStarted = TRUE;
			m_eqpEmptyCheckTimer.StartTimer();
		}
	}
	else //Panel 없으면..Timer End
	{
		m_bEqpEmptyCheckTimerStarted = FALSE;
		m_eqpEmptyCheckTimer.StopTimer();
	}

	//Run이면서 Panel이 60초 이상 머물러 있을 경우 T2 보고
	if (DRY_RUN_MODE != m_plnkSystemData->m_eRunMode
		&& GetOPStatus() == RUN ) //Run 일 때
	{			
		if (TRUE == m_bEqpEmptyCheckTimerStarted && m_eqpEmptyCheckTimer.MoreThan(600.0)) 
		{
			if (DEF_T2_STATE != m_iModelChangeDisableState)
			{
				m_iModelChangeDisableState = DEF_T2_STATE; // NSMC Can not
				m_pNSMCLocalData->m_strReplyCode.Format(_T("T2")); //T2를 Loader에 보고
				m_pNSMCLocalData->m_strEQState.Format(_T("%d"), GetOPStatus());
				m_plnkMelsecIF->SetNSMCWord(m_pNSMCLocalData);
				m_plnkMelsecIF->SetNSMCBit(eModelChangeDisable, TRUE);
			}
		}
		else 
		{
			if (DEF_NORMAL_STATE != m_iModelChangeDisableState)
			{
				m_iModelChangeDisableState = DEF_NORMAL_STATE; //NSMC Can
				m_pNSMCLocalData->m_strReplyCode.Format(_T(""));
				m_pNSMCLocalData->m_strEQState.Format(_T("%d"), GetOPStatus());
				m_plnkMelsecIF->SetNSMCWord(m_pNSMCLocalData);
				m_plnkMelsecIF->SetNSMCBit(eModelChangeDisable, FALSE);				
			}
		}
	}
	else //Run 아닐 때는 Down 보고
	{
		if (DEF_DOWN_STATE != m_iModelChangeDisableState) 
		{
			m_iModelChangeDisableState = DEF_DOWN_STATE;  //NSMC Can not
			m_pNSMCLocalData->m_strReplyCode.Format(_T("Down"));
			m_pNSMCLocalData->m_strEQState.Format(_T("%d"), GetOPStatus());
			m_plnkMelsecIF->SetNSMCWord(m_pNSMCLocalData);
			m_plnkMelsecIF->SetNSMCBit(eModelChangeDisable, TRUE);		
		}
	}
}

/** 
 * MTrsAutoManager Thread Job
 */
void MTrsAutoManager::threadJob()
{
	//20100212.kms_________________________________
//	CWnd* pParent;
//	pParent = CWnd::FromHandle(m_hTitleViewWnd);
//	CEqStopDlg Dlg(pParent);
	//_____________________________________________

//	ProcessParamReport();

	// TT_Alarm
	if (TRUE == IsTactTimeLogSave())
	{
		// Timer 동작 시작
		// Flag False로 해서 다음에 여기로 못 들어오게 함
		m_timerTactTimeLogSave.StartTimer();
		WriteTactTimeLog("TEST Start");
		SetTactTimeLogSave(FALSE);
	}
	if (m_timerTactTimeLogSave.MoreThan(300.0))
	{
		// Timer를 중지 시키고, T/T를 못찍게 수정...
		m_timerTactTimeLogSave.StopTimer();
		WriteTactTimeLog("TEST End");

		m_ucLevel = DEF_MLOG_NONE_LOG_LEVEL;
		if (m_plnkSystemData->m_bLogLevelError)
			m_ucLevel |= DEF_MLOG_ERROR_LOG_LEVEL;
		if (m_plnkSystemData->m_bLogLevelMonitoring)
			m_ucLevel |= DEF_MLOG_MONITORING_LOG_LEVEL;
		if (m_plnkSystemData->m_bLogLevelNormal)
			m_ucLevel |= DEF_MLOG_NORMAL_LOG_LEVEL;
		//170427 JSh.s
		if (m_plnkSystemData->m_bLogLevelTactTime)
			m_ucLevel |= DEF_MLOG_TACT_TIME_LOG_LEVEL;
		if (m_plnkSystemData->m_bLogLevelEqTactTime)
			m_ucLevel |= DEF_MLOG_EQ_TACT_TIME_LOG_LEVEL;
		//170427 JSh.e
	
		MOlbSystemPre.SetLogAttribute(m_ucLevel, m_plnkSystemData->m_iLogKeepingDays);
	}

//SESL_LKH_090713 : Heater Alarm 전설비 통일(Final에서 차용)
/*
	int iResult = checkHeaterAlarm();
	if (iResult)
	{
		SetErrorLevel(_T("AUTO MANAGER check Heater Alarm"), 0, __FILE__, __LINE__);
		PROCESS_AUTOMANAGER_ALARM(iResult);
	}
*/
	// Heater Alarm
#ifndef SIMULATION
	// hongju_SESL : Autorun 상태에서는 무조건 실행..그 외에는 Data 설정에 따라 실행.
	if (m_plnkSystemData->m_bUseHeaterAlarm || AUTORUN_MODE == GetOPMode()) 
	{
		int iResult = checkHeaterAlarm();
		if (iResult)
		{
			Sleep(100);
			if (FALSE == m_plnkOpPanel->GetEStopButtonStatus() || m_bEStopPressed)		//@
			{
				// 20081007 jdy : Heater Alarm 은 Auto/Manual 상관없이 항상 Display 되도록 수정.
				// Heater Alarm 발생 상태이면 더 이상 ThreadJob 은 진행되지 않는다.
				// 진행이 필요하면 별도 작업할 것.

				// 20090404 hans Heater Alarm Counter 
				// 15초 단위로 Alarm Display
				m_iHeaterAlarmCount++;
				if (m_iHeaterAlarmCount % 15 == 0)
				{
					PROCESS_AUTOMANAGER_ALARM(iResult);
					m_iHeaterAlarmCount = 0;
				}
			}
		}
	}
#endif

	//NSMC KJS
	CheckModelChangeDisable(); //syr..SESL 090610

	if (DRY_RUN_MODE != m_plnkSystemData->m_eRunMode
		&& GetOPStatus() == RUN)
	{
		if (FALSE != m_bOldModelChangeDisable)
		{
			m_bOldModelChangeDisable = FALSE;
			m_pNSMCLocalData->m_strReplyCode.Format(_T(""));
			m_pNSMCLocalData->m_strEQState.Format(_T("%d"), GetOPStatus());
			m_plnkMelsecIF->SetNSMCWord(m_pNSMCLocalData);
			m_plnkMelsecIF->SetNSMCBit(eModelChangeDisable, FALSE);
		}
	}
	else
	{
		if (TRUE != m_bOldModelChangeDisable)
		{
			m_bOldModelChangeDisable = TRUE;
			m_pNSMCLocalData->m_strReplyCode.Format(_T("DOWN"));
			m_pNSMCLocalData->m_strEQState.Format(_T("%d"), GetOPStatus());
			m_plnkMelsecIF->SetNSMCWord(m_pNSMCLocalData);
			m_plnkMelsecIF->SetNSMCBit(eModelChangeDisable, TRUE);
		}
	}



	switch (GetOPMode())
	{
	case MANUAL_MODE:
		//111022 sj_kjs
		m_TimerMachineStopTime.StartTimer();
		//___________________________//

		//100928.KKY.알람정지일 경우 PM상태를 유지하고, Run시 Normal로 변경한다_____
		// 장비 상태 보고 
		if (m_plnkLCNet->m_eEqState != ePM && m_plnkLCNet->m_eEqState != eNormal)
		{
			m_plnkLCNet->EqStateReport(eNormal);
			::PostMessage(m_hAutoViewWnd, WM_DISP_EQ_STATE, (WPARAM)(eNormal), NULL);
		}
		//___________________________________________________________________________

		//설비 유실 보고 Dialog Box 에서 보고
//		if (m_plnkLCNet->m_eEqProcState != ePause && m_plnkLCNet->m_eEqProcState != eInit)
//		{
//			m_plnkLCNet->EqProcessStateReport(ePause);
//			::PostMessage(m_hAutoViewWnd, WM_DISP_EQP_STATE, (WPARAM)(ePause), NULL);
//		}

		if (TRUE == m_bAutoReady)
		{
			// 장비 START Switch Check
			if (TRUE == m_plnkManageOpPanel->GetStartSWStatus())
			{
				if (DRY_RUN_MODE != m_plnkSystemData->m_eRunMode && !m_plnkLCNet->m_bConnected)
				{
					//L/C 와의 통신 연결을 기다리고 있습니다.\r\nSTOP Key 를 누르면, Manual Mode 로 돌아갑니다.
					CString strMsg;
					ReadDisplayMessage(MY_MESSAGE_BOX, _T("Message_62005"), &strMsg);
#ifndef DEF_SETUP
					// jdy sesl 081230	USES_CONVERSION; // 꼭 해줘야 함
					
					// jdy sesl 081230	char* szMsg = NULL;
					// jdy sesl 081230	szMsg = W2A(strMsg.GetBuffer(strMsg.GetLength()));
					
					if (m_hTitleViewWnd)
						// jdy sesl 081230	::SendMessage(m_hTitleViewWnd, WM_DISP_MY_MESSAGE, TRUE, (LPARAM)szMsg);
						::SendMessage(m_hTitleViewWnd, WM_DISP_MY_MESSAGE, TRUE, (LPARAM)(strMsg.GetBuffer(strMsg.GetLength())));

					MTickTimer timerLimit;
					timerLimit.StartTimer();
#endif
					while (!m_plnkLCNet->m_bConnected)
					{
#ifndef DEF_SETUP
						Sleep(100);

						if (TRUE == timerLimit.MoreThan(30.0))
#endif
						{
							if (m_hTitleViewWnd)
								::SendMessage(m_hTitleViewWnd, WM_DISP_MY_MESSAGE, FALSE, NULL);

							//통신상태가 오프라인이므로 자재 정보를 관리할 수 없습니다. 계속 진행하시겠습니까?
							if (MyMessageBox(MY_MESSAGE_BOX,62006, _T("Question"), M_YESNO|M_ICONQUESTION) == IDNO) // 2009.01.05 3
							{
								SetOPMode(MANUAL_MODE);
								SetOPStatus(STEP_STOP);
								m_bAutoReady = FALSE;
								return;
							}

							break;	// escape from while loop.
						}

						if (TRUE == m_plnkManageOpPanel->GetStopSWStatus())
						{
							if (m_hTitleViewWnd)
								::SendMessage(m_hTitleViewWnd, WM_DISP_MY_MESSAGE, FALSE, NULL);
							
							SetOPMode(MANUAL_MODE);
							SetOPStatus(STEP_STOP);
							m_bAutoReady = FALSE;
							return;
						}
					}
				}

				SetOPMode(AUTORUN_MODE);
				SetOPStatus(START_RUN);
				
				if (m_hTitleViewWnd)
					::SendMessage(m_hTitleViewWnd, WM_DISP_MY_MESSAGE, FALSE, NULL);
				
				m_timerSkipError.StartTimer();
				
				m_bAutoReady = FALSE;
				break;
			}

			// 장비 STOP Switch Check
			if (TRUE == m_plnkManageOpPanel->GetStopSWStatus())
			{
				if (m_hTitleViewWnd)
					::SendMessage(m_hTitleViewWnd, WM_DISP_MY_MESSAGE, FALSE, NULL);
				
				SetOPStatus(STEP_STOP);
				SetOPMode(MANUAL_MODE);
				m_bAutoReady = FALSE;			
				break;
			}
		}

		//EQ_STOP Report Flag 추가 100121 SJ_YYK
		m_bStepStopState = FALSE;

		//101204.kms____________
		//환경 안전 관련하여 Manual  상태 에서도 Door 가 Open 되어있으면 
		//Alarm 발생
		if (IsDoorOpen())
		{
			if(m_plnkIO->IsOn(IN_FRONT_DOOR1)
				&& m_plnkIO->IsOn(IN_FRONT_DOOR2)
				&& m_plnkIO->IsOn(IN_FRONT_DOOR3)
				&& m_plnkIO->IsOn(IN_FRONT_DOOR4)
				&& m_plnkIO->IsOn(IN_FRONT_DOOR5)
				&& m_plnkIO->IsOn(IN_FRONT_DOOR6)
				&& m_plnkIO->IsOn(IN_REAR_DOOR1)
				&& m_plnkIO->IsOn(IN_REAR_DOOR2)
				&& m_plnkIO->IsOn(IN_REAR_DOOR3)
				&& m_plnkIO->IsOn(IN_REAR_DOOR4)
				&& m_plnkIO->IsOn(IN_REAR_DOOR5)
				&& m_plnkIO->IsOn(IN_REAR_DOOR6)
			   )
			{
				m_bDoorCheck = TRUE;
			}
			else
			{
				if(m_bDoorLockCheck == FALSE)
				{
					m_bDoorCheck = FALSE;
				}
				
			}

			if(m_bDoorCheck == FALSE)
			{
				m_bDoorCheck = TRUE;
				
				m_bDoorLockCheck = TRUE;
				//Manual Mode 에서 Door Open 이 감지되었습니다. 작업자는 안전에 유의 하십시요.
				PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400006));
			}
		}
		else
		{
			m_bDoorCheck = FALSE;
			
			m_bDoorLockCheck = FALSE;
		}
		//________________________
		//111022 sj_kjs
		if (m_TimerMachineStopTime.MoreThan(m_plnkSystemData->m_dEmptyElapseTime * 60 ))
		{
			IonaizerBlowOnOff(FALSE); 
		}
		//________________________________________________

		break;
		
	case AUTORUN_MODE:
		switch (GetOPStatus())
		{
		case ERROR_STOP:
			//111022 sj_kjs
			m_TimerMachineStopTime.StartTimer();
			//_________________________________

			if (FALSE == m_bErrorProcessing)
				SetOPStatus(STEP_STOP);

			//EQ_STOP Report Flag 추가 100121 SJ_YYK
			m_bErrorStopState = TRUE;
			m_bStepStopState = FALSE;

			break;
			
		case STEP_STOP:

			//111022 sj_kjs
			m_TimerMachineStopTime.StartTimer();
			//_________________________________

			//EQ_STOP Report Flag 추가 100121 SJ_YYK
			if(m_bErrorStopState == FALSE)
				m_bStepStopState = TRUE;

			if (TRUE == isAllStepStop()) 
			{ 
			  //syr..090508
				m_bStepStopPressed = FALSE;
				SetOPMode(MANUAL_MODE);	

				//EQ_STOP Report Flag 추가 100121 SJ_YYK
				if(m_bStepStopState == TRUE)
				{
//					Sleep(1000);
//					Dlg.DoModal();
					//100825.KMS
					::SendMessage(m_hTitleViewWnd, WM_DISP_EQSTOP_MSG, NULL, NULL);
					m_bStepStopState = FALSE;
				}

				//120508.kms_________
#ifndef DEF_SETUP
				if (MOlbSystemPre.GetCurrentUserGroup() != OPERATOR_GROUP)
					::SendMessage(m_hTitleViewWnd, WM_DISP_OPERATER_MSG, NULL, NULL);
#endif
				//___________________
				
				/*if(m_iStopBtnOnStatus == DEF_STOP_BTN_FRONT)
				{
					if(m_plnkIO->IsOff(OUT_TOUCH_MONITOR_CHANGE))
					{// 모니터 앞면 활성화 아닌 경우
						m_plnkIO->OutputOn(OUT_TOUCH_MONITOR_CHANGE);		
					}
					
					m_iStopBtnOnStatus = DEF_STOP_BTN_NONE;
					Dlg.DoModal();
				}
				else if(m_iStopBtnOnStatus == DEF_STOP_BTN_BACK)
				{
					if(m_plnkIO->IsOn(OUT_TOUCH_MONITOR_CHANGE))
					{// 모니터 뒷면 활성화 아닌 경우
						m_plnkIO->OutputOff(OUT_TOUCH_MONITOR_CHANGE);		
					}
					
					m_iStopBtnOnStatus = DEF_STOP_BTN_NONE;
					Dlg.DoModal();
				}*/
				//______________________________________________________________
			}

			break;
			
		case START_RUN:

			//EQ_STOP Report Flag 추가 100121 SJ_YYK
			m_bStepStopState = FALSE;

			if (TRUE == isAllAutoRun())
			{
				//100928.KKY.알람정지일 경우 PM상태를 유지하고, Run시 Normal로 변경한다_____
				// 장비 상태 보고 
				if (m_plnkLCNet->m_eEqState != eNormal)
				{
					m_plnkLCNet->EqStateReport(eNormal);
					::PostMessage(m_hAutoViewWnd, WM_DISP_EQ_STATE, (WPARAM)(eNormal), NULL);
				}
				//___________________________________________________________________________

				SetOPStatus(RUN);
			}

//			m_plnkTabFeeder[DEF_TABFEEDER1]->PReelMotorOn();
//			m_plnkTabFeeder[DEF_TABFEEDER2]->PReelMotorOn();

			if (TRUE == m_plnkManageOpPanel->GetStopSWStatus())
				SetOPStatus(STEP_STOP);

			break;
			
		case CYCLE_STOP:

			//EQ_STOP Report Flag 추가 100121 SJ_YYK
			m_bStepStopState = FALSE;

			if (TRUE == isAllStepStop())
			{
				SetOPStatus(STEP_STOP);
				break;
			}
			/* FALL THROUGH : Cycle Stop이 될 때 까지 Run과 같이 실행 되어야 한다. */
			
		case RUN:

			

			//EQ_STOP Report Flag 추가 100121 SJ_YYK
			m_bStepStopState = FALSE;

			if (TRUE == m_bErrorProcessing)
			{
				SetOPStatus(ERROR_STOP);
				break;
			}
			
			processOpPanel();
			m_bErrorStopState = FALSE; //SJ_YYK 100121

			//110817 SJ_KJS
#ifndef DEF_SETUP
			//110901. SJ_YTH. 공운전시에도 메세지 창 안열리게...
			if(m_plnkSystemData->m_eRunMode != DRY_RUN_MODE)
			{
				if (!m_plnkLCNet->m_bConnected)
				{
					CString strEqCmd;
					strEqCmd.Format(_T("LC와 연결이 끊어졌습니다. 연결상태를 확인해 주세요.\n It is not connected with LC Please check."));		
					SetOperatorCall(TRUE, strEqCmd);
					//SetOPStatus(STEP_STOP);
					m_bLCConnected = FALSE;
				}
				else
				{
					//if(m_bOperatorCall == TRUE)
					if(m_bLCConnected == FALSE)
					{
						m_bLCConnected = TRUE;
						SetOperatorCall(FALSE, "");
					}
				}
			}
#endif
			//________________


			//SESL_요구사항반영
#ifdef DEF_SESL_SITE
			checkMoldCount();
#endif
			break;
		}
		break;
	}

	m_plnkLCNet->Lock(); //110629.KKY
	processNetState();	// LCNet 동작 
	m_plnkLCNet->Unlock();	//110629.KKY

	// 2011.11.05 Park, YK - //ELLAS_111103
	//ELLAS_110630 전후 설비 물류 상태 확인
	checkMelecFlowState();
	//ELLAS_110712 전설비 정지 확인, Network상태 확인
	checkUpperEquipPause();

// 	if (!MOlbSystemPre.GetRSNMCSetupComponent()->IsMasterRun())
// 	{
// 		AfxMessageBox(_T("Master Ring Error.!"));
// 	}
// 	
// 	if (!MOlbSystemPre.GetRSNMCSetupComponent()->IsSlaveOpModeAll())
// 	{
// 		AfxMessageBox(_T("Slave Ring Error.!"));
// 	}
	// End.

}

void MTrsAutoManager::threadRealTimeJob()
{
	int i = 0;

	// Net Ready 설정
	if (!m_plnkMelsecIF->IsConnected())
	{
		m_plnkIO->OutputOff(m_rgusUpperOUT[eNetReady]);
		m_plnkIO->OutputOff(m_rgusLowerOUT[eNetReady]);
	}
	else
	{
		m_plnkIO->OutputOn(m_rgusUpperOUT[eNetReady]);
		m_plnkIO->OutputOn(m_rgusLowerOUT[eNetReady]);
	}

//@	/*/
	// E-Stop 처리
	//090616 Suwon
	//if (TRUE == m_plnkOpPanel->GetEStopButtonStatus())
	if ((TRUE == m_plnkOpPanel->GetEStopButtonStatus() 
		|| TRUE == m_plnkIO->IsOff(IN_E_STOP_RELAY_CHECK) //170904 JSH
		|| TRUE == m_plnkIO->IsOff(IN_E_STOP_RELAY_CHECK2) //170904 JSH
		|| TRUE == m_plnkIO->IsOff(IN_E_STOP_RELAY_CHECK3) //170904 JSH
		) && !m_bEStopPressed)
	{
		if (FALSE == m_bEStopPressed)
		{
			m_bEStopPressed = TRUE;

			// hongju 수정...EStopAllAxis()에서 모두 처리..
			EStopAllAxis();
//			ResetOriginAllAxis();
//			resetAllInitialized();

			::PostMessage(m_hTitleViewWnd, WM_DISP_E_STOP_STATUS, TRUE, NULL);
		}
		m_plnkIO->OutputOff(m_rgusUpperOUT[eEmergency]);
		m_plnkIO->OutputOff(m_rgusLowerOUT[eEmergency]);
		Sleep(1);

		PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400035));
	}
	else
	{
		m_plnkIO->OutputOn(m_rgusUpperOUT[eEmergency]);
		m_plnkIO->OutputOn(m_rgusLowerOUT[eEmergency]);
	}
//@	/*/	

//@	if (TRUE == m_plnkIO->IsOff(IN_E_STOP_RELAY_CHECK) || m_bEStopPressed == TRUE)
	if (TRUE == m_plnkOpPanel->GetEStopButtonStatus() || m_bEStopPressed == TRUE)
	{
		if (TRUE == m_plnkManageOpPanel->GetResetSWStatus())
		{
			//jdy sesl 081230	USES_CONVERSION; // 꼭 해줘야 함
			//090616 Suwon
			if (TRUE == m_bEStopPressed)
				::PostMessage(m_hTitleViewWnd, WM_DISP_E_STOP_STATUS, FALSE, NULL);
			
//@			m_bEStopPressed = FALSE;
            //--------------------

			CString strMsg;
			//jdy sesl 081230	char* szMsg = NULL;
			//Power Reset 작업 진행 중...
			ReadDisplayMessage(MY_MESSAGE_BOX, _T("Message_62007"), &strMsg);
			//jdy sesl 081230	szMsg = W2A(strMsg.GetBuffer(strMsg.GetLength()));
			
			if (m_hTitleViewWnd)
				//jdy sesl 081230	::SendMessage(m_hTitleViewWnd, WM_DISP_MY_MESSAGE, TRUE, (LPARAM)szMsg);
				::SendMessage(m_hTitleViewWnd, WM_DISP_MY_MESSAGE, TRUE, (LPARAM)(strMsg.GetBuffer(strMsg.GetLength())));

			m_plnkMotion[DEF_AXIS_ACS_GANTRY_Y]->NodeClear();
			m_plnkMotion[DEF_AXIS_ACS_R_GANTRY_Y]->NodeClear();
			ResetAllMotorEvent();			

			//@________________
			// ACS 제어기 Reset 시간
//@			Sleep(20000);

			//20130927 SJ_HJG
			/*
			m_plnkIO->OutputOff(OUT_HEATER_POWER_RESET);
			DWORD sTime = GetTickCount();
			while(1)
			{
				Sleep(10);
				if (GetTickCount() - sTime > 20000)
					break;
				if (GetTickCount() - sTime > 100)
					m_plnkIO->OutputOn(OUT_HEATER_POWER_RESET);
				if (GetTickCount() - sTime > 1500 && m_plnkIO->IsOn(OUT_HEATER_POWER_RESET))
					m_plnkIO->OutputOff(OUT_HEATER_POWER_RESET);
			}
			//@_________________
			
			m_plnkIO->OutputOff(OUT_POWER_RESET);
//@			m_plnkIO->OutputOff(OUT_HEATER_POWER_RESET);
			Sleep(10);
			
			m_plnkIO->OutputOn(OUT_POWER_RESET);
			m_plnkIO->OutputOn(OUT_HEATER_POWER_RESET);
			Sleep(1000);
			
			m_plnkIO->OutputOff(OUT_POWER_RESET);
			m_plnkIO->OutputOff(OUT_HEATER_POWER_RESET);
			
			sTime = GetTickCount();
			while(1)
			{
				Sleep(10);
				if (FALSE == m_plnkOpPanel->GetEStopButtonStatus())
					break;
				if (GetTickCount() - sTime > 10000)
					break;
			}

			*/

			m_plnkIO->OutputOn(OUT_POWER_RESET);
			Sleep(1000);
			m_plnkIO->OutputOff(OUT_POWER_RESET);
			Sleep(1000);
			m_plnkIO->OutputOn(OUT_POWER_RESET);
			Sleep(1000);
			m_plnkIO->OutputOff(OUT_POWER_RESET);
			Sleep(1000);
			
			m_plnkIO->OutputOn(OUT_POWER_RESET_SECOND);
			Sleep(1000);
			m_plnkIO->OutputOff(OUT_POWER_RESET_SECOND);
			Sleep(1000);
			m_plnkIO->OutputOn(OUT_POWER_RESET_SECOND);
			Sleep(1000);
			m_plnkIO->OutputOff(OUT_POWER_RESET_SECOND);
			Sleep(1000);
			
			m_plnkIO->OutputOn(OUT_SERVO_CONTROL_POWER_OFF);
			Sleep(1000);
			m_plnkIO->OutputOff(OUT_SERVO_CONTROL_POWER_OFF);
			Sleep(1000);
			m_plnkIO->OutputOn(OUT_SERVO_CONTROL_POWER_OFF);
			Sleep(1000);
			m_plnkIO->OutputOff(OUT_SERVO_CONTROL_POWER_OFF);
			
			DWORD sTime = GetTickCount();

			BOOL bResetCheck = FALSE;
			while(1)
			{
				Sleep(10);
				if (FALSE == m_plnkOpPanel->GetEStopButtonStatus())
					break;
				if(bResetCheck == FALSE)
				{
					if (GetTickCount() - sTime > 10000)
					{
						m_plnkIO->OutputOn(OUT_POWER_RESET);
						Sleep(1000);
						m_plnkIO->OutputOff(OUT_POWER_RESET);
						Sleep(1000);
						m_plnkIO->OutputOn(OUT_POWER_RESET);
						Sleep(1000);
						m_plnkIO->OutputOff(OUT_POWER_RESET);
						Sleep(1000);
						
						m_plnkIO->OutputOn(OUT_POWER_RESET_SECOND);
						Sleep(1000);
						m_plnkIO->OutputOff(OUT_POWER_RESET_SECOND);
						Sleep(1000);
						m_plnkIO->OutputOn(OUT_POWER_RESET_SECOND);
						Sleep(1000);
						m_plnkIO->OutputOff(OUT_POWER_RESET_SECOND);
						Sleep(1000);
						
						m_plnkIO->OutputOn(OUT_SERVO_CONTROL_POWER_OFF);
						Sleep(1000);
						m_plnkIO->OutputOff(OUT_SERVO_CONTROL_POWER_OFF);
						Sleep(1000);
						m_plnkIO->OutputOn(OUT_SERVO_CONTROL_POWER_OFF);
						Sleep(1000);
						m_plnkIO->OutputOff(OUT_SERVO_CONTROL_POWER_OFF);
						bResetCheck = TRUE;
						break;
					}

				}

				if (GetTickCount() - sTime > 20000)
					break;
			}
			

			MOlbSystemPre.GetSercosSetupComponent()->SercosSetup();
			//_______________

			m_bEStopPressed = FALSE;
			if (m_hTitleViewWnd)
				::SendMessage(m_hTitleViewWnd, WM_DISP_MY_MESSAGE, FALSE, NULL);
		}
	}

	if (TRUE == m_plnkOpPanel->GetTPStatus())
	{
		if (FALSE == m_bTPConnected)
			::PostMessage(m_hTitleViewWnd, WM_DISP_TEACH_PENDANT_CONNECTING_STATUS, TRUE, NULL);

		m_bTPConnected = TRUE;
	}
	else
	{
		if (TRUE == m_bTPConnected)
			::PostMessage(m_hTitleViewWnd, WM_DISP_TEACH_PENDANT_CONNECTING_STATUS, FALSE, NULL);

		m_bTPConnected = FALSE;
	}

	switch (GetOPMode())
	{
	case MANUAL_MODE:

		if (TRUE == m_bDisplayManualModeChangeMsg)
		{
			m_bDisplayManualModeChangeMsg = FALSE;
			::SendMessage(m_hTitleViewWnd, WM_DISP_MY_MESSAGE, FALSE, NULL);
		}

		// Manual 시 Safety 무효화 (Y034, Y035)
		SafetyModeInvalidate(TRUE);

		m_plnkIO->OutputOff(m_rgusUpperOUT[eMachineRun]);
		m_plnkIO->OutputOff(m_rgusLowerOUT[eMachineRun]);
//		m_plnkIO->OutputOn(OUT_SAFETY_INVALIDATION1);
//		m_plnkIO->OutputOn(OUT_SAFETY_INVALIDATION2);

		break;

	case AUTORUN_MODE:
		
		switch (GetOPStatus())
		{
		case ERROR_STOP:
			if (TRUE == m_bErrorProcessing)
				break;

			// Fall Through

		case STEP_STOP:
			
			if (FALSE == m_bDisplayManualModeChangeMsg)
			{
				m_bDisplayManualModeChangeMsg = TRUE;
				
				//jdy sesl 081230	USES_CONVERSION; // 꼭 해줘야 함
		
//				CString strMsg; //syr..090508
				//jdy sesl 081230	char* szMsg = NULL;
				//Operation Mode 전환 중입니다.
//				ReadDisplayMessage(MY_MESSAGE_BOX, _T("Message_62008"), &strMsg); //syr..090508
				//jdy sesl 081230	szMsg = W2A(strMsg.GetBuffer(strMsg.GetLength()));
				
				//jdy sesl 081230	::SendMessage(m_hTitleViewWnd, WM_DISP_MY_MESSAGE, TRUE, (LPARAM)szMsg);
//				::SendMessage(m_hTitleViewWnd, WM_DISP_MY_MESSAGE, TRUE, (LPARAM)(strMsg.GetBuffer(strMsg.GetLength()))); //syr..090508
			}
			break;

		case START_RUN:
			break;
			
		case CYCLE_STOP:
			break;
			
		case RUN:
			/* jdy 12pm_s
			// Tower Lamp : Panel Empty 표시
			m_bEmptyPanel = m_plnkTrsLoadConveyor->IsEmptyPanel()
				&& m_plnkTrsPanelTransfer->IsEmptyPanel()
				&& m_plnkTrsPanelAligner->IsEmptyPanel()
				&& m_plnkTrsUnloadConveyor->IsEmptyPanel();
			*/
			m_plnkIO->OutputOn(m_rgusUpperOUT[eMachineRun]);
			m_plnkIO->OutputOn(m_rgusLowerOUT[eMachineRun]);

			m_bEmptyPanel = isNoPanelInEquipment();
			// jdy 12pm_e

			//2009.05.15 CYJ
			m_bFullPanel = isFullPanelInEquipment();

			
			if (TRUE == m_plnkSystemData->m_bSafetySensor)
			{
				// sesl_jdy 삭제 할 것. // Manual 시 Safety 무효화 해제. (Y034, Y035)
				// Auto Mode 시 Safety 무효화 해제. (Y034, Y035)
				// SafetyModeInvalidate(FALSE); 101027 del....
//				m_plnkIO->OutputOff(OUT_SAFETY_INVALIDATION1);
//				m_plnkIO->OutputOff(OUT_SAFETY_INVALIDATION2);
			}

			//20110914 sj_hjg
			if (TRUE == m_bEmptyPanel)
			{
				if (FALSE == m_bEqpEmptyCheckTimerStarted)
				{
					m_bEqpEmptyCheckTimerStarted = TRUE;
					m_eqpEmptyCheckTimer.StartTimer();
				}
			}
			else
			{
				m_bEqpEmptyCheckTimerStarted = FALSE;
				m_eqpEmptyCheckTimer.StopTimer();
			}

			if (TRUE == m_bEqpEmptyCheckTimerStarted && m_eqpEmptyCheckTimer.MoreThan(m_plnkSystemData->m_dEmptyElapseTime* 60)) 
			{
				m_plnkPanelAligner->AirCVBlowOff();
//@				m_plnkPanelTransfer->AirCVBlowOff();
//@				m_plnkPanelTransferCenter->AirCVBlowOff();
//@				m_plnkPanelTransferOut->AirCVBlowOff();
				m_bAirCVBlowOff = TRUE;
				//111022 sj_kjs
				IonaizerBlowOnOff(FALSE);

			}
			else
			{
				if(m_bAirCVBlowOff == TRUE)
				{
					m_plnkPanelAligner->AirCVBlowOn();
//@					m_plnkPanelTransfer->AirCVBlowOn();
//@					m_plnkPanelTransferCenter->AirCVBlowOn();
//@					m_plnkPanelTransferOut->AirCVBlowOn();
					m_bAirCVBlowOff = FALSE;
				}
				//111022 sj_kjs
				if (TRUE == IsIonaizerBlowOnOff())
				{
					IonaizerBlowOnOff(TRUE);
				}
				//_______________________________
			}
			//________________________
			
			//2009.05.15 CYJ 
			//Full 처리
			if (TRUE == m_bFullPanel)
			{
				if (FALSE == m_bEqpFullCheckTimerStarted)
				{
					m_bEqpFullCheckTimerStarted = TRUE;
					m_eqpFullCheckTimer.StartTimer();
				}
			}
			else
			{
				m_bEqpFullCheckTimerStarted = FALSE;
				m_eqpFullCheckTimer.StopTimer();
			}

			// 장비 상태 보고 
			if (m_plnkSystemData->m_eRunMode != DRY_RUN_MODE)
			{
				if (m_bEmptyPanel && m_plnkLCNet->m_eEqProcState != eIdle)
				{
					m_plnkLCNet->EqProcessStateReport(eIdle);
					::PostMessage(m_hAutoViewWnd, WM_DISP_EQP_STATE, (WPARAM)(eIdle), NULL);
				}

				//2009.05.15 CYJ
				if (m_bFullPanel)
				{
					if (TRUE == m_bEqpFullCheckTimerStarted
						&& m_eqpFullCheckTimer.MoreThan(60.0))
					{
						if (m_plnkLCNet->m_eEqProcState != eIdle)
						{
#ifndef SIMULATION
							m_plnkLCNet->EqStateReport(eNormal);
							m_plnkLCNet->EqProcessStateReport(eIdle);
#endif
							::SendMessage(m_hAutoViewWnd, WM_DISP_EQ_STATE, (WPARAM)(eNormal), NULL);
							::SendMessage(m_hAutoViewWnd, WM_DISP_EQP_STATE, (WPARAM)(eIdle), NULL);
						}
					}
					
				}

//				if (!m_bEmptyPanel && m_plnkLCNet->m_eEqProcState != eExecute)
				if (!m_bFullPanel && !m_bEmptyPanel && m_plnkLCNet->m_eEqProcState != eExecute)
				{
					m_plnkLCNet->EqProcessStateReport(eExecute);
					::PostMessage(m_hAutoViewWnd, WM_DISP_EQP_STATE, (WPARAM)(eExecute), NULL);
				}
			}

			if (m_plnkSystemData->m_eRunMode != DRY_RUN_MODE)
			{
				if (m_plnkMelsecIF->IsOnUpperEqBit(eImmediatelyPauseRequest))
				{
					SetOPStatus(STEP_STOP);
					WriteMonitoringLog("Upper eImmediatelyPauseRequest");
					//SESL_LKH_090713
					//전설비 E-STOP에 의해 StepStop 상태로 변경되었습니다.
					MyMessageBox(MY_MESSAGE_BOX,62021,_T("Lower Equip EStop is occurred."),M_ICONINFORMATION);
				}

				
				if (m_plnkMelsecIF->IsOnLowerEqBit(eImmediatelyPauseRequest))
				{
					SetOPStatus(STEP_STOP);
					WriteMonitoringLog("Lower eImmediatelyPauseRequest");
					//후설비 E-STOP에 의해 StepStop 상태로 변경되었습니다.
					MyMessageBox(MY_MESSAGE_BOX,62020,_T("Lower Equip EStop is occurred."),M_ICONINFORMATION);
				}
			}				
/*
#ifndef SIMULATION
			// Vacuum 출력은 On 인데, Sensor 입력은 Off 인 경우.
			if (TRUE == m_plnkIO->IsOn(OUT_TABPRESS1_ATTACH_NEW_REEL_VACCUM_ON)
				&& FALSE == m_plnkTabFeeder[DEF_TABFEEDER1]->IsAbsorbNewReel())
			{
				m_plnkTabFeeder[DEF_TABFEEDER1]->ReleaseNewReel(TRUE);
			}

#	ifdef DEF_GATE_SYSTEM
			if (TRUE == m_plnkIO->IsOn(OUT_TABPRESS2_ATTACH_NEW_REEL_VACCUM_ON)
				&& FALSE == m_plnkTabFeeder[DEF_TABFEEDER2]->IsAbsorbNewReel())
			{
				m_plnkTabFeeder[DEF_TABFEEDER2]->ReleaseNewReel(TRUE);
			}
#	endif
#endif
*/
			break;
		}
	}
}

UINT MTrsAutoManager::threadFunction(LPVOID pParam)
{
	MTrsAutoManager* pThis = (MTrsAutoManager*) pParam;

	TRACE(_T("TrsAutoManager Thread Run\n"));

	while (pThis->m_bThreadLife)
	{
		pThis->threadJob();
		Sleep(10);
	}

	TRACE(_T("TrsAutoManager Thread Stop\n"));
	return 0;
}

UINT MTrsAutoManager::threadRealTimeFunction(LPVOID pParam)
{
	MTrsAutoManager* pThis = (MTrsAutoManager*) pParam;

	TRACE(_T("TrsAutoManager RealTime Thread Run\n"));

	while (pThis->m_bThreadLife)
	{
		pThis->threadRealTimeJob();
		Sleep(10);
	}

	TRACE(_T("TrsAutoManager RealTime Thread Stop\n"));
	return 0;
}

UINT MTrsAutoManager::threadMonitoringFunction(LPVOID pParam)
{
	MTrsAutoManager* pThis = (MTrsAutoManager*) pParam;

	TRACE(_T("TrsAutoManager Monitoring Run\n"));

	while (pThis->m_bThreadLife)
	{
		pThis->threadMonitoringJob();
		Sleep(1000);
	}

	TRACE(_T("TrsAutoManager Mornitoring Stop\n"));
	return 0;
}
//SJ_YYK 150318 Add.
UINT MTrsAutoManager::threadAutoAlignFunction(LPVOID pParam)
{
	MTrsAutoManager* pThis = (MTrsAutoManager*) pParam;
	
	TRACE(_T("TrsAutoManager Thread AutoAlignFunction Run\n"));
	
	while (pThis->m_bThreadLife)
	{
		pThis->threadAutoAlignMonitoringJob();
		Sleep(50);
	}
	
	TRACE(_T("TrsAutoManager Thread AutoAlignFunction Stop\n"));

	return 0;
}
UINT MTrsAutoManager::threadDoorMonitoringFunction(LPVOID pParam)
{
	MTrsAutoManager* pThis = (MTrsAutoManager*) pParam;
	
	TRACE(_T("TrsAutoManager Thread DoorMonitoringFunction Run\n"));
	
	while (pThis->m_bThreadLife)
	{
		pThis->threadDoorMonitoringJob();
		Sleep(50);
	}
	
	TRACE(_T("TrsAutoManager Thread InPosition Stop\n"));

	return 0;
}

void MTrsAutoManager::threadDoorMonitoringJob()
{
	BOOL bAllDoorOpen	= IsAllDoorOpen();
	BOOL bFrontDoorOpen	= IsFrontDoorOpen();
	BOOL bRearDoorOpen	= IsRearDoorOpen();
	int iResult = ERR_TRS_AUTO_MANAGER_SUCCESS;

//@#ifdef DEF_SETUP
//@	return;
//@#endif

	//@130107________________
	if (FALSE == gIOTestMode)
	{
		//170124_KDH Door Open Interface 변경
		/*
		//@전/후 설비 Door상태 신호
		if (m_plnkIO->IsOn(IN_FRONT_DOOR1) || m_plnkIO->IsOn(IN_REAR_DOOR1))
			SetDoorCloseToPrevMCUnload(FALSE);
		else
			SetDoorCloseToPrevMCUnload(TRUE);
		
		if (m_plnkIO->IsOn(IN_FRONT_DOOR6) || m_plnkIO->IsOn(IN_REAR_DOOR6))
			SetDoorCloseToNextMCLoad(FALSE);
		else
			SetDoorCloseToNextMCLoad(TRUE);
		*/
		//20171004 KDW Start
		if(IsDoorOpen_AOC())
		{
			SetDoorCloseToNextMCLoad(FALSE);
			m_plnkMelsecAOCIF->SetUpperEqBit(eReserved5_UpperEqBit, FALSE, DEF_AOC_UNIT_NO_1, TRUE);
		
		}
		else
		{
			SetDoorCloseToNextMCLoad(TRUE);
			m_plnkMelsecAOCIF->SetUpperEqBit(eReserved5_UpperEqBit, TRUE, DEF_AOC_UNIT_NO_1, TRUE);
		}
		//20171004 KDW End
		if (bAllDoorOpen == TRUE)
		{
			SetDoorCloseToPrevMCUnload(FALSE);
			SetDoorCloseToNextMCLoad(FALSE);
			m_plnkMelsecAOCIF->SetUpperEqBit(eReserved5_UpperEqBit, FALSE, DEF_AOC_UNIT_NO_1, TRUE);
		}
		else
		{
			SetDoorCloseToPrevMCUnload(TRUE);
			SetDoorCloseToNextMCLoad(TRUE);
			m_plnkMelsecAOCIF->SetUpperEqBit(eReserved5_UpperEqBit, TRUE, DEF_AOC_UNIT_NO_1, TRUE);
		}
		//___________________
	}

	//@전/후 설비 PanelInterlock 신호
	BOOL bSts1 = FALSE, bSts2 = FALSE, bSts3 = FALSE, bSts4 = FALSE, bSts5 = FALSE, bSts6 = FALSE, bSts7 = FALSE;
#ifdef DEF_GATE_SYSTEM 
	double dSafePos = m_plnkPanelAligner->GetXYTTargetPos(DEF_PANEL_ALIGNER_FIRST_MARK_POS).dX;
	double dCurPos = m_plnkPanelAligner->GetXYTCurrentPos().dX;
	/*
	bSts1 = m_plnkPanelAligner->IsPanelLoadingDetected();
	if (bSts1)
		m_plnkMelsecIF->SetUpperEqBit(eReserved4_UpperEqBit, FALSE);
	else
		m_plnkMelsecIF->SetUpperEqBit(eReserved4_UpperEqBit, TRUE);
	*/
//@	bSts2 = (dCurPos < dSafePos - 1.0) && !m_plnkPanelAligner->IsPanelReleased();
//@	bSts3 = (dCurPos < dSafePos - 1.0) && !m_plnkPanelAligner->IsDownPickUpUnit();
	bSts2 = m_plnkPanelAligner->IsPanelWorkingDetected();
	bSts3 = !m_plnkPanelAligner->IsPanelReleased();
	bSts4 = !m_plnkPanelAligner->IsDownPickUpUnit();
	if (bSts2 || bSts3 || bSts4)
		SetPanelEmptyToPrevMC_In_MyLoading(FALSE);
	else
		SetPanelEmptyToPrevMC_In_MyLoading(TRUE);

	dSafePos= m_plnkPanelTransferOut->GetXTargetPos(DEF_PANEL_TRANSFER_LOAD_POS);
	dCurPos = m_plnkPanelTransferOut->GetXCurrentPos();
	bSts1 = (dCurPos > dSafePos + 1.0) && !m_plnkPanelTransferOut->IsPanelReleased();
	bSts2 = (dCurPos > dSafePos + 1.0) && !m_plnkPanelTransferOut->IsDownPickUpUDCyl();
	if (bSts1 || bSts2)
		SetPanelEmptyToNextMCLoad(FALSE);
	else
		SetPanelEmptyToNextMCLoad(TRUE);

#else
	
	//150328 SJ_YSH 
	/*
	bSts1 = m_plnkPanelTransfer->IsPanelLoadingDetected();
	bSts2 = !m_plnkPanelTransfer->IsPanelReleased();
	bSts3 = !m_plnkPanelTransfer->IsDownPickUpUDCyl();
	*/

	//SJ_YYK 150331 Modify..
	double dSafePos = m_plnkPanelAligner->GetXYTTargetPos(DEF_PANEL_ALIGNER_FIRST_MARK_POS).dX;
	double dCurPos = m_plnkPanelAligner->GetXYTCurrentPos().dX;
	bSts1 = !m_plnkPanelTransfer->IsPanelReleased();//170916 JSH
	bSts2 = (dCurPos < dSafePos - 1.0) && m_plnkPanelAligner->IsPanelWorkingDetected();
	bSts3 = (dCurPos < dSafePos - 1.0) && !m_plnkPanelAligner->IsPanelReleased();
	bSts4 = !m_plnkPanelAligner->IsDownPickUpUnit();	

//170919 JSh.s
#ifdef DEF_USE_TRANSFER_CENTER  
	bSts1 = (bSts1  || m_plnkPanelTransferCenter->IsPanelAbsorbed());
	bSts1 = (bSts1  || MOlbSystemPre.GetTurnHandlerComponent()->IsAbsorbPanel());
#endif
//170919 JSh.e

 	if (bSts1 || bSts2 || bSts3)
 		SetPanelEmptyToPrevMC_In_MyLoading(FALSE);
 	else
 		SetPanelEmptyToPrevMC_In_MyLoading(TRUE);

	if (TRUE == m_plnkPanelAligner->IsPanelAbsorbed())
	{
		bSts4 = TRUE;
	}
	else
	{
		bSts4 = FALSE;
	}

	if (bSts4)
		SetPanelEmptyToPrevMC_In_MyWorking(FALSE);
	else
		SetPanelEmptyToPrevMC_In_MyWorking(TRUE);


	bSts1 = m_plnkPanelAligner->IsPanelWorkingDetected();
	bSts2 = !m_plnkPanelAligner->IsPanelReleased();
	bSts3 = !m_plnkPanelAligner->IsDownPickUpUnit();
	bSts4 = !m_plnkPanelTransferOut->IsPanelReleased();
	bSts5 = !m_plnkPanelTransferOut->IsDownPickUpUDCyl();
	if (bSts1 || bSts2 || bSts3 || bSts4 || bSts5)
		SetPanelEmptyToNextMCLoad(FALSE);
	else
		SetPanelEmptyToNextMCLoad(TRUE);
#endif
	//@______________________

	switch (GetOPMode())
	{
		case MANUAL_MODE:
			//if (TRUE == gIOTestMode)
			//	break;
			//Door가 열린상태에서 닫히면 DoorLock을 자동으로 한다
			/*
			if (m_bAllDoorOpen != bAllDoorOpen)
			{
				if (FALSE == bAllDoorOpen)
				{
					iResult = LockAllDoor();
				}
			}
			*/

			if (m_bFrontDoorOpen != bFrontDoorOpen)
			{
				if (FALSE == bFrontDoorOpen)
				{
					iResult = LockFrontDoor();
				}
			}

			if (m_bRearDoorOpen != bRearDoorOpen)
			{
				if (FALSE == bRearDoorOpen)
				{
					iResult = LockRearDoor();
				}
			}
			break;
		case AUTORUN_MODE:
			switch (GetOPStatus())
			{
			case ERROR_STOP:
				break;
			case STEP_STOP:
				break;
			case START_RUN:
				break;
			case CYCLE_STOP:
				break;
			case RUN:
				break;
			}
#ifndef DEF_SETUP
			if (FALSE == IsFrontKeyAutoMode())
			{
				SetOPStatus(ERROR_STOP);
				PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400134));
			}
			if (FALSE == IsRearKeyAutoMode())
			{
				SetOPStatus(ERROR_STOP);
				PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400135));
			}

			//170123 SJ_YSH
			// 자동운전 중 전후 설비 Door Open 감지 시 설비 정지 하도록.  Setup간 목지훈D 요청 사항
			if(FALSE == IsDoorClose_PrevMCUnload())
			{
				SetOPStatus(ERROR_STOP);
				PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400138));
			}

			if(FALSE == IsDoorClose_NextMCLoad())
			{
				SetOPStatus(ERROR_STOP);
				PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400139));
			}
			//_____________

			//170127 SJ_YSH
			// 자동운전 중 AOC 설비 Door Open 감지 시 설비 정지 하도록.  Setup간 이기환D 요청 사항
			//20171004 KDW 
			//if(FALSE == m_plnkMelsecAOCIF->IsOnUpperEqBit(eReserved5_UpperEqBit))
			if(IsDoorOpen_AOC())
			{
				SetOPStatus(ERROR_STOP);
				PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400552));
			}
			//_____________

#endif
			break;
	}
	m_bFrontDoorOpen = bFrontDoorOpen;
	m_bRearDoorOpen = bRearDoorOpen;
//	m_bAllDoorOpen	= bAllDoorOpen;
}

//SJ_YYK 150318 Add..
void MTrsAutoManager::threadAutoAlignMonitoringJob()
{

	if(m_plnkSystemData->m_bUseAutoAlignSystem == FALSE)
		return;


	int iFlieCount = 0;

	MFileUtil util;
	CFileFind fn;

	CString strDataFolderPath = _T("./AutoAlign");
	CString	strAutoalignDataFileName = _T("./AutoAlign/AlignData.dat");
	CString strPanelInstopDataFileName = _T("./AutoAlign/PanelInStart.dat");

	iFlieCount = util.GetFileCountInDir(strDataFolderPath);

	if(iFlieCount == 0)
		return;

	// Panel In Stop 해제..
	if (fn.FindFile(strPanelInstopDataFileName, 0))
	{
#ifdef DEF_SOURCE_SYSTEM
		if(m_plnkTrsPanelTransfer->IsPanelInStop() == TRUE)
		{
			m_plnkTrsPanelTransfer->SetPanelInStop(FALSE);
		}
#else
		if(m_plnkTrsPanelAligner->IsPanelInStop() == TRUE)
		{
			m_plnkTrsPanelAligner->SetPanelInStop(FALSE);
		}
#endif
		DeleteFile(strPanelInstopDataFileName);
	}

	// Align Data 생성 확인...
	if (!fn.FindFile(strAutoalignDataFileName, 0))
		return;

	CString  strFileName = _T("AlignData.dat");
	CString  strFilePath = _T("./AutoAlign");
	CString	 strSection;
	CString  strItem;
	CString	 strMsg;

#ifdef DEF_SOURCE_SYSTEM

	if(!m_plnkAutoAlignData->ReadSystem())
	{
		strMsg = _T("Auto Align System Reading 중 Manual, Auto인자를 읽지 못하였습니다.");
		SetOperatorCall(TRUE, strMsg);
	}
	else
	{
		if(m_plnkAutoAlignData->m_bAutoAlignSystem == FALSE) // Manual 변경..
			m_bSetAutoAlignPanelInStop = TRUE;
	}
	if(!m_plnkAutoAlignData->ReadSourceAlignData())
	{
		strMsg = _T("Auto Align System Reading 중 Tab Offset Data 를 읽지 못하였습니다.");
		SetOperatorCall(TRUE, strMsg);
	}
	else
	{
		m_bAutoAlignDataUpdate = TRUE;
	}
	DeleteFile(strAutoalignDataFileName);
#else

	if(!m_plnkAutoAlignData->ReadSystem())
	{
		strMsg = _T("Auto Align System Reading 중 Manual, Auto인자를 읽지 못하였습니다.");
		SetOperatorCall(TRUE, strMsg);
	}
	else
	{
		if(m_plnkAutoAlignData->m_bAutoAlignSystem == FALSE) // Manual 변경..
			m_bSetAutoAlignPanelInStop = TRUE;
	}


	if(!m_plnkAutoAlignData->ReadGateAlignData())
	{
		strMsg = _T("Auto Align System Reading 중 Tab Offset Data 를 읽지 못하였습니다.");
		SetOperatorCall(TRUE, strMsg);
	}
	else
	{
		m_bAutoAlignDataUpdate = TRUE;
	}
	DeleteFile(strAutoalignDataFileName);
#endif
}

CString MTrsAutoManager::GetObjectName(int iErrorCode)
{
	CString strObjName;
	CString strErrorCode;

	strErrorCode.Format(_T("%d"), iErrorCode);
	if (strErrorCode.GetLength() != 9)
		return "";
	
	int iComponentCode = _wtoi(strErrorCode.Left(3));
	int iInstanceNo = _wtoi(strErrorCode.Right(3));

	int iResult = m_plnkSystemInfo->GetObjectName(iComponentCode, iInstanceNo, &strObjName);
	if (iResult != ERR_SYSTEMINFO_SUCCESS)
		return "";

	return strObjName;	
}

BOOL MTrsAutoManager::IsPanelEmpty()
{ 
	if (m_bEmptyPanel && !m_bManufacturingEmpty)
	{
		m_bManufacturingEmpty = TRUE;
		m_timerManufacturingEmpty.StartTimer();
	}

	if (!m_bEmptyPanel)
	{
		m_bManufacturingEmpty = FALSE;
		m_timerManufacturingEmpty.StopTimer();
	}

	if (m_timerManufacturingEmpty.MoreThan(5.0))
		return TRUE;
	
	return FALSE;
}

BOOL MTrsAutoManager::IsStepStopSWPressed() //syr..090508
{
	return m_bStepStopPressed;
}

BOOL MTrsAutoManager::IsOperatorCall()		
{ 
	return m_bOperatorCall;	
}

// sesl_jdy void MTrsAutoManager::SetOperatorCall(BOOL bState, CString strReceive, BOOL bBuzzerMode)
void MTrsAutoManager::SetOperatorCall(BOOL bState, CString strReceive, BOOL bBuzzerMode, BOOL bDisplayOpDlg)
{
	CString strMsg;
	strMsg.Format(_T("Operator Call : %d "), bState);
	WriteMonitoringLog(strMsg + strReceive);
	
	m_bOperatorCall = bState;

	if (FALSE == bState)
	{
		m_plnkManageOpPanel->SetBuzzerMode(FALSE);
		if (TRUE == bDisplayOpDlg)
			::SendMessage(m_hAutoViewWnd, WM_DISP_OPCALL_MSG, (WPARAM)(&strReceive), TRUE);
	}
	else
	{
		if (FALSE == bBuzzerMode || TRUE == bBuzzerMode)
			m_plnkManageOpPanel->SetBuzzerMode(bBuzzerMode);
		else
			m_plnkManageOpPanel->SetBuzzerMode(m_plnkSystemData->m_bUseBuzzer);

		// sesl_jdy
		if (TRUE == bDisplayOpDlg)
			::SendMessage(m_hAutoViewWnd, WM_DISP_OPCALL_MSG, (WPARAM)(&strReceive), NULL);
	}
}

void MTrsAutoManager::SetSelectState(int iSelect, int iMode)
{
	ASSERT(iSelect >= 0 && iSelect < DEF_MAX_OP_CALL_SELECT);
	m_iSelectState[iSelect] = iMode;
}

int MTrsAutoManager::GetSelectState(int iSelect)
{
	ASSERT(iSelect >= 0 && iSelect < DEF_MAX_OP_CALL_SELECT);
	return m_iSelectState[iSelect];
}

void MTrsAutoManager::SetMaterialExchange(BOOL bFlag)
{
	m_bMaterialExchange = bFlag;
}

/** 
 * 모든 Process layer의 initialize 상태 확인 
 */
BOOL MTrsAutoManager::isAllInitialized()
{
	BOOL rgbStatus[DEF_MAX_PROCESS_INSTANCE];

	memset(rgbStatus, TRUE, sizeof(rgbStatus));
	int iCnt=0;

	rgbStatus[iCnt++] = m_plnkTrsPanelAligner->IsInitialized();
#ifdef DEF_SOURCE_SYSTEM
	rgbStatus[iCnt++] = m_plnkTrsPanelTransfer->IsInitialized();
#endif
	rgbStatus[iCnt++] = m_plnkTrsPanelTransferOut->IsInitialized();
	
	rgbStatus[iCnt++] = m_plnkTrsTabMounter[DEF_TABMOUNTER1]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsTabMounter[DEF_TABMOUNTER2]->IsInitialized();
#ifdef DEF_SOURCE_SYSTEM
	rgbStatus[iCnt++] = m_plnkTrsTabMounter[DEF_TABMOUNTER3]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsTabMounter[DEF_TABMOUNTER4]->IsInitialized();
#endif

	rgbStatus[iCnt++] = m_plnkTrsRTabMounter[DEF_TABMOUNTER1]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsRTabMounter[DEF_TABMOUNTER2]->IsInitialized();
#ifdef DEF_SOURCE_SYSTEM
	rgbStatus[iCnt++] = m_plnkTrsRTabMounter[DEF_TABMOUNTER3]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsRTabMounter[DEF_TABMOUNTER4]->IsInitialized();
#endif

	rgbStatus[iCnt++] = m_plnkTrsTabCarrier[DEF_TABCARRIER1]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsTabCarrier[DEF_TABCARRIER2]->IsInitialized();
#ifdef DEF_SOURCE_SYSTEM
	rgbStatus[iCnt++] = m_plnkTrsTabCarrier[DEF_TABCARRIER3]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsTabCarrier[DEF_TABCARRIER4]->IsInitialized();
#endif

	rgbStatus[iCnt++] = m_plnkTrsRTabCarrier[DEF_TABCARRIER1]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsRTabCarrier[DEF_TABCARRIER2]->IsInitialized();
#ifdef DEF_SOURCE_SYSTEM
	rgbStatus[iCnt++] = m_plnkTrsRTabCarrier[DEF_TABCARRIER3]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsRTabCarrier[DEF_TABCARRIER4]->IsInitialized();
#endif

	rgbStatus[iCnt++] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_1]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_2]->IsInitialized();
#ifdef DEF_SOURCE_SYSTEM
	rgbStatus[iCnt++] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_3]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_4]->IsInitialized();
#endif

	rgbStatus[iCnt++] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_1]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_2]->IsInitialized();
#ifdef DEF_SOURCE_SYSTEM
	rgbStatus[iCnt++] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_3]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_4]->IsInitialized();
#endif

	rgbStatus[iCnt++] = m_plnkTrsTabFeeder[DEF_TABFEEDER1]->IsInitialized();
	rgbStatus[iCnt++] = m_plnkTrsTabFeeder[DEF_TABFEEDER2]->IsInitialized();

	BOOL isAllInitial = TRUE;
	for (int i = 0; i < DEF_MAX_PROCESS_INSTANCE; i++)
		isAllInitial &= rgbStatus[i];
	return isAllInitial;
}

/** 
 * 모든 Process layer의 initialize 상태 reset
 * @return int : 0 = Success, 그외 Error Code
 */
void MTrsAutoManager::resetAllInitialized()
{
	m_plnkTrsPanelAligner->ResetInitialized();
#ifdef DEF_SOURCE_SYSTEM
	m_plnkTrsPanelTransfer->ResetInitialized();
#endif
	m_plnkTrsPanelTransferOut->ResetInitialized();
	m_plnkTrsTabMounter[DEF_TABMOUNTER1]->ResetInitialized();
	m_plnkTrsTabMounter[DEF_TABMOUNTER2]->ResetInitialized();
#ifdef DEF_SOURCE_SYSTEM
	m_plnkTrsTabMounter[DEF_TABMOUNTER3]->ResetInitialized();
	m_plnkTrsTabMounter[DEF_TABMOUNTER4]->ResetInitialized();
#endif
	m_plnkTrsRTabMounter[DEF_TABMOUNTER1]->ResetInitialized();
	m_plnkTrsRTabMounter[DEF_TABMOUNTER2]->ResetInitialized();
#ifdef DEF_SOURCE_SYSTEM
	m_plnkTrsRTabMounter[DEF_TABMOUNTER3]->ResetInitialized();
	m_plnkTrsRTabMounter[DEF_TABMOUNTER4]->ResetInitialized();
#endif
	m_plnkTrsTabCarrier[DEF_TABCARRIER1]->ResetInitialized();
	m_plnkTrsTabCarrier[DEF_TABCARRIER2]->ResetInitialized();
#ifdef DEF_SOURCE_SYSTEM
	m_plnkTrsTabCarrier[DEF_TABCARRIER3]->ResetInitialized();
	m_plnkTrsTabCarrier[DEF_TABCARRIER4]->ResetInitialized();
#endif
	m_plnkTrsRTabCarrier[DEF_TABCARRIER1]->ResetInitialized();
	m_plnkTrsRTabCarrier[DEF_TABCARRIER2]->ResetInitialized();
#ifdef DEF_SOURCE_SYSTEM
	m_plnkTrsRTabCarrier[DEF_TABCARRIER3]->ResetInitialized();
	m_plnkTrsRTabCarrier[DEF_TABCARRIER4]->ResetInitialized();
#endif
	m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_1]->ResetInitialized();
	m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_2]->ResetInitialized();
#ifdef DEF_SOURCE_SYSTEM
	m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_3]->ResetInitialized();
	m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_4]->ResetInitialized();
#endif
	m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_1]->ResetInitialized();
	m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_2]->ResetInitialized();
#ifdef DEF_SOURCE_SYSTEM
	m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_3]->ResetInitialized();
	m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_4]->ResetInitialized();
#endif
	m_plnkTrsTabFeeder[DEF_TABFEEDER1]->ResetInitialized();
	m_plnkTrsTabFeeder[DEF_TABFEEDER2]->ResetInitialized();

}

/** 
 * 모든 모터의 event 상태를 해제한다.
 * @return int : 0 = Success, 그외 Error Code
 */
int MTrsAutoManager::ResetAllMotorEvent()
{
	for (int i = 0; i < DEF_AXIS_MAX_AXIS; i++)
	{
		if (TRUE == MOlbSystemPre.IsSkipAxis(i))
			continue;

		m_plnkMotion[i]->ClearAxis();
	}

	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

BOOL MTrsAutoManager::WriteMonitoringLogOp(CString strMsg)
{
	if (m_plnkSystemData->m_bLogLevelMonitoring == FALSE)
		return TRUE;

	//KJS NSMC System 생성이 완료되기 전에는 로그 작성하지 않음
	if (TRUE != MOlbSystemPre.m_bSystemInitialized)
		return TRUE;

	::EnterCriticalSection(&m_csMonitoringLogOp);							
	FILE* fsource;
	CFileFind fn;
	CString fname;

	CTime tmCurr = CTime::GetCurrentTime();
	strMsg = tmCurr.Format(_T("[%m/%d-%H:%M:%S]")) + strMsg;
	fname = _T("..\\Log\\MonitoringLogOp") + tmCurr.Format(_T("%y%m")) + _T(".txt");
	
	//LKH_20090130 : Log Unicode Writing
	if ((fsource = _wfopen(fname, _T("ab+,ccs=UNICODE"))) == NULL)
	{
		::LeaveCriticalSection(&m_csMonitoringLogOp);
		return FALSE;
	}
	//현재 발생 로그 내용 기록
	fwprintf(fsource, _T("%s\r\n"), strMsg.GetBuffer());
	fclose(fsource);

	::LeaveCriticalSection(&m_csMonitoringLogOp);

	return TRUE;
}

BOOL MTrsAutoManager::WriteMonitoringLog(CString strMsg)
{
	if (m_plnkSystemData->m_bLogLevelMonitoring == FALSE)
		return TRUE;

	//KJS NSMC System 생성이 완료되기 전에는 로그 작성하지 않음
	if (TRUE != MOlbSystemPre.m_bSystemInitialized)
		return TRUE;
	
	::EnterCriticalSection(&m_csMonitoringLog);

	FILE* fsource;
	CFileFind fn;
	CString fname;
//	WCHAR buf[500];
//	size_t strSize;

	CTime tmCurr = CTime::GetCurrentTime();
	strMsg = tmCurr.Format(_T("[%m/%d-%H:%M:%S]")) + strMsg;
	fname = _T("..\\Log\\MonitoringLog") + tmCurr.Format(_T("%m%d")) + _T(".txt");
	
	//LKH_20090130 : Log Unicode Writing
	if ((fsource = _wfopen(fname, _T("ab+,ccs=UNICODE"))) == NULL)
	{
		//LogDelete
		//Log 파일을 만들지 못 했습니다.
//		MyMessageBox(MY_MESSAGE_BOX, 64004, _T("File Write Error!"), M_ICONERROR);
		::LeaveCriticalSection(&m_csMonitoringLog);
		return FALSE;
	}
	//현재 발생 로그 내용 기록
	fwprintf(fsource, _T("%s\r\n"), strMsg.GetBuffer());
	/*
	wcscpy(buf,strMsg);
	strSize = wcslen(buf);
	fwrite(buf, sizeof(WCHAR), strSize, fsource);
	*/
	fclose(fsource);

	::LeaveCriticalSection(&m_csMonitoringLog);

	return TRUE;
}

CString MTrsAutoManager::getCurrentEquipState()
{
	if (   NULL == m_plnkTrsPanelAligner
#ifdef DEF_SOURCE_SYSTEM
#	ifdef DEF_USE_TRANSFER_CENTER
		|| NULL == m_plnkTrsPanelTransferCenter
#	endif
		|| NULL == m_plnkTrsPanelTransfer
#endif
		|| NULL == m_plnkTrsPanelTransferOut
		|| NULL == m_plnkTrsTabMounter[DEF_TABMOUNTER1]
		|| NULL == m_plnkTrsTabMounter[DEF_TABMOUNTER2]
#ifdef DEF_SOURCE_SYSTEM
		|| NULL == m_plnkTrsTabMounter[DEF_TABMOUNTER3]
		|| NULL == m_plnkTrsTabMounter[DEF_TABMOUNTER4]
#endif
		|| NULL == m_plnkTrsRTabMounter[DEF_TABMOUNTER1]
		|| NULL == m_plnkTrsRTabMounter[DEF_TABMOUNTER2]
#ifdef DEF_SOURCE_SYSTEM
		|| NULL == m_plnkTrsRTabMounter[DEF_TABMOUNTER3]
		|| NULL == m_plnkTrsRTabMounter[DEF_TABMOUNTER4]
#endif
		|| NULL == m_plnkTrsTabCarrier[DEF_TABCARRIER1]
		|| NULL == m_plnkTrsTabCarrier[DEF_TABCARRIER2]
#ifdef DEF_SOURCE_SYSTEM
		|| NULL == m_plnkTrsTabCarrier[DEF_TABCARRIER3]
		|| NULL == m_plnkTrsTabCarrier[DEF_TABCARRIER4]
#endif
		|| NULL == m_plnkTrsRTabCarrier[DEF_TABCARRIER1]
		|| NULL == m_plnkTrsRTabCarrier[DEF_TABCARRIER2]
#ifdef DEF_SOURCE_SYSTEM
		|| NULL == m_plnkTrsRTabCarrier[DEF_TABCARRIER3]
		|| NULL == m_plnkTrsRTabCarrier[DEF_TABCARRIER4]
#endif
		|| NULL == m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_1]
		|| NULL == m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_2]
#ifdef DEF_SOURCE_SYSTEM
		|| NULL == m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_3]
		|| NULL == m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_4]
#endif
		|| NULL == m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_1]
		|| NULL == m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_2]
#ifdef DEF_SOURCE_SYSTEM
		|| NULL == m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_3]
		|| NULL == m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_4]
#endif
		|| NULL == m_plnkTrsTabFeeder[DEF_TABFEEDER1]
		|| NULL == m_plnkTrsTabFeeder[DEF_TABFEEDER2]
#ifdef DEF_USE_TURN_HANDLER
		|| NULL == m_plnkTrsTHandler
#endif
		)
	{
		return "Not Initialized.";
	}

	CString strMonitoringLog;
	strMonitoringLog.Format(
#ifdef DEF_SOURCE_SYSTEM
		_T("state:%d step:PA(%d)PTC(%d)PTI(%d)PTO(%d) F[TM(%d %d %d %d)TC(%d %d %d %d)IC(%d %d %d %d)TF(%d)] R[TM(%d %d %d %d)TC(%d %d %d %d)IC(%d %d %d %d)TF(%d)]TH(%d)"), 
#else
		_T("state:%d step:PA(%d)PTO(%d) F[TM(%d %d)TC(%d %d)IC(%d %d)TF(%d)] R[TM(%d %d)TC(%d %d)IC(%d %d)TF(%d)]"), 
#endif
			GetOPStatus(),
#ifdef DEF_SOURCE_SYSTEM
			m_plnkTrsPanelAligner->GetStep(),
#	ifdef DEF_USE_TRANSFER_CENTER
			m_plnkTrsPanelTransferCenter->GetStep(),
#	else
			FALSE,
#	endif
			m_plnkTrsPanelTransfer->GetStep(),
			m_plnkTrsPanelTransferOut->GetStep(),

			m_plnkTrsTabMounter[DEF_TABMOUNTER1]->GetStep(),
			m_plnkTrsTabMounter[DEF_TABMOUNTER2]->GetStep(),
			m_plnkTrsTabMounter[DEF_TABMOUNTER3]->GetStep(),
			m_plnkTrsTabMounter[DEF_TABMOUNTER4]->GetStep(),
			
			m_plnkTrsTabCarrier[DEF_TABCARRIER1]->GetStep(),
			m_plnkTrsTabCarrier[DEF_TABCARRIER2]->GetStep(),
			m_plnkTrsTabCarrier[DEF_TABCARRIER3]->GetStep(),
			m_plnkTrsTabCarrier[DEF_TABCARRIER4]->GetStep(),
			
			m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_1]->GetStep(),
			m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_2]->GetStep(),
			m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_3]->GetStep(),
			m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_4]->GetStep(),
			
			m_plnkTrsTabFeeder[DEF_TABFEEDER1]->GetStep(),
			
			m_plnkTrsRTabMounter[DEF_TABMOUNTER1]->GetStep(),
			m_plnkTrsRTabMounter[DEF_TABMOUNTER2]->GetStep(),
			m_plnkTrsRTabMounter[DEF_TABMOUNTER3]->GetStep(),
			m_plnkTrsRTabMounter[DEF_TABMOUNTER4]->GetStep(),
			
			m_plnkTrsRTabCarrier[DEF_TABCARRIER1]->GetStep(),
			m_plnkTrsRTabCarrier[DEF_TABCARRIER2]->GetStep(),
			m_plnkTrsRTabCarrier[DEF_TABCARRIER3]->GetStep(),
			m_plnkTrsRTabCarrier[DEF_TABCARRIER4]->GetStep(),
			
			m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_1]->GetStep(),
			m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_2]->GetStep(),
			m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_3]->GetStep(),
			m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_4]->GetStep(),
			m_plnkTrsTabFeeder[DEF_TABFEEDER2]->GetStep(),
#	ifdef DEF_USE_TURN_HANDLER			
			m_plnkTrsTHandler->GetStep()//SJ_YYK 161104 Add.
#	else
			FALSE
#	endif
#else
			m_plnkTrsPanelAligner->GetStep(),
			m_plnkTrsPanelTransferOut->GetStep(),
			
			m_plnkTrsTabMounter[DEF_TABMOUNTER1]->GetStep(),
			m_plnkTrsTabMounter[DEF_TABMOUNTER2]->GetStep(),
			
			m_plnkTrsTabCarrier[DEF_TABCARRIER1]->GetStep(),
			m_plnkTrsTabCarrier[DEF_TABCARRIER2]->GetStep(),
			
			m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_1]->GetStep(),
			m_plnkTrsInspectionCamera[DEF_INSPECTION_CARRIER_2]->GetStep(),
			
			m_plnkTrsTabFeeder[DEF_TABFEEDER1]->GetStep(),
			
			m_plnkTrsRTabMounter[DEF_TABMOUNTER1]->GetStep(),
			m_plnkTrsRTabMounter[DEF_TABMOUNTER2]->GetStep(),
			
			m_plnkTrsRTabCarrier[DEF_TABCARRIER1]->GetStep(),
			m_plnkTrsRTabCarrier[DEF_TABCARRIER2]->GetStep(),

			m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_1]->GetStep(),
			m_plnkTrsRInspectionCamera[DEF_INSPECTION_CARRIER_2]->GetStep(),

			m_plnkTrsTabFeeder[DEF_TABFEEDER2]->GetStep()
#endif
		);
	return strMonitoringLog;
}

/** Error Report Code 인지 확인 한다. */
BOOL MTrsAutoManager::isErrorReportCode(int nErrorCode)
{
	/** 설비별 Error Report 하지 말아야 하는 Code를 case 에 추가 한다. */
	switch (nErrorCode)
	{
	case 206001: // CodeSpec Type Error [RFID]
	case 206002: // Data Code Type Error
	case 206003: // UnKnown Command Error
	case 206004: // Null Data Error
	case 206007: // Data Write Time Out
	case 206008: // Wrong Data Length

	case 300003: // 문이 열린 상태 입니다. 
/*
	case 310017: // Tab IC Cutting 정도가 틀어졌습니다. (Tab Mark 위치는 -1 ~ +1 사이에 있어야 함) [Feeder#1]
	case 310117: // Tab IC Cutting 정도가 틀어졌습니다. (Tab Mark 위치는 -1 ~ +1 사이에 있어야 함) [Feeder#2]
	case 310018: // Tab IC 1번 마크 위치 편차가 제한값 이상입니다. (Tab IC Cutting 정도 불량, 금형상태 확인, Reel 상태 확인) [Feeder#1]
	case 310118: // Tab IC 1번 마크 위치 편차가 제한값 이상입니다. (Tab IC Cutting 정도 불량, 금형상태 확인, Reel 상태 확인) [Feeder#2]
	case 310019: // Tab IC 2번 마크 위치 편차가 제한값 이상입니다. (Tab IC Cutting 정도 불량, 금형상태 확인, Reel 상태 확인) [Feeder#1]
	case 310119: // Tab IC 2번 마크 위치 편차가 제한값 이상입니다. (Tab IC Cutting 정도 불량, 금형상태 확인, Reel 상태 확인) [Feeder#2]
*/
		// hongju 수정... 작업자 문제이므로 L/C 보고 할 필요 없음.
	case 315014: // 회수 장치 펴짐이 감지되지 않습니다.
	case 400030: // 자동운전 중 비상정지 스위치가 눌려졌습니다.
	case 400031: // 자동운전 중 Door Open이 감지 되었습니다.
	case 400134: // 자동운전중 Front Door Key가 Auto상태가 아닙니다.
	case 400135: // 자동운전중 Rear Door Key가 Auto상태가 아닙니다.
	case 400040: // 전설비와의 Melsec 통신이 연결되지 않았으므로 모든 모터를 정지합니다.
	case 400041: // 전설비가 E-Stop 상태이므로 모든 모터를 정지합니다. 
	case 400043: // 후설비와의 Melsec 통신이 연결되지 않았으므로 모든 모터를 정지합니다.
	case 400044: // 후설비가 E-Stop 상태이므로 모든 모터를 정지합니다. 
	case 427015: // Panel에 이전 설비로부터 넘겨받은 ID Data가 없습니다. Load Conveyor 로부터 Panel 을 제거해 주세요.
//090913 탕정2호기 수정 
	case 315001: // TabIC 를 모두 사용했습니다.
	case 315007: // 금형 사용 제한 회수를 초과하였습니다. (Regrinding 후 최대 사용횟수 초과)
	case 315012: // 금형 사용 제한 횟수를 초과하였습니다. (Zig 최대 사용횟수 초과)
	case 315015: // New Reel 공급장치에 Reel이 없습니다.
	case 315016: // New Reel Vaccum이 On이 아닙니다.
	case 415002: // 현재 Feeder는 타발을 할 수 없는 상태입니다. Reel을 제거하고 새 Reel을 공급해주세요
	case 415003: // 현재 금형은 타발을 할 수 없는 상태입니다. 금형을 제거하고 새 금형을 공급해주세요
	case 427000: // 이전 설비로부터 Panel을 넘겨받는 중 30초 동안 감속센서가 감지되지 않았습니다.
	case 428005: // 다음 설비로 Panel을 넘겨주던 중 30초 동안 정지센서에 Panel이 계속 감지됩니다.
	case 400090: // 현재 생산계획이 비어 있습니다. 생산계획 요청후 다시 시작하세요.
	case 400091: // 현재 자재 정보가 비어 있습니다. 자재 정보 요청후 다시 시작하세요.
	case 400092: // 현재 등록된 자재 정보중 MCode가 일치하는 자재가 없습니다. 사용할수 없는 자재입니다.
	case 315023: // 현재 Tab IC 갯수가 설정치를 초과하였습니다. 자재 정보를 확인하여 주세요.
		return FALSE;

	default:
		break;
	}

	return TRUE;
}

void MTrsAutoManager::SetDisplayErrorImage(BOOL bState)
{
	m_bDisplayErrorImage = bState;
}

BOOL MTrsAutoManager::IsDisplayErrorImage()
{
	return (GetOPMode() == MANUAL_MODE) ? FALSE : m_bDisplayErrorImage;
}

void MTrsAutoManager::ManageGlassData(EPanelEvent eEventType, int iUnitID)
{
	// Doolin kwangilshin 2017. 09. 15.
	//
// 	if (m_plnkSystemData->m_eRunMode == DRY_RUN_MODE)
// 		return;
	//


	//20111028 SJ_HJG
	CString strLogMsg;

	switch (eEventType)
	{
	case ePanelNothing:

		if (m_plnkSystemData->m_eRunMode != DRY_RUN_MODE)
		{
		}

		break;

	case ePanelRemove:	//Scrap

		// Doolin kwangilshin 2017. 09. 15.
		//
		m_plnkProductInfoData->m_nPanelScrapQty++;
		::PostMessage(GetAutoViewHandle(), WM_DISP_PANEL_SCRAP_QTY, NULL, NULL);
		// End.

		if (m_plnkSystemData->m_eRunMode != DRY_RUN_MODE)
		{
			m_plnkLCNet->PanelTransferReport(ePanelRemove, (MPanel*)m_pGlassData[iUnitID]);
		}

		m_pGlassData[iUnitID]->ResetData();

		break;

	case ePanelUnScrap:	//Unscrap

		if (m_plnkSystemData->m_eRunMode != DRY_RUN_MODE)
		{
			m_plnkLCNet->PanelTransferReport(ePanelUnScrap, (MPanel*)m_pGlassData[iUnitID]);
		}

		break;

	case ePanelIn:

		// Doolin kwangilshin 2017. 09. 15.
		//
#ifdef DEF_USE_TRANSFER_CENTER  //170919 JSh
		if (iUnitID == DEF_PANEL_TRANSFER_CENTER_PANEL)
#else
		if (iUnitID == DEF_PANEL_TRANSFER_PANEL)
#endif
		{
			if (m_pGlassData[iUnitID]->m_strHPanelID.IsEmpty())
			{
				m_plnkProductInfoData->m_nPanelInputQty++;
				::PostMessage(GetAutoViewHandle(), WM_DISP_PANEL_IN_QTY, NULL, NULL);

				if (m_plnkSystemData->m_eRunMode == DRY_RUN_MODE)	
				{
					m_pGlassData[iUnitID]->ResetData();
					m_pGlassData[iUnitID]->m_strHPanelID.Format(_T("%s_%03d"), m_plnkSystemData->m_strModelFileName, m_plnkProductInfoData->m_nPanelInputQty);
				}
			}
		}
		// End.

		if (m_plnkSystemData->m_eRunMode != DRY_RUN_MODE)
		{
			m_pGlassData[iUnitID]->ResetData();
			m_plnkMelsecIF->GetGlassData((MToLowerEqs*)m_pGlassData[iUnitID]);
			m_plnkLCNet->PanelTransferReport(ePanelIn, (MPanel*)m_pGlassData[iUnitID]);
			
			//20111028 SJ_HJG
			strLogMsg.Format(_T("[ Panel IN  ] H: %s , E: %s"),m_pGlassData[iUnitID]->m_strHPanelID,m_pGlassData[iUnitID]->m_strEPanelID);
			WritePanelIDLog(strLogMsg);
		}

		break;

	case ePanelOut:

		// Doolin kwangilshin 2017. 09. 15.
		//
		if (iUnitID == DEF_PANEL_TRANSFER_OUT_PANEL)
		{
			m_plnkProductInfoData->m_iProductCount++;
			::PostMessage(GetAutoViewHandle(), WM_DISP_PRODUCT_QTY, NULL, NULL);
		}
		// End.

		if (m_plnkSystemData->m_eRunMode != DRY_RUN_MODE)
		{
			//20111028 SJ_HJG
			strLogMsg.Format(_T("[ Panel OUT ] H: %s , E: %s"),m_pGlassData[iUnitID]->m_strHPanelID,m_pGlassData[iUnitID]->m_strEPanelID);
			WritePanelIDLog(strLogMsg);
			//________________________

			m_plnkLCNet->PanelTransferReport(ePanelOut, (MPanel*)m_pGlassData[iUnitID]);
		}

		m_pGlassData[iUnitID]->ResetData();

		break;
	case ePanelVcrRead:
		/* FALL THROUGH */
	
	case ePanelBcrRead:

		if (m_plnkSystemData->m_eRunMode != DRY_RUN_MODE)
		{
		}

		break;

	default:
		break;
	}
	
	//SJ_PJC 20170123
	::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_TRANSFER_CENTER_PANEL, NULL);
	::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_THANDLER_PANEL, NULL);
	//_______________
#ifdef DEF_SOURCE_SYSTEM
	::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_TRANSFER_PANEL, NULL);
#endif
	::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_ALIGNER_PANEL, NULL);
	::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_TRANSFER_OUT_PANEL, NULL);
}

void MTrsAutoManager::TransferGlassData(int iPrevUnitID, int iNextUnitID)
{
	*m_pGlassData[iNextUnitID] = *m_pGlassData[iPrevUnitID];
	m_pGlassData[iPrevUnitID]->ResetData();
	m_plnkLCNet->PanelIdTransfer(iPrevUnitID+1, iNextUnitID+1, m_pGlassData[iNextUnitID]->m_strEPanelID);

	switch (iPrevUnitID)
	{
		/*/
	case DEF_PANEL_TRANSFER_CENTER_PANEL:
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_TRANSFER_CENTER_PANEL, NULL);// 2009.04.06 SESL_CYJ
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_TRANSFER_PANEL, NULL);
		break;
		/*/
#ifdef DEF_SOURCE_SYSTEM
	case DEF_THANDLER_PANEL:
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_THANDLER_PANEL, NULL);
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_TRANSFER_PANEL, NULL);
		break;


	case DEF_PANEL_TRANSFER_PANEL:
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_TRANSFER_PANEL, NULL);// 2009.04.06 SESL_CYJ
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_ALIGNER_PANEL, NULL);
		break;
#endif
	case DEF_PANEL_ALIGNER_PANEL:
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_ALIGNER_PANEL, NULL);// 2009.04.06 SESL_CYJ
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_TRANSFER_OUT_PANEL, NULL);
		break;
//	case DEF_PANEL_TRANSFER_OUT_PANEL:
//		break;
	default:
//		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_TRANSFER_CENTER_PANEL, NULL);// 2009.04.06 SESL_CYJ
#ifdef DEF_SOURCE_SYSTEM
		//SJ_PJC 20170123
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_TRANSFER_CENTER_PANEL, NULL);
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_THANDLER_PANEL, NULL);
		//_______________
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_TRANSFER_PANEL, NULL);
#endif
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_ALIGNER_PANEL, NULL);
		::SendMessage(m_hAutoViewWnd, WM_DISP_PANEL_ID, (WPARAM)DEF_PANEL_TRANSFER_OUT_PANEL, NULL);
	}
}

void MTrsAutoManager::AssignGlassData(int iUnitID)
{
	if (m_plnkSystemData->m_eRunMode == DRY_RUN_MODE)
		return ;

	m_plnkMelsecIF->SetGlassData((MToLowerEqs*)m_pGlassData[iUnitID]);
}



//121204.kms________________________
//
void MTrsAutoManager::AssignPassData(int iUnitID)
{
	if (m_plnkSystemData->m_eRunMode == DRY_RUN_MODE)
		return ;

	//@130117.KKY________
//@	m_plnkMelsecIF->SetComment_LowerEq(_T("OS"), m_plnkMelsecIF->m_nCurLocal);
//@	m_plnkMelsecIF->SetGlassData((MToLowerEqs*)m_pGlassData[iUnitID]);
	ASSERT(iUnitID >= 0 && iUnitID < DEF_MAX_PANEL_UNIT);
	m_pGlassData[iUnitID]->m_strComment = _T("OS");
	//@__________________
}

void MTrsAutoManager::ResetPassData(int iUnitID)
{
	if (m_plnkSystemData->m_eRunMode == DRY_RUN_MODE)
		return ;
	ASSERT(iUnitID >= 0 && iUnitID < DEF_MAX_PANEL_UNIT);
	m_pGlassData[iUnitID]->m_strComment = _T(" ");
}

BOOL MTrsAutoManager::GetAssignPassData(int iUnitID)
{
	if (m_plnkSystemData->m_eRunMode == DRY_RUN_MODE)
		return FALSE;

	ASSERT(iUnitID >= 0 && iUnitID < DEF_MAX_PANEL_UNIT);

	if(m_pGlassData[iUnitID]->m_strComment == _T("OS"))
		return TRUE;
	else
		return FALSE;
}
//___________________________________


CString MTrsAutoManager::GetGlassID(int iUnitID)
{
	if (m_plnkSystemData->m_eRunMode == DRY_RUN_MODE)
		return "DRY_RUN";
	else
		return m_pGlassData[iUnitID]->m_strEPanelID;
}

int MTrsAutoManager::CheckPanelValidation(int iUnitNo)
{
	//SJ_YYK 111004 Modify...
	MGlassDatas pRecvGlassData ;
	//pRecvGlassData = new MGlassDatas;
	m_plnkMelsecIF->GetGlassData((MToLowerEqs*)(&pRecvGlassData));
	
	if (pRecvGlassData.m_strEPanelID.IsEmpty()
		|| pRecvGlassData.m_strBatchID.IsEmpty()
		|| pRecvGlassData.m_strDeviceID.IsEmpty())
	{
		return ERR_NO_PANEL_DATA;
	}

	CString strCurrentPanelID = pRecvGlassData.m_strEPanelID;
	CString strCurrentBatch = pRecvGlassData.m_strBatchID;
	CString strCurrentDevice = pRecvGlassData.m_strDeviceID;

	if (strCurrentPanelID.GetLength() < 2)
		return ERR_NO_PANELID_DATA;
	if (strCurrentBatch.GetLength() < 2)
		return ERR_NO_BATCHID_DATA;
	if (strCurrentDevice.GetLength() < 2)
		return ERR_NO_DEVICEID_DATA;

	CString strOldPanelID;
	int iIndex;
	int iCurrentIndex = m_plnkProductInfoData->GetCurrentQueueIndex();
	for (int i = 0; i < 5; i++)
	{
		iIndex = iCurrentIndex - i - 1;
		if (iIndex < 0)
			iIndex += DEF_MAX_QUEUE_SIZE;
		
		strOldPanelID = m_plnkProductInfoData->GetPanelInfo(iIndex)->m_strPanelID;

		if (strCurrentPanelID == strOldPanelID)
			return ERR_SAME_PANELID_IN_LAST_5TIME;
	}

	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}


int MTrsAutoManager::CheckPanelValidationItem(int iUnitNo)
{
	//110701.kms______________________
	//Panel Validation 추가
	// ( Receive Panel Data ) 와 ( Current, Complete1 Data ) 과 비교
	//SJ_YYK 111004 Modify..

	MGlassDatas pRecvGlassData ;
	//pRecvGlassData = new MGlassDatas;
	m_plnkMelsecIF->GetGlassData((MToLowerEqs*)(&pRecvGlassData));

	if(m_plnkSystemData->m_bValidationCheckSelect[0])//m_strHPanelID
	{
		if(pRecvGlassData.m_strHPanelID == _T(""))
			return ERR_HPANELID;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[1])//m_strEPanelID
	{
		if(pRecvGlassData.m_strEPanelID == _T(""))
			return ERR_EPANELID;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[2])//m_strBatchID
	{
		if(pRecvGlassData.m_strBatchID == _T(""))
			return ERR_BATCHID;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[3])//m_strProdType
	{
		if(pRecvGlassData.m_strProdType == _T(""))
			return ERR_PRODTYPE;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[4])//m_strProdKind
	{
		if(pRecvGlassData.m_strProdKind == _T(""))
			return ERR_PRODKIND;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[5])//m_strDeviceID
	{
		if(pRecvGlassData.m_strDeviceID == _T(""))
			return ERR_DEVICEID;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[6])//m_strStepID
	{
		if(pRecvGlassData.m_strStepID == _T(""))
			return ERR_STEPID;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[7])//m_strPPID
	{
		if(pRecvGlassData.m_strPPID == _T(""))
			return ERR_PPID;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[8])//m_strThickness
	{
		if(pRecvGlassData.m_strThickness == _T(""))
			return ERR_THICKNESS;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[9])//m_strInsFlag
	{
		if(pRecvGlassData.m_strInsFlag == _T(""))
			return ERR_INSFLAG;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[10])//m_strPanelSize
	{
		if(pRecvGlassData.m_strPanelSize == _T(""))
			return ERR_PANELSIZE;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[11])//m_strPanelPosition
	{
		if(pRecvGlassData.m_strPanelPosition == _T(""))
			return ERR_PANELPOSITION;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[12])//m_strCount1
	{
		if(pRecvGlassData.m_strCount1 == _T(""))
			return ERR_COUNT1;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[13])//m_strCount2
	{
		if(pRecvGlassData.m_strCount2 == _T(""))
			return ERR_COUNT2;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[14])//m_strGrade
	{
		if(pRecvGlassData.m_strGrade == _T(""))
			return ERR_GRADE;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[15])//m_strComment
	{
		if(pRecvGlassData.m_strComment == _T(""))
			return ERR_COMMENT;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[16])//m_strCompSize
	{
		if(pRecvGlassData.m_strCompSize == _T(""))
			return ERR_COMPSIZE;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[17])//m_strReadingFlag
	{
		if(pRecvGlassData.m_strReadingFlag == _T(""))
			return ERR_READINGFLAG;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[18])//m_strPanelState
	{
		if(pRecvGlassData.m_strPanelState == _T(""))
			return ERR_PANELSTATE;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[19])//m_strJudgement
	{
		if(pRecvGlassData.m_strJudgement == _T(""))
			return ERR_JUDGEMENT;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[20])//m_strCode
	{
		if(pRecvGlassData.m_strCode == _T(""))
			return ERR_CODE;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[21])//m_strRunLine
	{
		if(pRecvGlassData.m_strRunLine == _T(""))
			return ERR_RUNLINE;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[22])//m_strUniqueId
	{
		if(pRecvGlassData.m_strUniqueId == _T(""))
			return ERR_UNIQUEID;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[23])//m_strPairHPanelID
	{
		if(pRecvGlassData.m_strPairHPanelID == _T(""))
			return ERR_PAIRHPANELID;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[24])//m_strPairEPanelID
	{
		if(pRecvGlassData.m_strPairEPanelID == _T(""))
			return ERR_PAIREPANELID;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[25])//m_strPairGrade
	{
		if(pRecvGlassData.m_strPairGrade == _T(""))
			return ERR_PAIRGRADE;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[26])//m_strPairUniqueId
	{
		if(pRecvGlassData.m_strPanelSize == _T(""))
			return ERR_PAIRUNIQUEID;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[27])//m_strFlowRecipe
	{
		if(pRecvGlassData.m_strFlowRecipe == _T(""))
			return ERR_FLOWRECIPE;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[28])//m_strReserved0
	{
		if(pRecvGlassData.m_strReserved0 == _T(""))
			return ERR_RESERVED0;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[29])//m_strBitsSignals
	{
		if(pRecvGlassData.m_strBitsSignals == _T(""))
			return ERR_BITSSIGNALS;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[30])//m_strReferData
	{
		if(pRecvGlassData.m_strReferData == _T(""))
			return ERR_REFERDATA;
	}
	if(m_plnkSystemData->m_bValidationCheckSelect[31])//NoUse
	{
//		if(m_pGlassData[iUnitNo]->m_strPanelSize == _T(""))
//			return ERR_BATCHID;
	}
	//________________________________

	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}



/* selsk_jdy TrsPanelAligner 에서 처리.
void MTrsAutoManager::StartEQTactTimer()
{
	m_dEQTactTime = 0.0;

	if (FALSE == m_EQTactTimer.IsTimerStarted())
		m_EQTactTimer.StartTimer();
}

void MTrsAutoManager::StopEQTactTimer()
{
	m_dEQTactTime = m_EQTactTimer.GetElapseTime();
	m_EQTactTimer.StopTimer();
}

double MTrsAutoManager::GetEQTactTime()
{
	return m_dEQTactTime;
}
*/

int MTrsAutoManager::checkHeaterAlarm()
{
	if (FALSE == m_plnkSystemData->m_bUseHeaterAlarm)
		return ERR_TRS_AUTO_MANAGER_SUCCESS;

#if (defined SIMULATION || defined DEF_SETUP)
	return ERR_TRS_AUTO_MANAGER_SUCCESS;
#endif

	if (TRUE == m_plnkIO->IsOff(IN_OVER_HEAT_DETECT_80))
		return generateErrorCode(400046); // 400050 = Over Heat 감지

	if (TRUE == m_plnkIO->IsOff(IN_OVER_HEAT_DETECT_60))
		// 400050 = Over Heat 감지.
		return generateErrorCode(400047);

	if (TRUE == m_plnkIO->IsOff(IN_FRONT_LOCAL_OVERHEAT))
		// 400050 = Over Heat 감지.
		return generateErrorCode(400048);

	/*/
	if (TRUE == m_plnkIO->IsOff(IN_C_BOX_LIGHT_ON))
	{
		SetErrorLevel(_T("AUTO MANAGER check Heater Alarm"), 0, __FILE__, __LINE__);
		// 400050 = Over Heat 감지.
		return generateErrorCode(400075);
	}
	/*/

//20171009 KDW Start
// 	//if (TRUE == m_plnkIO->IsOn(IN_C_BOX_VENT_FAN))
// 	if (TRUE == m_plnkIO->IsOff(IN_C_BOX_VENT_FAN))
// 	{
// 		SetErrorLevel(_T("AUTO MANAGER check Heater Alarm"), 0, __FILE__, __LINE__);
// 		// 400050 = Over Heat 감지.
// 		return generateErrorCode(400076);
// 	}
// 
// 	//if (TRUE == m_plnkIO->IsOn(IN_C_BOX_INHALATION_FAN))
// 	// Doolin kwangilshin 2017. 09. 03.
// // 	if (TRUE == m_plnkIO->IsOff(IN_C_BOX_INHALATION_FAN))
// // 	{
// // 		SetErrorLevel(_T("AUTO MANAGER check Heater Alarm"), 0, __FILE__, __LINE__);
// // 		// 400050 = Over Heat 감지.
// // 		return generateErrorCode(400077);
// // 	}
// 
// 	//if (TRUE == m_plnkIO->IsOn(IN_C_BOX_SSR_VENT_FAN))
// 	if (TRUE == m_plnkIO->IsOff(IN_C_BOX_SSR_VENT_FAN))
// 	{
// 		SetErrorLevel(_T("AUTO MANAGER check Heater Alarm"), 0, __FILE__, __LINE__);
// 		// 400050 = Over Heat 감지.
// 		return generateErrorCode(400078);
// 	}
// 
// 	//if (TRUE == m_plnkIO->IsOn(IN_C_BOX_SSR_INHALATION_FAN))
// 	if (TRUE == m_plnkIO->IsOff(IN_C_BOX_SSR_INHALATION_FAN))
// 	{
// 		SetErrorLevel(_T("AUTO MANAGER check Heater Alarm"), 0, __FILE__, __LINE__);
// 		// 400050 = Over Heat 감지.
// 		return generateErrorCode(400079);
// 	}
//20171009 KDW END

	//if (TRUE == m_plnkIO->IsOn(IN_C_BOX_PANEL_TEMP))
	if (TRUE == m_plnkIO->IsOff(IN_C_BOX_PANEL_TEMP))
		// 400050 = Over Heat 감지.
		return generateErrorCode(400084);

	//20171009 KDW Start
	if (TRUE == m_plnkIO->IsOn(IN_C_BOX_GAS_DETECT))
		// 400083 = C-Box gas 검출기가 감지 되었습니다.
		return generateErrorCode(400083);
	//20171009 KDW End

#ifdef DEF_SOURCE_SYSTEM
	int rgiThermostatCheckStartAddress[DEF_MAX_WORKER_PER_GROUP] = { IN_TABMOUNTER1_THERMOSTAT_01, IN_TABMOUNTER1_THERMOSTAT_05};
#else
	int rgiThermostatCheckStartAddress[DEF_MAX_WORKER_PER_GROUP] = { IN_TABMOUNTER1_THERMOSTAT_01, IN_TABMOUNTER1_THERMOSTAT_03};
#endif
	for (int i = 0; i < DEF_MAX_WORKER_GROUP; i++)
	{	 
		if(i == DEF_REAR_GROUP)
			continue;

		for (int j = 0; j < DEF_MAX_WORKER_PER_GROUP; j++)
		{
			//20110816 SJ_HJG 김지룡 주임 요청 B 접점으로 변경
			//if (TRUE == m_plnkIO->IsOn(rgiThermostatCheckStartAddress[i] + j))	// A 접점.
			if (TRUE == m_plnkIO->IsOff(rgiThermostatCheckStartAddress[i] + j))	// B 접점.
			{
				switch (i * DEF_MAX_WORKER_PER_GROUP + j)
				{
				case 0:
					return generateErrorCode(400051);	// 400051 = 온도 컨트롤러1 과열 감지.
				case 1:
					return generateErrorCode(400052);	// 400052 = 온도 컨트롤러2 과열 감지.
				case 2:
					return generateErrorCode(400053);	// 400053 = 온도 컨트롤러3 과열 감지.
				case 3:
					return generateErrorCode(400054);	// 400054 = 온도 컨트롤러4 과열 감지.

				case 4:
					return generateErrorCode(400055);	// 400055 = 온도 컨트롤러5 과열 감지.
 				case 5:
					return generateErrorCode(400056);	// 400056 = 온도 컨트롤러6 과열 감지.
				case 6:
					return generateErrorCode(400057);	// 400057 = 온도 컨트롤러7 과열 감지.
				case 7:
					return generateErrorCode(400058);	// 400058 = 온도 컨트롤러8 과열 감지.
				case 8:
					return generateErrorCode(400059);	// 400059 = 온도 컨트롤러9 과열 감지.
				case 9:
					return generateErrorCode(400060);	// 400060 = 온도 컨트롤러10 과열 감지.
				case 10:
					return generateErrorCode(400061);	// 400061 = 온도 컨트롤러11 과열 감지.
				case 11:
					return generateErrorCode(400062);	// 400062 = 온도 컨트롤러12 과열 감지.
				default:
					break;
				}
			}
		}
	}

#ifdef DEF_SOURCE_SYSTEM
	int rgiWireCutCheckStartAddress[DEF_MAX_GROUP] = { IN_TABMOUNTER1_HEATER_WIRE_CUT_01, IN_TABMOUNTER1_HEATER_WIRE_CUT_05};
#else
	int rgiWireCutCheckStartAddress[DEF_MAX_GROUP] = { IN_TABMOUNTER1_HEATER_WIRE_CUT_01, IN_TABMOUNTER1_HEATER_WIRE_CUT_03};
#endif
	for (int i = 0; i < DEF_MAX_WORKER_GROUP; i++)
	{	 
		if(i == DEF_REAR_GROUP)
			continue;
		for (int j = 0; j < DEF_MAX_WORKER_PER_GROUP; j++)
		{
			if (TRUE == m_plnkIO->IsOn(rgiWireCutCheckStartAddress[i] + j))	// B 접점.
			{
				switch (i * DEF_MAX_WORKER_PER_GROUP + j)
				{
				case 0:
					return generateErrorCode(400063);	// 400063 = 온도 컨트롤러1 단선 감지.
				case 1:
					return generateErrorCode(400064);	// 400064 = 온도 컨트롤러2 단선 감지.
				case 2:
					return generateErrorCode(400065);	// 400065 = 온도 컨트롤러3 단선 감지.
				case 3:
					return generateErrorCode(400066);	// 400066 = 온도 컨트롤러4 단선 감지.
				case 4:
					return generateErrorCode(400067);	// 400067 = 온도 컨트롤러5 단선 감지.
				case 5:
					return generateErrorCode(400068);	// 400068 = 온도 컨트롤러6 단선 감지.
				case 6:
					return generateErrorCode(400069);	// 400069 = 온도 컨트롤러7 단선 감지.
				case 7:
					return generateErrorCode(400070);	// 400070 = 온도 컨트롤러8 단선 감지.
				case 8:
					return generateErrorCode(400071);	// 400071 = 온도 컨트롤러9 단선 감지.
				case 9:
					return generateErrorCode(400072);	// 400072 = 온도 컨트롤러10 단선 감지.
				case 10:
					return generateErrorCode(400073);	// 400073 = 온도 컨트롤러11 단선 감지.
				case 11:
					return generateErrorCode(400074);	// 400074 = 온도 컨트롤러12 단선 감지.
				default:
					break;
				}
			}
		}
	}
	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

void MTrsAutoManager::GetMonitoringLogResult()
{
	FILE* fp;

	if ((fp = fopen("..\\Log\\MonitoringLog0714.txt", "r")) == NULL)
		return;

	int i = 0;
	char szBuf[1000];
	CString strCurrent;
	CString strPrevious = "[00/00-00:00:00]";
	CString strTempStart = "00/00-00:00:00";
	CString strTempEnd;

	double dAutoRunTime = 0.0;		// 단위 : 초
	double dManualRunTime = 0.0;	// 단위 : 초
	double dNormalDownTime = 0.0;
	double dAbnormalDownTime = 0.0;	// 단위 : 초 - 설비 프로그램이 비정상 종료된 뒤, 다시 Loading 될 때까지 걸린 시간 합.

	BOOL bAutoRun = FALSE;
	BOOL bManualRun = FALSE;

	BOOL bProgramStart = FALSE;
	BOOL bProgramTermination = FALSE;

	while (TRUE)
	{
		i++;

		if (feof(fp) || NULL == fgets(szBuf, 1000, fp))
		{
			double dRest = getElapsedTime(strTempStart, "00/00-24:00:00");
			if (TRUE == bAutoRun)
				dAutoRunTime += dRest;
			else if (TRUE == bManualRun)
				dManualRunTime += dRest;

			break;
		}

		strCurrent.Format(_T("%s"), szBuf);

		int iTemp = strCurrent.Find(_T("]"));	// 시간 표시 부분 끝나는 위치 찾기.

		if ("state" == strCurrent.Mid(iTemp + 1, 5))
		{
			strPrevious = strCurrent;
			continue;
		}

		if (strCurrent.Find(_T("AUTORUN_MODE")))
		{
			strTempEnd = strCurrent.Mid(1, iTemp - 1);
			dManualRunTime += getElapsedTime(strTempStart, strTempEnd);

			strTempStart = strTempEnd;

			bAutoRun = TRUE;
			bManualRun = FALSE;
		}
		else if (stringExists(strCurrent, "MANUAL_MODE"))
		{
			strTempEnd = strCurrent.Mid(1, iTemp - 1);
			dAutoRunTime += getElapsedTime(strTempStart, strTempEnd);

			strTempStart = strTempEnd;

			bAutoRun = FALSE;
			bManualRun = TRUE;
		}
		else if (stringExists(strCurrent, "프로그램 시작"))
		{
			if (FALSE == bProgramTermination)
			{
				double dRest = getElapsedTime(strTempStart, strPrevious.Mid(1, iTemp - 1));
				if (TRUE == bAutoRun)
					dAutoRunTime += dRest;
				else if (TRUE == bManualRun)
					dManualRunTime += dRest;

				dAbnormalDownTime += getElapsedTime(strPrevious.Mid(1, iTemp - 1), strCurrent.Mid(1, iTemp - 1));
			}
			else
			{
				dNormalDownTime += getElapsedTime(strPrevious.Mid(1, iTemp - 1), strCurrent.Mid(1, iTemp - 1));
				bProgramTermination = TRUE;
			}

			bAutoRun = FALSE;
			bManualRun = TRUE;
		}
		else if (stringExists(strCurrent, "Program End"))
		{
			strTempEnd = strCurrent.Mid(1, iTemp - 1);
			double dRest = getElapsedTime(strTempStart, strTempEnd);
			if (TRUE == bAutoRun)
				dAutoRunTime += dRest;
			else if (TRUE == bManualRun)
				dManualRunTime += dRest;

			bProgramTermination = TRUE;
		}

		strPrevious = strCurrent;
	}
	fclose(fp);
}

double MTrsAutoManager::getElapsedTime(CString strStart, CString strEnd)
{
	double dStart = getSecondsFromTimeString(strStart);
	double dEnd = getSecondsFromTimeString(strEnd);

	ASSERT(dEnd >= dStart);

	return dEnd - dStart;
}

double MTrsAutoManager::getSecondsFromTimeString(CString strTime)
{
	ASSERT(14 == strTime.GetLength());

	double dSum = 0.0;
	CString strTemp;
	double rgdTime[6];
	WCHAR rgcTime[6];
	strTime.Remove(':');
	for (int i = 11; i > 5; i--)
	{
		swprintf(&(rgcTime[i - 6]), strTime.Mid(i, 1));

		rgdTime[i - 6] = wcstod(&(rgcTime[i - 6]), NULL);
	}

	dSum += rgdTime[5];
	dSum += rgdTime[4] * 10;
	dSum += rgdTime[3] * 60;
	dSum += rgdTime[2] * 600;
	dSum += rgdTime[1] * 3600;
	dSum += rgdTime[0] * 36000;

	return dSum;
}

BOOL MTrsAutoManager::stringExists(CString strSource, CString strTag)
{
	return strTag == strSource.Mid(16, strTag.GetLength());
}

// sesl_jdy
BOOL MTrsAutoManager::IsOffInterlockInvalidationSignal()
{
//@	#pragma message(__LOC__ "여기 함수 수정 하기!!!!!")
//@	return !m_plnkIO->IsOn(OUT_SAFETY_INVALIDATION1) || !m_plnkIO->IsOn(OUT_SAFETY_INVALIDATION2);
	return FALSE;
}

int MTrsAutoManager::SafetyModeInvalidate(BOOL bOnOff)
{
//@	#pragma message(__LOC__ "여기 함수 수정 하기!!!!!")
	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

BOOL MTrsAutoManager::isNoPanelInEquipment()
{
	//101005.KKY_____
	//	이전 설비로부터 Panel 받고 있는 경우.
	if (TRUE == m_plnkMelsecIF->IsOnUpperEqBit(eSendStart))
		return FALSE;
	//	Panel이 감지되는 경우.
#ifdef DEF_SOURCE_SYSTEM
#	ifdef DEF_USE_TRANSFER_CENTER	
	if (FALSE == m_plnkTrsPanelTransferCenter->IsEmptyPanel())
		return FALSE;
#	endif
	if (FALSE == m_plnkTrsPanelTransfer->IsEmptyPanel())
		return FALSE;
#endif
	if (FALSE == m_plnkTrsPanelAligner->IsEmptyPanel())
		return FALSE;
	if (FALSE == m_plnkTrsPanelTransferOut->IsEmptyPanel())
		return FALSE;
	

#ifdef DEF_USE_TURN_HANDLER
	if (FALSE == m_plnkTrsTHandler->IsEmptyPanel())
		return FALSE;
#endif
	return TRUE;
}

BOOL MTrsAutoManager::isFullPanelInEquipment()
{
	//101005.KKY__________
	BOOL tmpsts1 = FALSE, tmpsts2 = FALSE, tmpsts3 = FALSE, tmpsts4 = FALSE, tmpsts5 = FALSE, tmpsts6 = FALSE;

	//	이전 설비로부터 Panel 받고 있는 경우.
	tmpsts1 = m_plnkMelsecIF->IsOnUpperEqBit(eSendStart);

	//	Panel이 감지되는 경우
#ifdef DEF_SOURCE_SYSTEM
#	ifdef DEF_USE_TRANSFER_CENTER
	tmpsts2 = !m_plnkTrsPanelTransferCenter->IsEmptyPanel();
#	endif
	tmpsts3 = !m_plnkTrsPanelTransfer->IsEmptyPanel();
#endif

	tmpsts4 = !m_plnkTrsPanelAligner->IsEmptyPanel();

	tmpsts5 = !m_plnkTrsPanelTransferOut->IsEmptyPanel();

#ifdef DEF_USE_TURN_HANDLER
	tmpsts6	= !m_plnkTrsTHandler->IsEmptyPanel();
#endif
//	#pragma message(__LOC__ "여기 함수 수정 하기!!!!!")
	/*/
#ifdef DEF_SOURCE_SYSTEM
	if (MOlbSystemPre.GetPanelData()->m_dPanelSize_X < DEF_PANEL_SIZE_46INCH + 10.0)
	{
		//BOOL sts =  (tmpsts1 || tmpsts2) && tmpsts3 && tmpsts4 && tmpsts5;
		BOOL sts =  (tmpsts1 ||( tmpsts2 && tmpsts3)) && (tmpsts4 || tmpsts5);
		return sts;
	}
	else
	{
		BOOL sts =  tmpsts3 && tmpsts4 && tmpsts5;
		return sts;			
	}
#else
	BOOL sts = tmpsts4 && tmpsts5;
	return sts;			
#endif
	/*/
	return FALSE;

	//____________________
}

// TT_Alarm
void	MTrsAutoManager::SetTactTimeLogSave(BOOL bTactTimeLogSave)
{
	m_bTactTimeLogSave = bTactTimeLogSave;
}
BOOL	MTrsAutoManager::IsTactTimeLogSave()
{
	return m_bTactTimeLogSave;
}

// NSMC
CString MTrsAutoManager::GetNewModelDataFolderName(CString strDeviceID)
{
	CString strNewModel;

	const int iDeviceID_StringLength = 14;
	// 080818
	if (strDeviceID.GetLength() < iDeviceID_StringLength)
	{
		strNewModel.Empty();
		return strNewModel;
	}

	MFileUtil util;
//	CString strDataFolderPath = m_plnkSystemData->m_strModelDir;
	CString strDataFolderPath = m_plnkSystemData->m_strModelFileDir;

	int iModelFolderCount = util.GetDirCountInDir(strDataFolderPath);
	if (iModelFolderCount > DEF_MAX_MODEL)
	{
		strNewModel.Empty();
		return strNewModel;
	}

	CString* pstrModelFolderList = new CString[iModelFolderCount];

	// Directory List를 읽어와서 strModelList에 등록한다.
	util.GetDirListInDir(strDataFolderPath, pstrModelFolderList, iModelFolderCount);

	int i = 0;
	int j = 0;
	int* pSubCount = new int[iModelFolderCount];

	for (int i = 0; i < iModelFolderCount; i++)
	{
		pSubCount[i] = 0;
		pSubCount[i] = util.GetDirCountInDir(strDataFolderPath + "\\" + pstrModelFolderList[i]);
	}

	CString strSrc = strDeviceID.Mid(0, iDeviceID_StringLength);
	CString strTgt;
	CString* pstrSubDeviceIDList;
	// 080818
	BOOL bExit = FALSE;
	for (int i = 0; i < iModelFolderCount; i++)
	{
		// 080818
		if (pSubCount[i] < 1)
			continue;

		pstrSubDeviceIDList = new CString[pSubCount[i]];
		util.GetDirListInDir(strDataFolderPath + "\\" + pstrModelFolderList[i], pstrSubDeviceIDList, pSubCount[i]);

		for (int j = 0; j < pSubCount[i]; j++)
		{
			strTgt = pstrSubDeviceIDList[j].Mid(0, iDeviceID_StringLength);
			if (strSrc == strTgt)
			{
				strNewModel = pstrModelFolderList[i];
				
				// 080818
				bExit = TRUE;
				break;
			}
		}

		delete[] pstrSubDeviceIDList;

		// 080818
		if (TRUE == bExit)
			break;
	}

	delete[] pSubCount;
	delete[] pstrModelFolderList;

	if (i == iModelFolderCount)
		strNewModel.Empty();

	return strNewModel;
}

BOOL MTrsAutoManager::IsLastGlassInput()
{
	if (FALSE == m_plnkSystemData->m_bUseAutoModelChange)
		return FALSE;

	return m_bInputLastGlass;
}

BOOL MTrsAutoManager::IsLastGlassOnWorker(int iWorkerID)
{
	if (FALSE == m_plnkSystemData->m_bUseAutoModelChange)
		return FALSE;

	ASSERT(iWorkerID > -1 && iWorkerID <= DEF_MAX_PANEL_UNIT);

	// 080818
	CString strCommand = m_pGlassData[iWorkerID]->m_strComment;
	if (strCommand == "LAST GLASS")
		return TRUE;

	return FALSE;
}

BOOL MTrsAutoManager::IsStartModelChange()
{
	return m_plnkSystemData->m_bUseAutoModelChange && m_bModelChangeStart;
}

void MTrsAutoManager::ResetAutoModelChagneFlag()
{
/*	//NSMC KJS
	//Melsec Bit신호 reset
	m_plnkMelsecIF->SetNSMCBit(eModelChangeReserve, FALSE);
	m_plnkMelsecIF->SetNSMCBit(eModelChangeStart, FALSE);
	m_plnkMelsecIF->SetNSMCBit(eModelChangeComplete, FALSE);
	m_plnkMelsecIF->SetNSMCBit(eModelChangeDisable, FALSE);

	//Melsec Word reset
	m_pNSMCLocalData->ResetData();
	m_plnkMelsecIF->SetNSMCWord(m_pNSMCLocalData);
*/
	m_bInputLastGlass = FALSE;
	m_bModelChangeStart = FALSE;
}

// NSMC
/** Panel 공급 중단 여부를 설정한다. */
void MTrsAutoManager::SetPanelInStopNSMC(BOOL bPanelInStopNSMC)
{
	m_bPanelInStopNSMC = bPanelInStopNSMC;

	//SS chang
	if(m_bPanelInStopNSMC == TRUE)
	{
		m_plnkLCNet->EqSpecialStateReport(ePanelSupplyStopStartNSMC);
	}
	else
	{
		m_plnkLCNet->EqSpecialStateReport(ePanelSupplyStopEndNSMC);
	}

	if (m_hAutoViewWnd != NULL)	// 이 조건 제거해도 되는지 확인할 것. (생성되지 않은 Wnd 에 Msg 보내면 어떻게 될까?)
		::SendMessage(m_hAutoViewWnd, WM_AUTO_STATUS, m_eOPMode, m_bPanelInStopNSMC);
}

BOOL	MTrsAutoManager::IsPanelInStopNSMC()
{
	if (FALSE == m_plnkSystemData->m_bUseAutoModelChange)
		return FALSE;

	return m_bPanelInStopNSMC;
}

MModelChangeWordDatas*	MTrsAutoManager::GetCurrentNSMCInfo()
{
	return m_pNSMCLocalData;
}

void	MTrsAutoManager::SetCurrentNSMCInfo(MModelChangeWordDatas nsmcData)
{
	m_pNSMCLocalData->CopyData(nsmcData);
}

int MTrsAutoManager::PrepareAfterMC()
{
	int iResult = m_plnkTrsPanelAligner->Initialize(TRUE, FALSE);
	if (ERR_TRS_AUTO_MANAGER_SUCCESS != iResult)
	{
		PROCESS_AUTOMANAGER_ALARM(iResult);
	}	

//SJ_YYK 110502 Modify Auto Model Chnage....
	for (int i = DEF_MAX_TABMOUNTER - 1; i >= 0; i--)
	{
		iResult = m_plnkTrsTabMounter[i]->Initialize();
//		Sleep(static_cast<unsigned long>(m_plnkSystemData->m_dStartMoveDelay) * 1000);
		Sleep(500);
		if (ERR_TRS_AUTO_MANAGER_SUCCESS != iResult)
		{
			PROCESS_AUTOMANAGER_ALARM(iResult);
		}
		iResult = m_plnkTrsRTabMounter[i]->Initialize();
//		Sleep(static_cast<unsigned long>(m_plnkSystemData->m_dStartMoveDelay) * 1000);
		Sleep(500);
		if (ERR_TRS_AUTO_MANAGER_SUCCESS != iResult)
		{
			PROCESS_AUTOMANAGER_ALARM(iResult);
		}

	}
	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

BOOL MTrsAutoManager::GetModelChangeReserveBit()
{
	BOOL bModelChangeReserve = FALSE;
	
	if (m_iNSMCControlNo != NSMC_CONTROL_EQUIP)
	{
		m_plnkMelsecIF->GetNSMCWord(m_pNSMCControlData, m_iNSMCControlNo);
		#ifdef DEF_SOURCE_SYSTEM
			bModelChangeReserve = _wtoi(m_pNSMCControlData->m_strPanelWIP) == eLocalCommand4 ? TRUE : FALSE;
		#else
			bModelChangeReserve = _wtoi(m_pNSMCControlData->m_strPanelWIP) == eLocalCommand5 ? TRUE : FALSE;
		#endif
	}
	else
	{
		
//SJ_YYK 110502 Add... S&G Type, S Type 설비 No. 구분...
#ifdef DEF_SOURCE_SYSTEM
		bModelChangeReserve = m_plnkMelsecIF->IsOnNSMCEqBit(eLocalCommand4, m_iNSMCControlNo);
#else
		bModelChangeReserve = m_plnkMelsecIF->IsOnNSMCEqBit(eLocalCommand5, m_iNSMCControlNo);
#endif
	
		//________________________________
	}
	
	return bModelChangeReserve;	
}

void MTrsAutoManager::CheckMaterialValidation(int iTabFeederNo, int iSelectedReel, BOOL bAutoModelChange)
{
	ASSERT (iTabFeederNo == DEF_TABFEEDER1 || iTabFeederNo == DEF_TABFEEDER2);
	ASSERT (iSelectedReel == DEF_USING_REEL || iSelectedReel == DEF_SPARE_REEL);

	m_plnkCtrlTabFeeder[iTabFeederNo]->m_matTabICInfo[iSelectedReel].m_nM_STATE = eMatStateIdle;

	BOOL bCheckTimeOver = FALSE;
	eMState bCheckMatState;

#ifdef DEF_SESL_SITE
	if (TRUE == bAutoModelChange)
	{
		m_plnkLCNet->MaterialReport(eMatInfoRequest, &(m_plnkCtrlTabFeeder[iTabFeederNo]->m_matTabICInfo[iSelectedReel]));
	}
#endif

#ifdef DEF_SESL_SITE
	m_plnkLCNet->MaterialReport(eMatStockIn, &(m_plnkCtrlTabFeeder[iTabFeederNo]->m_matTabICInfo[iSelectedReel]));
#else
	m_plnkLCNet->MaterialReport(eMatDockIn, &(m_plnkCtrlTabFeeder[iTabFeederNo]->m_matTabICInfo[iSelectedReel]));
#endif
	
	MTickTimer tmMaterialCheck;
	tmMaterialCheck.StartTimer();
	while (1)
	{
		if (tmMaterialCheck.MoreThan(4.0))
		{
			bCheckTimeOver = TRUE;
			break;
		}

		bCheckMatState = (eMState)m_plnkCtrlTabFeeder[iTabFeederNo]->m_matTabICInfo[iSelectedReel].m_nM_STATE;
		
		if (bCheckMatState != eMatStateIdle)
			break;

		Sleep(100);
	}

	if (bCheckTimeOver || bCheckMatState != eMatStateEnable)
	{
		::SendMessage(m_hTitleViewWnd, WM_DISP_MAT_CHECK, (WPARAM)iTabFeederNo, (LPARAM)iSelectedReel);
		while (1)
		{
			if (TRUE == m_plnkOpPanel->GetEStopButtonStatus())
				return;
			
			bCheckMatState = (eMState)m_plnkCtrlTabFeeder[iTabFeederNo]->m_matTabICInfo[iSelectedReel].m_nM_STATE;

			if (bCheckMatState != eMatStateIdle)
				break;
			
			Sleep(100);
		}
	}

	return;
}

// hongju_SESL
//BOOL	MTrsAutoManager::IsPanelInStopLoadConveyor()
BOOL MTrsAutoManager::IsPanelInStopPanelTransferCenter()
{
	//return m_plnkTrsLoadConveyor->IsPanelInStop();
#	ifdef DEF_USE_TRANSFER_CENTER
	return m_plnkTrsPanelTransferCenter->IsPanelInStop();
#	else
	return m_plnkTrsPanelTransfer->IsPanelInStop();
#	endif
}

//SESL_LKH_090711 : 설비간 함수 통일을 위해 추가
BOOL MTrsAutoManager::IsDoorOpen()
{
#ifdef DEF_SETUP
	return FALSE;
#endif

#ifdef SIMULATION
	return FALSE;
#endif

	// hongju 수정...코드 간결화...항상 Safety 센서와 도어 open을 같이 보도록 코드 짤 필요 있나?
	if(m_plnkSystemData != NULL)
	{
		if (m_plnkSystemData->m_bSafetySensor)
		{
			return m_plnkManageOpPanel->GetDoorSWStatus();
		}
		else
		{
			// hongju_SESL : 심우섭 임시 수정.
			return FALSE;
		}
	}
	else
		return FALSE;
}

//@DoorLock________________
BOOL MTrsAutoManager::IsAllDoorOpen()
{
	if (m_plnkIO->IsOn(IN_FRONT_DOOR1) || m_plnkIO->IsOn(IN_FRONT_DOOR2)
		|| m_plnkIO->IsOn(IN_FRONT_DOOR3) || m_plnkIO->IsOn(IN_FRONT_DOOR4)	
		|| m_plnkIO->IsOn(IN_REAR_DOOR1) || m_plnkIO->IsOn(IN_REAR_DOOR2)
		|| m_plnkIO->IsOn(IN_REAR_DOOR3) || m_plnkIO->IsOn(IN_REAR_DOOR4))
		return TRUE;
	return FALSE;
}

BOOL MTrsAutoManager::IsFrontDoorOpen()
{
	if (m_plnkIO->IsOn(IN_FRONT_DOOR1) || m_plnkIO->IsOn(IN_FRONT_DOOR2) || m_plnkIO->IsOn(IN_FRONT_DOOR3))
		return TRUE;
	return FALSE;
}

BOOL MTrsAutoManager::IsRearDoorOpen()
{
	if (m_plnkIO->IsOn(IN_REAR_DOOR1) || m_plnkIO->IsOn(IN_REAR_DOOR2)
		|| m_plnkIO->IsOn(IN_REAR_DOOR3) || m_plnkIO->IsOn(IN_REAR_DOOR4) || m_plnkIO->IsOn(IN_REAR_DOOR5)
		)
		return TRUE;
	return FALSE;
}

//131111. SJ_YTH
BOOL MTrsAutoManager::IsMeterialDoorOpenFront()
{
	if (m_plnkIO->IsOn(IN_FRONT_DOOR5) || m_plnkIO->IsOn(IN_FRONT_DOOR6))
		return TRUE;
	return FALSE;
}

BOOL MTrsAutoManager::IsMeterialDoorOpenRear()
{
	if (m_plnkIO->IsOn(IN_REAR_DOOR5) || m_plnkIO->IsOn(IN_REAR_DOOR6))
		return TRUE;
	return FALSE;
}
//@________________________


//SESL_요구사항반영
#ifdef DEF_SESL_SITE
void MTrsAutoManager::checkMoldCount()
{
	if ( m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matZigInfo.m_nU_QTY > m_iOldMoldCount1 )
	{
		m_iMoldCount1 += (m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matZigInfo.m_nU_QTY - m_iOldMoldCount1);
		m_iOldMoldCount1 = m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matZigInfo.m_nU_QTY;
	}

	//2009.08.11 CYJ
	if ( (290000 == m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matZigInfo.m_nU_QTY) 
		|| (295000== m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matZigInfo.m_nU_QTY) )
	{
		// 15초 단위로 Op Call
		m_iMoldCountAlarmCount1++;
		if (m_iMoldCountAlarmCount1 % 1500 == 0)
		{
			//Feeder 1의 Mold Count가 290000을 초과하였습니다. 금형 교체를 준비하세요.
			CString strMsg;
			ReadDisplayMessage(MY_MESSAGE_BOX, _T("Message_62022"), &strMsg);
			SetOperatorCall(TRUE, strMsg);
			m_iMoldCountAlarmCount1 = -1;
		}
	}

	if ( m_plnkCtrlTabFeeder[DEF_TABFEEDER1]->m_matZigInfo.m_nU_QTY > 300000 )
	{
		//Feeder 1의 Mold Count가 300000을 초과하였습니다.
		PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400080));
	}

//KKY.Del #	ifdef DEF_GATE_SYSTEM
	if ( m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matZigInfo.m_nU_QTY > m_iOldMoldCount2 )
	{
		m_iMoldCount2 += (m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matZigInfo.m_nU_QTY - m_iOldMoldCount2);
		m_iOldMoldCount2 = m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matZigInfo.m_nU_QTY;
	}

	//2009.08.11 CYJ
	if ( (290000 == m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matZigInfo.m_nU_QTY) 
		|| (295000== m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matZigInfo.m_nU_QTY) )
	{
		// 15초 단위로 Op Call
		m_iMoldCountAlarmCount2++;
		if (m_iMoldCountAlarmCount2 % 1500 == 0)
		{
			//Feeder 2의 Mold Count가 290000을 초과하였습니다. 금형 교체를 준비하세요.
			CString strMsg;
			ReadDisplayMessage(MY_MESSAGE_BOX, _T("Message_62023"), &strMsg);
			SetOperatorCall(TRUE, strMsg);
			m_iMoldCountAlarmCount2 = -1;
		}
	}

	if ( m_plnkCtrlTabFeeder[DEF_TABFEEDER2]->m_matZigInfo.m_nU_QTY > 300000 )
	{
		//Feeder 2의 Mold Count가 300000을 초과하였습니다.
		PROCESS_AUTOMANAGER_ALARM(generateErrorCode(400081));
	}
//KKY.Del #	endif
	
}
#endif

// hongju_MC : Auto NSMC_INFO에서 입력받은 New Model 정보를 Setting 해주는 부분..
//110114.kms__________
void MTrsAutoManager::SetNewModelName(CString strNewModelName, CString strNewDeviceName)
{
	m_strNewModelName = strNewModelName;
	//110114.kms__________
	m_strNewDeviceName = strNewDeviceName;
}

CString	MTrsAutoManager::GetNewModelName()
{
	return m_strNewModelName;
}

//100807.ECID_____________________________
//
int MTrsAutoManager::GetEqConstData(CString strECID, MEqConstant *pData)
{
	MEqConstant *pECData;
	pECData = new MEqConstant;

	CString strSqlMsg;
	strSqlMsg.Format(_T("Select * From EQ_EC_DATA Where ECID = '%s'"), strECID);
	MyInputDB.ExcuteQry(strSqlMsg);

	MyInputDB.GetData(0,0, pECData->m_strECID);
	MyInputDB.GetData(1,0, pECData->m_strECName);
	MyInputDB.GetData(7,0, pECData->m_strECSLL);
	MyInputDB.GetData(8,0, pECData->m_strECSUL);
	MyInputDB.GetData(9,0, pECData->m_strECWLL);
	MyInputDB.GetData(10,0, pECData->m_strECWUL);
	MyInputDB.GetData(11,0, pECData->m_strECDef);

	pData->CopyData(pECData);

	return 0;
}

// EC Data를 RecodeSet에 추가하고 L/C에 전송한다.
int MTrsAutoManager::InsertEqConstData(MEqConstant *pData)
{
	if (FALSE == MOlbSystemPre.GetSystemData()->m_bUseECDataReport)
		return 0;

	MEqConstant*	pECData;
	pECData = NULL;

	pECData->CopyData(pData);

	CString strSqlMsg;
	strSqlMsg.Format(_T("Insert into EQ_EC_DATA ECID='%s', ECNAME='%s', ECSLL='%s', ECSUL='%s', ECWLL='%s', ECWUL='%s', ECDEF='%s'")
		, pECData->m_strECID, pECData->m_strECName, pECData->m_strECSLL, pECData->m_strECSUL, pECData->m_strECWLL, pECData->m_strECWUL);

	MyInputDB.InsUpDel(strSqlMsg);

	m_plnkLCNet->ParamECChangeReport(eChangeRequest, pECData);

	return 0;
}

// 하나의 ECID 에 대하여 EC Data를 Update하고 결과를 L/C로 전송한다.
int MTrsAutoManager::UpdateEqConstData(MEqConstant *pData)
{
	if (FALSE == MOlbSystemPre.GetSystemData()->m_bUseECDataReport)
		return 0;

	MEqConstant*	pECData;
	pECData = NULL;

	//pECData->CopyData(pData);
	pECData = pData;

	// Host Change 가능 여부 판단 필요...	

	CString strSqlMsg;
	//strSqlMsg.Format(_T("Update EQ_EC_DATA set ECNAME='%s', ECSLL='%s', ECSUL='%s', ECWLL='%s', ECWUL='%s', ECDEF='%s' where ECID='%s'")
	//	, pECData->m_strECName, pECData->m_strECSLL, pECData->m_strECSUL, pECData->m_strECWLL, pECData->m_strECWUL, pECData->m_strECDef, pECData->m_strECID);
	strSqlMsg.Format(_T("Update EQ_EC_DATA set ECNAME='%s', ECDEF='%s' where ECID='%s'")
		, pECData->m_strECName, pECData->m_strECDef,pECData->m_strECID);
	

	MyInputDB.InsUpDel(strSqlMsg);

	m_plnkLCNet->ParamECChangeReport(eChangeRequest, pECData);

	return 0;
}

// 여러개의 ECID 에 대하여 EC Data를 Update하고 결과를 L/C로 전송한다.
int MTrsAutoManager::UpdateEqConstDataList()
{
	if (FALSE == MOlbSystemPre.GetSystemData()->m_bUseECDataReport)
		return 0;

	CPtrList* pECList;
	MEqConstant* pECData;

	pECList = m_plnkLCNet->m_pECList;

	int nCount; 
	POSITION Pos;

	CString strSqlMsg;

	Pos = pECList->GetHeadPosition();

	nCount = pECList->GetCount();
	
	for (int i=0; i<nCount; i++)
	{
		if (Pos == NULL) continue;

		pECData = (MEqConstant *)pECList->GetAt(Pos);
		strSqlMsg.Format(_T("Update EQ_EC_DATA set ECNAME='%s', ECSLL='%s', ECSUL='%s', ECWLL='%s', ECWUL='%s', ECDEF='%s' where ECID='%s'")
			, pECData->m_strECName, pECData->m_strECSLL, pECData->m_strECSUL, pECData->m_strECWLL, pECData->m_strECWUL, pECData->m_strECDef, pECData->m_strECID);

		MyInputDB.InsUpDel(strSqlMsg);

		m_plnkLCNet->ParamECChangeReport(eChangeRequest, pECData);

		pECList->GetNext(Pos);
	}

	pECList->RemoveAll();

	return 0;
}

// 전체 EC Data List 조회 결과를 L/C로 전송한다.
int MTrsAutoManager::ReplyEqConstList()
{
	if (FALSE == MOlbSystemPre.GetSystemData()->m_bUseECDataReport)
		return 0;

	MEqConstant*	pECData;
	pECData = new MEqConstant;

	CString strSqlMsg;
	strSqlMsg = _T("Select * From EQ_EC_DATA order by ECID ASC");
	MyInputDB.ExcuteQry(strSqlMsg);

	int rowsize = MyInputDB.GetRowSize();

	DWORD sTime = GetTickCount();
	for (int i = 0; i < rowsize; i++)
	{
		MyInputDB.GetData(0 ,  i, pECData->m_strECID);
		MyInputDB.GetData(1 ,  i, pECData->m_strECName);
		MyInputDB.GetData(7 ,  i, pECData->m_strECSLL);
		MyInputDB.GetData(8 ,  i, pECData->m_strECSUL);
		MyInputDB.GetData(9 ,  i, pECData->m_strECWLL);
		MyInputDB.GetData(10,  i, pECData->m_strECWUL);
		MyInputDB.GetData(11,  i, pECData->m_strECDef);
		// m_pECList에 추가
		m_plnkLCNet->SetParamEC(pECData);
	}
	UINT dTime = GetTickCount() - sTime;
	TRACE(_T("=====ReplyEqConstList:%d=====\n"), dTime);

	m_plnkLCNet->ParamECReportAll(eInitRequest, rowsize);

	delete pECData;

	return 0;
}

//Transfer투입부에 패널이 있는지
BOOL MTrsAutoManager::IsPanelExistInTransfer()
{
	//171013_KDH Panel Aligner 가 스케쥴 생성하기전 시점 변경, Transfer In이 Panel을 가지고 있을 경우에만 보도록  
	//	이전 설비로부터 Panel 받고 있는 경우.
	//if (TRUE == m_plnkMelsecIF->IsOnUpperEqBit(eSendAble)
	//	|| TRUE == m_plnkMelsecIF->IsOnUpperEqBit(eSendStart))
	//	return TRUE;
#ifdef DEF_SOURCE_SYSTEM
	//	Panel이 감지되는 경우.	
#	ifdef DEF_USE_TRANSFER_CENTER
	//if (FALSE == m_plnkTrsPanelTransferCenter->IsEmptyPanel())
	//	return TRUE;
#	endif
	if (FALSE == m_plnkTrsPanelTransfer->IsEmptyPanel())
		return TRUE;
#else
	if (FALSE == m_plnkTrsPanelAligner->IsEmptyPanel())
		return TRUE;
#endif
	return FALSE;
}

//앞설비에서 넘겨줄 패널이 있는지
BOOL MTrsAutoManager::IsPanelExistInPrevMachine()
{
	return m_plnkMelsecIF->IsOnUpperEqBit(eWorkStart_LowerEq);
}

//________________________________________________________________________

//SJ_YYK 101124 Add....
void MTrsAutoManager::SetMaterialDoorCheck(BOOL bFlag, int iWorkGroup)
{
//@	#pragma message(__LOC__ "SetMaterialDoorCheck() 여기 함수 수정 하기!!!!!")
	if (iWorkGroup == DEF_FRONT_GROUP)
	{
		//120213.kms____________
		//Door 맞지 않아 수정 함
#	ifdef DEF_SOURCE_SYSTEM
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 0);
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 1);
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 8);
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 9);
#	else
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 1);
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 2);
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 9);
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 10);
#	endif


	}
	else
	{
#	ifdef DEF_SOURCE_SYSTEM
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 4);
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 5);
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 12);
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 13);
#	else
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 5);
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 6);
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 13);
		m_plnkManageOpPanel->SetMaterialChangeFlag(bFlag, 0, 14);
#	endif
		
	}
}
//______________________*/
//____________________________________
// Add. 110525 기종변경 예약 Bit 추가
BOOL MTrsAutoManager::GetNewModelReserveBit()
{
	BOOL bNewModelReserved = FALSE;
	
	if (m_iNSMCControlNo != NSMC_CONTROL_EQUIP)
	{
		m_plnkMelsecIF->GetNSMCWord(m_pNSMCControlData, m_iNSMCControlNo);
#ifdef DEF_SOURCE_SYSTEM
		bNewModelReserved = _wtoi(m_pNSMCControlData->m_strPanelWIP) == eLocalCommand4 ? TRUE : FALSE;
#else
		bNewModelReserved = _wtoi(m_pNSMCControlData->m_strPanelWIP) == eLocalCommand5 ? TRUE : FALSE;
#endif
	}
	else
	{
#ifdef DEF_SOURCE_SYSTEM
		bNewModelReserved = m_plnkMelsecIF->IsOnNSMCEqBit(eLocalCommand4, m_iNSMCControlNo, 1, true);
#else
		bNewModelReserved = m_plnkMelsecIF->IsOnNSMCEqBit(eLocalCommand5, m_iNSMCControlNo, 1, true);
#endif

	}

	return bNewModelReserved;
}
//______________________________________

int	MTrsAutoManager::CheckFeederEnable()
{
	return ERR_TRS_AUTO_MANAGER_SUCCESS;
#ifdef DEF_SOURCE_SYSTEM
	/*/
	if (FALSE == m_plnkSystemData->m_bUse1FeederAllMount)
	{
		if (m_plnkSystemData->m_nUseFeeder == DEF_TABFEEDER_1)
		{
//			if (m_plnkCtrlTabFeeder[0]->GetHomeFlagSprocket2() == FALSE)
			if (FALSE == m_plnkCtrlTabFeeder[0]->GetFeederReady())
			{
				SetErrorLevel(_T("AUTO MANAGER check OP State(Before Start Run)"), 0, __FILE__, __LINE__);
				// 400015 = Feeder1 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
				// 400016 = Feeder2 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
				return generateErrorCode(400015);
			}
		}
		else if (m_plnkSystemData->m_nUseFeeder == DEF_TABFEEDER_2)
		{
			//if (m_plnkCtrlTabFeeder[1]->GetHomeFlagSprocket2() == FALSE)
			if (FALSE == m_plnkCtrlTabFeeder[1]->GetFeederReady())
			{
				SetErrorLevel(_T("AUTO MANAGER check OP State(Before Start Run)"), 0, __FILE__, __LINE__);
				// 400015 = Feeder1 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
				// 400016 = Feeder2 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
				return generateErrorCode(400016);
			}
		}
		else
		{
			for (int i = 0; i < DEF_MAX_TABFEEDER; i++)
			{
				//if (m_plnkCtrlTabFeeder[i]->GetHomeFlagSprocket2() == FALSE)
				if (FALSE == m_plnkCtrlTabFeeder[i]->GetFeederReady())
				{
					SetErrorLevel(_T("AUTO MANAGER check OP State(Before Start Run)"), 0, __FILE__, __LINE__);
					// 400015 = Feeder1 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
					// 400016 = Feeder2 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
					return generateErrorCode(400015 + i);
				}
			}
		}
	}
	else
	{
		//if (FALSE == m_plnkCtrlTabFeeder[0]->GetHomeFlagSprocket2() && FALSE == m_plnkCtrlTabFeeder[1]->GetHomeFlagSprocket2())
		if (FALSE == m_plnkCtrlTabFeeder[0]->GetFeederReady() && FALSE == m_plnkCtrlTabFeeder[1]->GetFeederReady())
		{
			//if (m_plnkCtrlTabFeeder[0]->GetHomeFlagSprocket2() == FALSE)
			if (FALSE == m_plnkCtrlTabFeeder[0]->GetFeederReady())
			{
				SetErrorLevel(_T("AUTO MANAGER check OP State(Before Start Run)"), 0, __FILE__, __LINE__);
				// 400015 = Feeder1 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
				// 400016 = Feeder2 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
				return generateErrorCode(400015);
			}
			//if (m_plnkCtrlTabFeeder[1]->GetHomeFlagSprocket2() == FALSE)
			if (FALSE == m_plnkCtrlTabFeeder[1]->GetFeederReady())
			{
				SetErrorLevel(_T("AUTO MANAGER check OP State(Before Start Run)"), 0, __FILE__, __LINE__);
				// 400015 = Feeder1 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
				// 400016 = Feeder2 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
				return generateErrorCode(400016);
			}
		}
	}
	/*/
	if (m_plnkPanelData->m_bUseFlag_Xu)
	{
		//if (m_plnkCtrlTabFeeder[DEF_FRONT_GROUP]->GetHomeFlagSprocket2() == FALSE)
		if (FALSE == m_plnkCtrlTabFeeder[DEF_FRONT_GROUP]->GetFeederReady())
			// 400015 = Feeder1 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
			return generateErrorCode(400015);
	}
	else if (m_plnkPanelData->m_bUseFlag_Xd)
	{
		//if (m_plnkCtrlTabFeeder[DEF_REAR_GROUP]->GetHomeFlagSprocket2() == FALSE)
		if (FALSE == m_plnkCtrlTabFeeder[DEF_REAR_GROUP]->GetFeederReady())
			// 400016 = Feeder2 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
			return generateErrorCode(400016);
	}
#else
#	ifndef DEF_MIRROR_
	if (m_plnkPanelData->m_bUseFlag_Yl)
	{
		//if (m_plnkCtrlTabFeeder[DEF_FRONT_GROUP]->GetHomeFlagSprocket2() == FALSE)
		if (FALSE == m_plnkCtrlTabFeeder[DEF_FRONT_GROUP]->GetFeederReady())
		{
			SetErrorLevel(_T("AUTO MANAGER check OP State(Before Start Run)"), 0, __FILE__, __LINE__);
			// 400015 = Feeder1 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
			// 400016 = Feeder2 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
			return generateErrorCode(400015);
		}
	}
	else if (m_plnkPanelData->m_bUseFlag_Yr)
	{
		//if (m_plnkCtrlTabFeeder[DEF_REAR_GROUP]->GetHomeFlagSprocket2() == FALSE)
		if (FALSE == m_plnkCtrlTabFeeder[DEF_REAR_GROUP]->GetFeederReady())
		{
			SetErrorLevel(_T("AUTO MANAGER check OP State(Before Start Run)"), 0, __FILE__, __LINE__);
			// 400015 = Feeder1 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
			// 400016 = Feeder2 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
			return generateErrorCode(400016);
		}
	}
#	else
	if (m_plnkPanelData->m_bUseFlag_Yl)
	{
		//if (m_plnkCtrlTabFeeder[DEF_REAR_GROUP]->GetHomeFlagSprocket2() == FALSE)
		if (FALSE == m_plnkCtrlTabFeeder[DEF_REAR_GROUP]->GetFeederReady())
		{
			SetErrorLevel(_T("AUTO MANAGER check OP State(Before Start Run)"), 0, __FILE__, __LINE__);
			// 400015 = Feeder1 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
			// 400016 = Feeder2 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
			return generateErrorCode(400016);
		}
	}
	else if (m_plnkPanelData->m_bUseFlag_Yr)
	{
		//if (m_plnkCtrlTabFeeder[DEF_FRONT_GROUP]->GetHomeFlagSprocket2() == FALSE)
		if (FALSE == m_plnkCtrlTabFeeder[DEF_FRONT_GROUP]->GetFeederReady())
		{
			SetErrorLevel(_T("AUTO MANAGER check OP State(Before Start Run)"), 0, __FILE__, __LINE__);
			// 400015 = Feeder1 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
			// 400016 = Feeder2 Home 상태가 아니므로 자동운전을 시작할 수 없습니다.
			return generateErrorCode(400015);
		}
	}
#	endif
#endif
	return ERR_TRS_AUTO_MANAGER_SUCCESS;
}

BOOL MTrsAutoManager::GetStartSWStatus()
{
	return m_plnkManageOpPanel->GetStartSWStatus();
}

BOOL MTrsAutoManager::GetStopSWStatus()
{
	return m_plnkManageOpPanel->GetStopSWStatus();
}

BOOL MTrsAutoManager::GetResetSWStatus()
{
	return m_plnkManageOpPanel->GetResetSWStatus();
}

BOOL MTrsAutoManager::GetEStopSWStatus()
{
	return m_plnkManageOpPanel->GetEStopSWStatus();
}

BOOL MTrsAutoManager::IsAll1FeederAllMount_MountInitReady()
{
	/*/
	BOOL bInitReadyState[DEF_MAX_TABMOUNTER];
	memset(bInitReadyState, TRUE, sizeof(bInitReadyState));

	bInitReadyState[0] = m_plnkTrsTabMounter[DEF_TABMOUNTER1]->Is1FeederAllMountInitReady();
	bInitReadyState[1] = m_plnkTrsTabMounter[DEF_TABMOUNTER2]->Is1FeederAllMountInitReady();
	bInitReadyState[2] = m_plnkTrsTabMounter[DEF_TABMOUNTER3]->Is1FeederAllMountInitReady();
	bInitReadyState[3] = m_plnkTrsTabMounter[DEF_TABMOUNTER4]->Is1FeederAllMountInitReady();
	bInitReadyState[4] = m_plnkTrsTabMounter[DEF_TABMOUNTER5]->Is1FeederAllMountInitReady();
	bInitReadyState[5] = m_plnkTrsTabMounter[DEF_TABMOUNTER6]->Is1FeederAllMountInitReady();
	bInitReadyState[6] = m_plnkTrsTabMounter[DEF_TABMOUNTER7]->Is1FeederAllMountInitReady();
	bInitReadyState[7] = m_plnkTrsTabMounter[DEF_TABMOUNTER8]->Is1FeederAllMountInitReady();
	
	BOOL bResult = TRUE;
	for (int i=0; i<DEF_MAX_TABMOUNTER; i++)
	{
		bResult &= bInitReadyState[i];
	}
	return bResult;
	/*/
	return FALSE;
}

BOOL MTrsAutoManager::IsAll1FeederAllMount_PanelAlignerInitReady()
{
//@	return m_plnkTrsPanelAligner->Is1FeederAllMountInitReady();
	return FALSE;
}

//110620.KKY_____
int MTrsAutoManager::CheckProductValidation()
{
	MProductPlanBatchData*	pCurProductPlan = &(m_plnkLCNet->m_CurProductPlan);
	MProductPlanBatchData*	pNextProductPlan = &(m_plnkLCNet->m_NextProductPlan);
	MProductPlanBatchData*	pEndProductPlan = &(m_plnkLCNet->m_EndProductPlan);

	//SJ_YYK 111004 Modify...
	//MGlassDatas*			pRecvGlassData = m_pGlassData[DEF_PANEL_TRANSFER_CENTER_PANEL];
	MGlassDatas pRecvGlassData ;
	//pRecvGlassData = new MGlassDatas;
	m_plnkMelsecIF->GetGlassData((MToLowerEqs*)(&pRecvGlassData));

	// 자동 생산 계획 시작
	// 투입 지시량 도달 확인
	if (m_plnkProductInfoData->m_iProductCount >= m_plnkLCNet->m_CurProductPlan.m_nBatchSize)
	{
		// 현재 생산 계획 종료
		m_plnkLCNet->m_EndProductPlan.SetData(&m_plnkLCNet->m_CurProductPlan);
		m_plnkLCNet->m_EndProductPlan.m_nBatchState = eProductPlanEnd;
		m_plnkLCNet->ProductPlanReport(eProductPlanBatchEnd, &m_plnkLCNet->m_EndProductPlan);
		m_plnkLCNet->m_CurProductPlan.Clear();
		
		m_plnkProductInfoData->m_iProductCount = 0;
		m_plnkProductInfoData->WriteData();
		
		// 다음 생산 계획을 현재 생산 계획으로 Update
		//if(m_pLCNet->m_NextProductPlan.m_sBatchID != "")
		if (m_plnkLCNet->m_NextProductPlan.m_sBatchID != "" &&
			m_plnkLCNet->m_NextProductPlan.m_nBatchSize != 0)
		{
			m_plnkLCNet->m_CurProductPlan.SetData(&m_plnkLCNet->m_NextProductPlan);
			m_plnkLCNet->m_NextProductPlan.Clear();
			// 현재 생산정보 상태 변경 보고
			m_plnkProductInfoData->m_iProductCount = 0; //m_lnkPM->ClearProductCount();
			m_plnkLCNet->m_CurProductPlan.m_nBatchState = eProductPlanCreate;
			//m_pLCNet->ProductPlanReport(eProductPlanBatchStart, &m_pLCNet->m_CurProductPlan);
		}
		
		::SendMessage(m_hAutoViewWnd, WM_DISP_PRODUCT_PLAN_MSG, (WPARAM)eProductPlanCreate, NULL);
		
		// 생산 계획 요청
		Sleep(3000); // 3초 동안 아무것도 안해도 되는가?
		MPlanRequestData *pPR;
		pPR = new MPlanRequestData;
		
		pPR->m_nM_KIND = 0 ;
		pPR->m_sEQPID.Format(m_plnkSystemData->m_strEQPID);
		pPR->m_sLINE_NO.Format(_T("LINE_NO"));
		pPR->m_sCarrierID.Format(_T(""));
		pPR->m_sDeviceID.Format(_T(""));	
		pPR->m_sM_STEP.Format(_T(""));
		
		m_plnkLCNet->ProductPlanRequest(eProductPlanRequest, pPR);
		delete pPR;
		
		return 0;
	}
	
	// Modify. 110323 R0A,...  새로운 DeviceID 가 계속 추가됨...
	CString strDeviceID = pRecvGlassData.m_strDeviceID;
	CString strProductDeviceID = pCurProductPlan->m_sDeviceID;
	CString strNextDeviceID = pNextProductPlan->m_sDeviceID;
	//if (strDeviceID.GetLength() > 14)
	//{			
	strDeviceID = strDeviceID.Left(strDeviceID.GetLength()-4);
	strProductDeviceID = strProductDeviceID.Left(strProductDeviceID.GetLength()-4);
	strNextDeviceID = strNextDeviceID.Left(strNextDeviceID.GetLength()-4);

	if(strDeviceID != strProductDeviceID)
	{
		if(strDeviceID == strNextDeviceID)
		{
			m_plnkLCNet->TransferCurToEndProductPlanData();
			m_plnkLCNet->TransferNextToCurProductPlanData();
			m_plnkLCNet->m_CurProductPlan.m_nBatchState = eProductPlanBusy;
			m_plnkProductInfoData->m_iProductCount = 0;
			UpdateProductInfoData();
			::SendMessage(m_hAutoViewWnd, WM_DISP_PRODUCT_PLAN_MSG, (WPARAM)eProductPlanBusy, NULL);
			MaterialCodeInfoRequest(DEF_CUR_PRODUCT_PLAN, eMatStep_S);
			Sleep(500);
		}
		else
		{
			return 100041; // Panel 자재 오투입...			
		}			
	}
	else
	{
		if (m_plnkProductInfoData->m_iProductCount >= 0)
		{
			if(pCurProductPlan->m_nBatchState != eProductPlanBusy)
			{
				pCurProductPlan->m_nBatchState = eProductPlanBusy;
				m_plnkLCNet->ProductPlanReport(eProductPlanBatchStart, pCurProductPlan);
				::SendMessage(m_hAutoViewWnd, WM_DISP_PRODUCT_PLAN_MSG, (WPARAM)eProductPlanCreate, NULL);
			}
		}
	}
	


	return 0;
}

//110630.KKY_____
int	MTrsAutoManager::CheckProductPlanCnt()
{
	if (m_plnkLCNet->m_pReceivedPanelData->m_strDeviceID == m_plnkLCNet->m_CurProductPlan.m_sDeviceID)
	{
		// 자동 생산 계획 시작
		// 투입 지시량 도달 확인
		int iCompSize = 0;
		if (m_plnkLCNet->m_CurProductPlan.m_nBatchSizeLast != 0)
			iCompSize = m_plnkLCNet->m_CurProductPlan.m_nBatchSizeLast;
		else
			iCompSize = m_plnkLCNet->m_CurProductPlan.m_nBatchSize;

		if (m_plnkProductInfoData->m_iProductCount >= iCompSize)
		{
			//현재 생산계획을 Complete하고 생산계획을 요청한다
#ifdef DEF_PROCESS_MC_FIRST
			m_plnkLCNet->ProductPlanReport(eProductPlanBatchEnd, &m_plnkLCNet->m_CurProductPlan);
			Sleep(100);

			MPlanRequestData *pPR;
			pPR = new MPlanRequestData;
			pPR->m_nM_KIND = 0 ;
			pPR->m_sEQPID.Format(m_plnkSystemData->m_strEQPID);
			pPR->m_sLINE_NO.Format(_T("LINE_NO"));
			pPR->m_sCarrierID.Format(_T(""));
			pPR->m_sDeviceID.Format(_T(""));	
			pPR->m_sM_STEP.Format(_T(""));			
			m_plnkLCNet->ProductPlanRequest(eProductPlanRequest, pPR);
			delete pPR;
			Sleep(100);
			return ERR_DISCORD_DEVICE_ID;
#else
			//Next가 Current, Next1이 Next, Next2가 Next1....으로 Shift됨
			if (m_plnkLCNet->m_NextProductPlan.m_sDeviceID != _T("") && m_plnkLCNet->m_NextProductPlan.m_nBatchSize != 0)
			{
				m_plnkLCNet->TransferCurToEndProductPlanData();
				m_plnkLCNet->TransferNextToCurProductPlanData();
				m_plnkLCNet->m_CurProductPlan.m_nBatchState = eProductPlanBusy;
				m_plnkProductInfoData->m_iProductCount = 0;
				UpdateProductInfoData();
				::SendMessage(m_hAutoViewWnd, WM_DISP_PRODUCT_PLAN_MSG, (WPARAM)eProductPlanBusy, NULL);
#ifdef DEF_SOURCE_SYSTEM
				MaterialCodeInfoRequest(DEF_CUR_PRODUCT_PLAN, eMatStep_S);	//자재 정보를 요청함
#else
				MaterialCodeInfoRequest(DEF_CUR_PRODUCT_PLAN, eMatStep_G);	//자재 정보를 요청함
#endif
				Sleep(500);
			}
			else
			{
				return ERR_CNTOVER_PRODUCT_PLAN;
			}			
#endif
		}
	}
	else
	{
		return ERR_DISCORD_DEVICE_ID;
	}

	return 0;
}
//________________


// ProductPlan Create
int MTrsAutoManager::CreateProductPlan()
{
	if (m_plnkLCNet->m_iaProductPlanCode.GetSize() < 1)		return -1;
	if (m_plnkLCNet->m_caProductPlanBatchData.GetSize() < 1)	return -1;

	BOOL bRequestCurMCode = FALSE;
	BOOL bRequestNextMCode = FALSE;

	int iPlanSize = m_plnkLCNet->m_iaProductPlanCode.GetSize();
	int i = 0, iCnt = 0;

	//기존 Next정보를 지운다_______
	m_plnkLCNet->m_NextProductPlan.Clear();
	int iNextCnt = m_plnkLCNet->m_caNextProductPlan.GetSize();
	for (int i=0; i<iNextCnt; i++)
	{
		MProductPlanBatchData* p = (MProductPlanBatchData*)m_plnkLCNet->m_caNextProductPlan.GetAt(0);
		m_plnkLCNet->m_caNextProductPlan.RemoveAt(0);
		delete p;
	}
	//_____________________________

//	for (int i=0; i<iPlanSize; i++)
//	{
		UINT iProductPlanCode = m_plnkLCNet->m_iaProductPlanCode.GetAt(0);
		MProductPlanBatchData* cProductPlanBatchData
			= (MProductPlanBatchData*)m_plnkLCNet->m_caProductPlanBatchData.GetAt(0);
		m_plnkLCNet->m_iaProductPlanCode.RemoveAt(0);
		m_plnkLCNet->m_caProductPlanBatchData.RemoveAt(0);

		/*----- Scenario -----
		@조건 : 내려받은 BatchID가 존재할 경우에만 적용함
		
		# 투입 설비일 경우
		if) PlanOrder가 1일경우
		{
			if) 현재 생산중인 BatchID와 내려준 BatchID가 일치할 경우
				- 현재 생산중인 생산정보를 Update한다(최초생산정보 유지. BatchSize===>최종생산정보)
			else)
				-if) 현재 생산중인 생산정보가 있을경우
					현재 생산중인 생산정보를 Complete함(EndProduct에 추가)
				-현재 생산중인 생산정보를 내려준 생산정보로 대체함
		}
		else
		{
			if) 현재 생산중인 생산정보가 없을경우
				-현재 생산중인 생산정보를 내려준 생산정보로 대체함			
			else)
				내려받은 생산정보를 Next로 대체함
		}

		#공정 설비일 경우
		if) PlanOrder가 1일 경우
		{
			if) 현재 생산중인 BatchID와 내려준 BatchID가 일치할 경우
				- 현재 생산중인 생산정보를 Update한다(최초생산정보 유지. BatchSize===>최종생산정보)
			else)
				if) 현재 생산중인 생산정보가 있을경우
					Current를 Next로 대체함(이때 Next1이 Next2으로, Next2가 Next3으로....)
				else)
					현재 생산중인 생산정보를 내려준 생산정보로 대체함
		}
		else
		{
			if) 현재 생산중인 생산정보가 없을경우
				-현재 생산중인 생산정보를 내려준 생산정보로 대체함
			else
				내려받은 생산정보를 Next+1로 대체함
		}
		--------------------*/

//		if (cProductPlanBatchData->m_sBatchID.IsEmpty()) continue;

		int iPlanOrder = cProductPlanBatchData->m_nPlanOrderID;
		if (iPlanOrder == 1)
		{
			//현재 생산중인 생산정보와 받은 정보가 같으면 Update한다
			if (m_plnkLCNet->m_CurProductPlan.m_sBatchID == cProductPlanBatchData->m_sBatchID)
			{
				int iBatchState = m_plnkLCNet->m_CurProductPlan.m_nBatchState;
				int iInitSize = m_plnkLCNet->m_CurProductPlan.m_nBatchSize;
				cProductPlanBatchData->m_nBatchState = iBatchState;
				cProductPlanBatchData->m_nBatchSizeLast = cProductPlanBatchData->m_nBatchSize;//내려준 BatchSize가 최종 BatchSize가 됨
				cProductPlanBatchData->m_nBatchSize = iInitSize;	//기존에 가지고 있던 BatchSize가 최초 BatchSize가 됨
				m_plnkLCNet->m_CurProductPlan.SetData(cProductPlanBatchData);
			}
			else
			{
				//현재 생산중인 생산정보가 있을경우 Current를 End로 바꿈
				if (m_plnkLCNet->m_CurProductPlan.m_nBatchSize != 0 && m_plnkLCNet->m_CurProductPlan.m_sBatchID != "")
				{
					m_plnkLCNet->TransferCurToEndProductPlanData();
				}
				//받은정보가 Current가 됨
				m_plnkLCNet->m_CurProductPlan.SetData(cProductPlanBatchData);
				bRequestCurMCode = TRUE;	//새로운 현재 자재 정보를 요청해라
				m_plnkProductInfoData->m_iProductCount = 0;


			}
		}
		if(m_plnkLCNet->m_iPlanQty >1 && cProductPlanBatchData->m_nPlanOrderID2 == 2)
		//else
		{
			if (m_plnkLCNet->m_CurProductPlan.m_nBatchSize == 0 || m_plnkLCNet->m_CurProductPlan.m_sBatchID == "")
			{
				cProductPlanBatchData->m_nBatchState = eProductPlanCreate;
				m_plnkLCNet->m_CurProductPlan.SetData(cProductPlanBatchData);
				bRequestCurMCode = TRUE;	//새로운 현재 자재 정보를 요청해라
				m_plnkProductInfoData->m_iProductCount = 0;
			}
			else
			{
				MProductPlanBatchData* pNew = new MProductPlanBatchData;
				pNew->SetData2N1(cProductPlanBatchData);
				m_plnkLCNet->m_caNextProductPlan.Add(pNew);
				m_plnkLCNet->ManageNextProductPlanData();
				bRequestNextMCode = TRUE;	//새로운 다음 자재 정보를 요청해라
			}
		}
		if (cProductPlanBatchData != NULL)
			delete cProductPlanBatchData;	
	//}
	
	//Next 첫번째가 m_NextProductPlan이 된다
	if (m_plnkLCNet->m_caNextProductPlan.GetSize() > 0)
	{
		m_plnkLCNet->m_NextProductPlan.SetData((MProductPlanBatchData*)m_plnkLCNet->m_caNextProductPlan.GetAt(0));
	}

	UpdateProductInfoData();

	::SendMessage(m_hAutoViewWnd, WM_DISP_PRODUCT_PLAN_MSG, (WPARAM)eProductPlanCreate, NULL);

	if (TRUE == bRequestCurMCode)
	{
#ifdef DEF_SOURCE_SYSTEM
		MaterialCodeInfoRequest(DEF_CUR_PRODUCT_PLAN, eMatStep_S);
#else
		MaterialCodeInfoRequest(DEF_CUR_PRODUCT_PLAN, eMatStep_G);
#endif
	}
	if (TRUE == bRequestNextMCode)
	{
#ifdef DEF_SOURCE_SYSTEM
		MaterialCodeInfoRequest(DEF_NEXT_PRODUCT_PLAN, eMatStep_S);
#else 
		MaterialCodeInfoRequest(DEF_NEXT_PRODUCT_PLAN, eMatStep_G);
#endif
	}
	return 0;
}

// ProductPlan Update
int MTrsAutoManager::UpdateProductPlan()
{
	return 0;
}

int MTrsAutoManager::CreateMCodeInfo(MMaterialCodeInfo* pInfo)
{
	/*----- Scenario -----
	@조건 : 내려받은 DeviceID가 존재할 경우에만 적용
	if (내려받은 DeviceID와 현재생산정보 DeviceID가 일치할 경우)
	{
		if (내려받은 DeviceID와 현재 생산중인 자재정보의 DeviceID가 일치할 경우)
			;(update???)
		else
			- if (현재 자재정보가 있을경우)
				현재 자재정보 Complete. End정보로 바꿔줌
			- 현재 자재정보를 내려준 정보로 대체함
	}
	else if (내려받은 DeviceID와 Next생산정보 DeviceID가 일치할 경우)
	{
		내려받은 정보를 Next로 대체함
	}
	else
		;
	--------------------*/	

	MMaterialCodeInfo* pCurMInfo;
	MMaterialCodeInfo* pNextMInfo;
	MMaterialCodeInfo* pEndMInfo;

	if (pInfo->m_sDeviceID.IsEmpty()) return 0;
	
#ifdef DEF_SOURCE_SYSTEM
	if(pInfo->m_nM_KIND == eMatKind_TABIC)
	{
		pCurMInfo = &m_plnkLCNet->m_CurMaterialCodeInfo_S;
		pNextMInfo = &m_plnkLCNet->m_NextMaterialCodeInfo_S;
		pEndMInfo = &m_plnkLCNet->m_EndMaterialCodeInfo_S;
	}
	else if (pInfo->m_nM_KIND == eMatKind_JIG)
	{
		pCurMInfo = &m_plnkLCNet->m_CurMaterialCodeInfo_ZS;
		pNextMInfo = &m_plnkLCNet->m_NextMaterialCodeInfo_ZS;
		pEndMInfo = &m_plnkLCNet->m_EndMaterialCodeInfo_ZS;
	}
#else
	if(pInfo->m_nM_KIND == eMatKind_TABIC)
	{
		pCurMInfo = &m_plnkLCNet->m_CurMaterialCodeInfo_G;
		pNextMInfo = &m_plnkLCNet->m_NextMaterialCodeInfo_G;
		pEndMInfo = &m_plnkLCNet->m_EndMaterialCodeInfo_G;
	}
	else if (pInfo->m_nM_KIND == eMatKind_JIG)
	{
		pCurMInfo = &m_plnkLCNet->m_CurMaterialCodeInfo_ZG;
		pNextMInfo = &m_plnkLCNet->m_NextMaterialCodeInfo_ZG;
		pEndMInfo = &m_plnkLCNet->m_EndMaterialCodeInfo_ZG;
	}
#endif

	if (pInfo->m_sDeviceID == m_plnkLCNet->m_CurProductPlan.m_sDeviceID)
	{
		//if (pInfo->m_sDeviceID == pCurMInfo->m_sDeviceID)
		//	;
		//else
		{
			if (pCurMInfo->m_sDeviceID != _T(""))
			{
				if(pInfo->m_nM_KIND == eMatKind_TABIC)
				{
					m_plnkLCNet->TrsnaferCurMCodeToEndMCode();
				}
				else
					m_plnkLCNet->TrsnaferCurMCodeToEndMCodeJIG();
			}
			m_plnkLCNet->UpdateCurrentMCodePlan(pInfo);
		}
	}

	//20110813 SJ_YSB
	//else if (pInfo->m_sDeviceID == m_plnkLCNet->m_NextProductPlan.m_sDeviceID)
	if (pInfo->m_sDeviceID == m_plnkLCNet->m_NextProductPlan.m_sDeviceID)
	{
		m_plnkLCNet->UpdateNextMCodePlan(pInfo);
	}
	
	
	m_plnkProductInfoData->m_MaterialCodeInfo_S[DEF_CUR_PRODUCT_PLAN].CopyData(&m_plnkLCNet->m_CurMaterialCodeInfo_S);
	m_plnkProductInfoData->m_MaterialCodeInfo_S[DEF_NEXT_PRODUCT_PLAN].CopyData(&m_plnkLCNet->m_NextMaterialCodeInfo_S);
	m_plnkProductInfoData->m_MaterialCodeInfo_S[DEF_END_PRODUCT_PLAN].CopyData(&m_plnkLCNet->m_EndMaterialCodeInfo_S);

	m_plnkProductInfoData->m_MaterialCodeInfo_G[DEF_CUR_PRODUCT_PLAN].CopyData(&m_plnkLCNet->m_CurMaterialCodeInfo_G);
	m_plnkProductInfoData->m_MaterialCodeInfo_G[DEF_NEXT_PRODUCT_PLAN].CopyData(&m_plnkLCNet->m_NextMaterialCodeInfo_G);
	m_plnkProductInfoData->m_MaterialCodeInfo_G[DEF_END_PRODUCT_PLAN].CopyData(&m_plnkLCNet->m_EndMaterialCodeInfo_G);

	m_plnkProductInfoData->WriteMaterialCodeInfo();

	::SendMessage(m_hAutoViewWnd, WM_DISP_MATERIAL_CODEINFO, 0, 0);
	

	return 0;
}
//_______________

//110630.KKY_____
int MTrsAutoManager::MaterialCodeInfoRequest(int iPlanType, EMaterialStep eStep)
{
	//170908 Jas_SYS 자재정보 필요없음
	return 0;

	CString sDeviceID;
	MPlanRequestData *pPR = new MPlanRequestData;

	pPR->m_sCarrierID.Format(_T(" "));

	if (iPlanType == DEF_CUR_PRODUCT_PLAN)
	{
		sDeviceID = m_plnkLCNet->m_CurProductPlan.m_sDeviceID;
	}
	else
	{
		sDeviceID = m_plnkLCNet->m_NextProductPlan.m_sDeviceID;
	}
	if (sDeviceID.IsEmpty())
	{
		delete pPR;
//		MyMessageBox(_T("생산 정보의 DeviceID가 비어 있습니다. 자재정보를 요청할수 없습니다."), _T("Confirm"));
		return ERR_NO_DEVICEID_MCODE_REQUEST;
	}
	pPR->m_sDeviceID = sDeviceID;

	pPR->m_nM_KIND = eMatKind_TABIC;

	if (eStep == eMatStep_S)
		pPR->m_sM_STEP = DEF_MCODE_STEP_S;
	else
		pPR->m_sM_STEP = DEF_MCODE_STEP_G;

	m_plnkLCNet->ProductPlanRequest(eMaterialInfoRequest, pPR);


	pPR->m_nM_KIND = eMatKind_JIG;

	if (eStep == eMatStep_S)
		pPR->m_sM_STEP = "JIGS";
	else
		pPR->m_sM_STEP ="JIGG";

	m_plnkLCNet->ProductPlanRequest(eMaterialInfoRequest, pPR);

/*
	//임시.For Test___________
	//sDeviceID = LJ12-345678;
	CString strRcv;
	strRcv.Format(_T("@MC##1##%s##%d##%s##3##M_CODE_1##M_CODE_2##M_CODE_3$"), pPR->m_sDeviceID, pPR->m_nM_KIND, pPR->m_sM_STEP);
	m_plnkLCNet->AnaysisMessage_SelfFormat(strRcv);
	//________________________
*/
	delete pPR;

	return 0;
}
//____________________________


//110624.KKY.Add________
int MTrsAutoManager::CheckExistMCode(int iPlanCode, EMaterialStep eStep, CString strMCode)
{
	int iResult = 0;

	ASSERT(iPlanCode == DEF_CUR_PRODUCT_PLAN ||
			iPlanCode == DEF_NEXT_PRODUCT_PLAN ||
			iPlanCode == DEF_END_PRODUCT_PLAN);

	MMaterialCodeInfo* pMCodeInfo;

	if (iPlanCode == DEF_CUR_PRODUCT_PLAN)
	{
		if (eStep == eMatStep_S)
			pMCodeInfo = &m_plnkLCNet->m_CurMaterialCodeInfo_S;
		else
			pMCodeInfo = &m_plnkLCNet->m_CurMaterialCodeInfo_G;
	}
	else if (iPlanCode == DEF_END_PRODUCT_PLAN)
	{
		if (eStep == eMatStep_S)
			pMCodeInfo = &m_plnkLCNet->m_EndMaterialCodeInfo_S;
		else
			pMCodeInfo = &m_plnkLCNet->m_EndMaterialCodeInfo_G;
	}
	else
	{
		if (eStep == eMatStep_S)
			pMCodeInfo = &m_plnkLCNet->m_NextMaterialCodeInfo_S;
		else
			pMCodeInfo = &m_plnkLCNet->m_NextMaterialCodeInfo_G;
	}

	if (pMCodeInfo->m_sDeviceID.IsEmpty())
		return ERR_MCODE_NOT_EXIST;

	strMCode.TrimLeft();
	strMCode.TrimRight();
	strMCode.MakeUpper();

	CString strTemp;
	int nCnt = pMCodeInfo->m_asM_CODE.GetSize();
	for (int i=0; i<nCnt; i++)
	{
		strTemp = pMCodeInfo->m_asM_CODE.GetAt(i);
		strTemp.TrimLeft();
		strTemp.TrimRight();
		strTemp.MakeUpper();
		if (strTemp.Compare(strMCode) == 0)
			return ERR_MCODE_NOT_EXIST;
//			return generateErrorCode(400092);
	}

	return 0;
}

	// 생산 계획 저장
void MTrsAutoManager::UpdateProductInfoData()
{
	m_plnkProductInfoData->m_CurProductBatchInfo.SetData(&m_plnkLCNet->m_CurProductPlan);
	int i = 0;
	int iCnt = 0;
	for (int i=0; i<DEF_MAX_PRODUCT_PLAN_CNT; i++)
	{
		m_plnkProductInfoData->m_NextProductBatchInfo[i].Clear();
		m_plnkProductInfoData->m_EndProductBatchInfo[i].Clear();
	}
	iCnt = m_plnkLCNet->m_caNextProductPlan.GetSize();
	for (int i=0; i<iCnt; i++)
	{
		MProductPlanBatchData* p = (MProductPlanBatchData*)m_plnkLCNet->m_caNextProductPlan.GetAt(i);
		m_plnkProductInfoData->m_NextProductBatchInfo[i].SetData(p);
	}
	iCnt = m_plnkLCNet->m_caEndProductPlan.GetSize();
	for (int i=0; i<iCnt; i++)
	{
		MProductPlanBatchData* p = (MProductPlanBatchData*)m_plnkLCNet->m_caEndProductPlan.GetAt(i);
		m_plnkProductInfoData->m_EndProductBatchInfo[i].SetData(p);
	}

	m_plnkProductInfoData->WriteProductPlan();
}

void MTrsAutoManager::SetLastPanelCurProductPlan(BOOL bLast)
{
	m_bLastPanelCurProductPlan = bLast;
}

BOOL MTrsAutoManager::GetLastPanelCurProductPlan()
{
	return m_bLastPanelCurProductPlan;
}

//Panel 배출시 현재 생산정보의 마지막 Panel이면 자재정보(MCode)를 Transfer시킨다.
int	MTrsAutoManager::CheckLastPanelMCode()
{
	//170908 Jas_SYS 필요없음.
	return 0;
	if (TRUE == m_bLastPanelCurProductPlan)
	{
		m_plnkLCNet->m_EndMaterialCodeInfo_S.CopyData(&m_plnkLCNet->m_CurMaterialCodeInfo_S);
		m_plnkLCNet->m_EndMaterialCodeInfo_G.CopyData(&m_plnkLCNet->m_CurMaterialCodeInfo_G);
		if (m_plnkLCNet->m_NextMaterialCodeInfo_S.m_sDeviceID != "")
		{
			m_plnkLCNet->m_CurMaterialCodeInfo_S.CopyData(&m_plnkLCNet->m_NextMaterialCodeInfo_S);
			m_plnkLCNet->m_NextMaterialCodeInfo_S.ResetData();
		}
		if (m_plnkLCNet->m_NextMaterialCodeInfo_G.m_sDeviceID != "")
		{
			m_plnkLCNet->m_CurMaterialCodeInfo_G.CopyData(&m_plnkLCNet->m_NextMaterialCodeInfo_G);
			m_plnkLCNet->m_NextMaterialCodeInfo_G.ResetData();
		}
		::SendMessage(m_hAutoViewWnd, WM_DISP_MATERIAL_CODEINFO, NULL, NULL);

		//다음 ProductPlan이 있으면 MCode를 요청한다
		MPlanRequestData *pPR = new MPlanRequestData;
		pPR->m_sLINE_NO.Format(_T("LINE_NO"));
		pPR->m_sEQPID.Format(m_plnkSystemData->m_strEQPID);
		pPR->m_sCarrierID.Format(_T(" "));
		CString sDeviceID = m_plnkLCNet->m_NextProductPlan.m_sDeviceID;
		if (sDeviceID.IsEmpty())
		{
			delete pPR;
			return 0;
		}
		pPR->m_sDeviceID = sDeviceID;
		pPR->m_nM_KIND = eMatKind_TABIC;
#ifdef DEF_SOURCE_SYSTEM
		pPR->m_sM_STEP = DEF_MCODE_STEP_S;
#else
		pPR->m_sM_STEP = DEF_MCODE_STEP_G;
#endif
		m_plnkLCNet->ProductPlanRequest(eMaterialInfoRequest, pPR);

		delete pPR;
		m_bLastPanelCurProductPlan = FALSE;
	}
	return 0;
}
//______________________
//111022 sj_kjs
void MTrsAutoManager::IonaizerBlowOnOff(BOOL bSet)
{
	if (bSet)
	{
		m_plnkIO->OutputOff(OUT_IONAIZER_BLOW_ONOFF);
	}
	else
	{
		m_plnkIO->OutputOn(OUT_IONAIZER_BLOW_ONOFF);
	}
}
BOOL MTrsAutoManager::IsIonaizerBlowOnOff()
{
	return m_plnkIO->IsOn(OUT_IONAIZER_BLOW_ONOFF);
}
//_______________________________________________

//20111028 SJ_HJG
BOOL MTrsAutoManager::WritePanelIDLog(CString strMsg)
{

	FILE* fsource;
	//CFileFind fn;
	MFileUtil FileUtil;
	CString fname;

	CTime tmCurr = CTime::GetCurrentTime();
 
	strMsg = tmCurr.Format(_T("[%m/%d-%H:%M:%S]")) + strMsg;
	fname.Format(_T("..\\Log\\PanelID\\")); 
	fname = fname + tmCurr.Format(_T("PanelIDLog_%y%m%d"))  + _T(".log");

	FileUtil.MakeDir(fname,FALSE); // 로깅 디렉토리가 존재하지 않을 경우 Directory를 만든다.

	//LKH_20090130 : Log Unicode Writing
	if ((fsource = _wfopen(fname, _T("ab+,ccs=UNICODE"))) == NULL)
	{
		//Log 파일을 만들지 못 했습니다.
//		MyMessageBox(MY_MESSAGE_BOX, 64004, _T("File Write Error!"), M_ICONERROR);
		return FALSE;
	}

	//현재 발생 로그 내용 기록
	fwprintf(fsource, _T("%s\r\n"), strMsg.GetBuffer());

	fclose(fsource);


	return TRUE;
}
//__________________

// 2011.11.05 Park, YK - //ELLAS_111103
//ELLAS_110630 전후 설비 물류 상태 확인
void MTrsAutoManager::checkMelecFlowState()
{
	m_bNewUpperSendAble = m_plnkMelsecIF->IsOnUpperEqBit(eSendAble);
	if (m_bNewUpperSendAble != m_bOldUpperSendAble)
	{	
		if (m_bNewUpperSendAble == TRUE)
			m_plnkLCNet->EqSpecialStateReport(eUpperSendAbleStart);
		else
			m_plnkLCNet->EqSpecialStateReport(eUpperSendAbleEnd);

		m_bOldUpperSendAble = m_bNewUpperSendAble;
	}

	m_bNewLowerReceiveAble = m_plnkMelsecIF->IsOnLowerEqBit(eReceiveAble);
	if (m_bNewLowerReceiveAble != m_bOldLowerReceiveAble)
	{	
		if (m_bNewLowerReceiveAble == TRUE)
			m_plnkLCNet->EqSpecialStateReport(eLowerReceiveAbleStart);
		else
			m_plnkLCNet->EqSpecialStateReport(eLowerReceiveAbleEnd);

		m_bOldLowerReceiveAble = m_bNewLowerReceiveAble;
	}
}

//ELLAS_110712 전설비 정지 확인, Network상태 확인
void MTrsAutoManager::checkUpperEquipPause()
{
	m_lNewTick = GetTickCount();
	if (m_lNewTick>m_lOldTick+10000)
	{
		short bState;
		m_plnkMelsecIF->GetMachinePause_ToUpperEqBit(&bState);
		if (bState)
		{
			m_plnkLCNet->EqSpecialStateReport(eUpperEquipPauseStart, (EMaterialType)0);
		}
		else
		{
			m_plnkLCNet->EqSpecialStateReport(eUpperEquipPauseEnd, (EMaterialType)0);
		}

		m_plnkMelsecIF->GetMachinePause_ToLowerEqBit(&bState);
		if (bState)
		{
			m_plnkLCNet->EqSpecialStateReport(eUpperEquipPauseStart, (EMaterialType)1);
		}
		else
		{
			m_plnkLCNet->EqSpecialStateReport(eUpperEquipPauseEnd, (EMaterialType)1);
		}

		m_lOldTick = m_lNewTick;
	}
	else if (m_lNewTick<m_lOldTick)
	{
		m_lOldTick = m_lNewTick;
	}
}

//120111.KMS____________
void MTrsAutoManager::SetModelChangeAlarmReport(BOOL bChange)
{
	m_bModelChangeFlg = bChange;
}
BOOL MTrsAutoManager::GetModelChangeAlarmReport()
{
	return m_bModelChangeFlg;
}

void MTrsAutoManager::SetMountAutoChange(BOOL bChange)
{
	m_bMountAutoChangeFlg = bChange;
}

BOOL MTrsAutoManager::GetMountAutoChange()
{
	return m_bMountAutoChangeFlg;
}
//____________________
//20111205 SJ_HJG
BOOL MTrsAutoManager::WriteAutoAlignLog(CString strMsg)
{
	//KJS NSMC System 생성이 완료되기 전에는 로그 작성하지 않음
	if (TRUE != MOlbSystemPre.m_bSystemInitialized)
		return TRUE;

	//::EnterCriticalSection(&m_csAutoAlignLog);
	
	FILE* fsource;
	CFileFind fn;
	CString fname;
//	WCHAR buf[500];
//	size_t strSize;

	CTime tmCurr = CTime::GetCurrentTime();
	strMsg = tmCurr.Format(_T("[%m/%d-%H:%M:%S]")) + strMsg;
	fname = _T("..\\Log\\AutoAlignLog\\AutoAlignLog") + tmCurr.Format(_T("%m%d")) + _T(".txt");
	
	//LKH_20090130 : Log Unicode Writing
	if ((fsource = _wfopen(fname, _T("ab+,ccs=UNICODE"))) == NULL)
	{
	//	::LeaveCriticalSection(&m_csAutoAlignLog);
		return FALSE;
	}
	//현재 발생 로그 내용 기록
	fwprintf(fsource, _T("%s\r\n"), strMsg.GetBuffer());

	fclose(fsource);

	//::LeaveCriticalSection(&m_csAutoAlignLog);
	return TRUE;
}

//120228.kms_________________
void MTrsAutoManager::StartChangeModelTimer()
{
	m_tChangeModelTimer.StartTimer();
}

//_________________________________________________________________________________________________
// 091028 공정 Parameter 전송
int MTrsAutoManager::MeasureProcessParameter()
{
	return 0;
	/*
	int iResult = 0;
	int dIonizerState;

	int	i;
	// Heater Temp
	for (int i=0; i<1; i++)
	{
		//120508.KMS____________
		if(m_plnkPanelAligner->IsIonizerState())
			dIonizerState = 1;
		else
			dIonizerState = 0;
		//______________________

		m_iMeasProcessData[i] = dIonizerState;
	}

	return iResult;
	*/
}


//120515.KMS____________
void MTrsAutoManager::SetAssemReport(BOOL bASReport)
{
	m_bAssemReportFlg = bASReport;
}

BOOL MTrsAutoManager::GetAssemReport()
{
	return m_bAssemReportFlg;
}
//______________________
//20121004 SJ_HJG 횡전개
void MTrsAutoManager::SetTabEndMarkDistance(int iWorkGroupNo, double dTabEndMarkDistance)
{
	if (iWorkGroupNo == 0)
	{
		//m_dTabEndMarkDistance[0] = dTabEndMarkDistance;
		m_dTabEndMarkDistance1 = dTabEndMarkDistance;
	}
	else
	{
		//m_dTabEndMarkDistance[1] = dTabEndMarkDistance;
		m_dTabEndMarkDistance2 = dTabEndMarkDistance;
	}
}

double MTrsAutoManager::GetTabEndMarkDistance(int iInstanceNo)
{
	double dTabEndMarkDistance = 0.0;
	if (iInstanceNo == 0)
	{
		//dTabEndMarkDistance = m_dTabEndMarkDistance[0];
		dTabEndMarkDistance = m_dTabEndMarkDistance1;
	}
	else
	{
		//dTabEndMarkDistance = m_dTabEndMarkDistance[1];
		dTabEndMarkDistance = m_dTabEndMarkDistance2;
	}

	return dTabEndMarkDistance;
}

//@DoorLock_________________________________
//131111. SJ_YTH
BOOL MTrsAutoManager::IsFrontKeyAutoMode()
{
	return m_plnkIO->IsOn(IN_SAFETY_KEY1_AUTO);
}

BOOL MTrsAutoManager::IsRearKeyAutoMode()
{
	return m_plnkIO->IsOn(IN_SAFETY_KEY2_AUTO);	
}

//150406 SJ_YSH
BOOL MTrsAutoManager::IsFrontMaterialKeyAutoMode()
{
	return m_plnkIO->IsOn(IN_SAFETY_KEY_F_MATERIAL);	
}

BOOL MTrsAutoManager::IsRearMaterialKeyAutoMode()
{
	return m_plnkIO->IsOn(IN_SAFETY_KEY_R_MATERIAL);	
}
//____________

int	MTrsAutoManager::LockAllDoor()
{
	//return (m_plnkIO->OutputOff(OUT_ALL_DOOR_LOCK_OPEN));
	return FALSE;
}

int	MTrsAutoManager::LockFrontDoor()
{
	return (m_plnkIO->OutputOff(OUT_FRONT_DOOR_LOCK_OPEN));
}

int	MTrsAutoManager::LockRearDoor()
{
	return (m_plnkIO->OutputOff(OUT_REAR_DOOR_LOCK_OPEN));
}

BOOL MTrsAutoManager::IsFrontMeterialKeyAutoMode()
{
	return m_plnkIO->IsOn(IN_SAFETY_KEY_F_MATERIAL);
}

BOOL MTrsAutoManager::IsRearMeterialKeyAutoMode()
{
	return m_plnkIO->IsOn(IN_SAFETY_KEY_R_MATERIAL);
}
int	MTrsAutoManager::LockMaterialFrontDoor()
{
	return m_plnkIO->OutputOff(OUT_FRONT_METERIAL_DOOR_LOCK_OPEN);
}

int MTrsAutoManager::LockMaterialRearDoor()
{
	return m_plnkIO->OutputOff(OUT_REAR_METERIAL_DOOR_LOCK_OPEN);
}

int MTrsAutoManager::UnlockMaterialFrontDoor()
{
	//Unlock할수 있는 조건
	//1. 설비 Manual 상태이어야 함
	if (GetOPMode() != MANUAL_MODE)
	{
		return generateErrorCode(400130);
	}

	//2. KeyManual 상태이어야 함
	if (TRUE == IsFrontMeterialKeyAutoMode())
	{
		return generateErrorCode(400132);
	}

	BOOL bAxisStop[DEF_AXIS_MAX_AXIS] = {FALSE, };
	//3. 모든 Motor 정지상태 이어야 함
	DWORD sTime = GetTickCount();
	while(1)
	{
		Sleep(15);
		if (TRUE == IsAllMotorStop(bAxisStop))
			break;
		if (GetTickCount() - sTime > 30.0)
		{
			return generateErrorCode(400131);
		}
	}

	return m_plnkIO->OutputOn(OUT_FRONT_METERIAL_DOOR_LOCK_OPEN);
}

int MTrsAutoManager::UnlockMeterialRearDoor()
{
	//Unlock할수 있는 조건
	//1. 설비 Manual 상태이어야 함
	if (GetOPMode() != MANUAL_MODE)
	{
		return generateErrorCode(400130);
	}	

	//2. KeyManual 상태이어야 함
	if (TRUE == IsRearMeterialKeyAutoMode())
	{
		return generateErrorCode(400133);
	}

	BOOL bAxisStop[DEF_AXIS_MAX_AXIS] = {FALSE, };
	//3. 모든 Motor 정지상태 이어야 함
	DWORD sTime = GetTickCount();
	while(1)
	{
		Sleep(15);
		if (TRUE == IsAllMotorStop(bAxisStop))
			break;
		if (GetTickCount() - sTime > 30.0)
		{
			return generateErrorCode(400131);
		}
	}
	return m_plnkIO->OutputOn(OUT_REAR_METERIAL_DOOR_LOCK_OPEN);
}

int MTrsAutoManager::UnlockAllDoor()
{
	//Unlock할수 있는 조건
	//1. 설비 Manual 상태이어야 함
	if (GetOPMode() != MANUAL_MODE)
	{
		return generateErrorCode(400130);
	}	

	//2. KeyManual 상태이어야 함
	if (TRUE == IsFrontKeyAutoMode()		
		&& TRUE == IsRearKeyAutoMode())
	{
		return generateErrorCode(400133);
	}

	BOOL bAxisStop[DEF_AXIS_MAX_AXIS] = {FALSE, };
	//3. 모든 Motor 정지상태 이어야 함
	DWORD sTime = GetTickCount();
	while(1)
	{
		Sleep(15);
		if (TRUE == IsAllMotorStop(bAxisStop))
			break;
		if (GetTickCount() - sTime > 30.0)
		{
			return generateErrorCode(400131);
		}
	}
	//return (m_plnkIO->OutputOn(OUT_ALL_DOOR_LOCK_OPEN));
	return FALSE;
}
//_________________________________//

int MTrsAutoManager::UnlockFrontDoor()
{
	//Unlock할수 있는 조건
	//1. 설비 Manual 상태이어야 함
	if (GetOPMode() != MANUAL_MODE)
	{
		return generateErrorCode(400130);
	}	

	//2. KeyManual 상태이어야 함
	if (TRUE == IsFrontKeyAutoMode())	 
	{
		return generateErrorCode(400133);
	}

	BOOL bAxisStop[DEF_AXIS_MAX_AXIS] = {FALSE, };
	//3. 모든 Motor 정지상태 이어야 함
	DWORD sTime = GetTickCount();
	while(1)
	{
		Sleep(15);
		if (TRUE == IsAllMotorStop(bAxisStop))
			break;
		if (GetTickCount() - sTime > 30.0)
		{
			return generateErrorCode(400131);
		}
	}

	return (m_plnkIO->OutputOn(OUT_FRONT_DOOR_LOCK_OPEN));
}
//_________________________________//
int MTrsAutoManager::UnlockRearDoor()
{
	//Unlock할수 있는 조건
	//1. 설비 Manual 상태이어야 함
	if (GetOPMode() != MANUAL_MODE)
	{
		return generateErrorCode(400130);
	}	

	//2. KeyManual 상태이어야 함
	if (TRUE == IsRearKeyAutoMode())	 
	{
		return generateErrorCode(400133);
	}

	BOOL bAxisStop[DEF_AXIS_MAX_AXIS] = {FALSE, };
	//3. 모든 Motor 정지상태 이어야 함
	DWORD sTime = GetTickCount();
	while(1)
	{
		Sleep(15);
		if (TRUE == IsAllMotorStop(bAxisStop))
			break;
		if (GetTickCount() - sTime > 30.0)
		{
			return generateErrorCode(400131);
		}
	}
	return (m_plnkIO->OutputOn(OUT_REAR_DOOR_LOCK_OPEN));
}
//_________________________________//
BOOL MTrsAutoManager::IsAllMotorStop(BOOL bMotorStop[DEF_AXIS_MAX_AXIS])
{
	BOOL bAxisDone = TRUE;
	for (int i=0; i<DEF_AXIS_MAX_AXIS; i++)
	{
		if (i == DEF_AXIS_SERCOS_FEEDER_REEL_T
			|| i == DEF_AXIS_SERCOS_R_FEEDER_REEL_T
			|| i == DEF_AXIS_SERCOS_FEEDER_SPROCKET1_T
			|| i == DEF_AXIS_SERCOS_FEEDER_SPROCKET2_T
			|| i == DEF_AXIS_SERCOS_R_FEEDER_SPROCKET1_T
			|| i == DEF_AXIS_SERCOS_R_FEEDER_SPROCKET2_T
			#ifdef DEF_1ST_EQ
			|| i == DEF_AXIS_SERCOS_TRANSFER_CENTER_2 //170929 JSh Gear
			|| i == DEF_AXIS_SERCOS_TRANSFER_OUT_2//170929 JSh Gear
			#endif
			|| i == DEF_AXIS_SERCOS_TRANSFER_IN_2//170929 JSh Gear
			)
		{
			bMotorStop[i] = TRUE;
			continue;
		}

		//@		bMotorStop[i] = m_plnkMotion[i]->IsAxisDone();
		if (MOlbSystemPre.IsSkipAxis(i) || m_plnkMotion[i]->IsAmpEnable() == FALSE)
			bMotorStop[i] = TRUE;
		else
			bMotorStop[i] = m_plnkMotion[i]->IsMotionDone();
		bAxisDone &= bMotorStop[i];
	}
	return bAxisDone;
}

//@___________________________

//#pragma message(__LOC__ "아래 MelsecBit및 IO번지 확인해야 함")

BOOL MTrsAutoManager::IsPanelEmpty_PrevMCUnload()
{
	return m_plnkMelsecIF->IsOnUpperEqBit(eReserved5_LowerEqBit);
}

BOOL MTrsAutoManager::IsPanelEmpty_NextMCLoad()
{
#ifdef DEF_GATE_SYSTEM
	return m_plnkMelsecIF->IsOnLowerEqBit(eReserved3_UpperEqBit);
#else
	return m_plnkMelsecIF->IsOnLowerEqBit(eReserved3_UpperEqBit);
//@			&& m_plnkMelsecIF->IsOnLowerEqBit(eReserved1_UpperEqBit);
#endif
}

void MTrsAutoManager::SetPanelEmptyToPrevMC_In_MyLoading(BOOL bEmpty)
{
	m_plnkMelsecIF->SetUpperEqBit(eReserved3_UpperEqBit, bEmpty);
}

void MTrsAutoManager::SetPanelEmptyToPrevMC_In_MyWorking(BOOL bEmpty)
{
	m_plnkMelsecIF->SetUpperEqBit(eReserved4_UpperEqBit, bEmpty);
}

void MTrsAutoManager::SetPanelEmptyToNextMCLoad(BOOL bEmpty)
{
	m_plnkMelsecIF->SetLowerEqBit(eReserved5_LowerEqBit, bEmpty);
}

BOOL MTrsAutoManager::IsDoorClose_PrevMCUnload()
{
	return m_plnkIO->IsOn(m_rgusUpperIN[eStageMoveInhibit]);
}

void MTrsAutoManager::SetDoorCloseToPrevMCUnload(BOOL bDoorClose)
{
	if (TRUE == bDoorClose)
		m_plnkIO->OutputOn(m_rgusUpperOUT[eStageMoveInhibit]);
	else
		m_plnkIO->OutputOff(m_rgusUpperOUT[eStageMoveInhibit]);
}

BOOL MTrsAutoManager::IsDoorClose_NextMCLoad()
{
	return m_plnkIO->IsOn(m_rgusLowerIN[eStageMoveInhibit]);
}

//170928 JSH.s
BOOL MTrsAutoManager::IsOnPIO_PrevMC(EIfIOAddr eIfIO)
{
	return m_plnkIO->IsOn(m_rgusUpperIN[eIfIO]);
}

BOOL MTrsAutoManager::IsOffPIO_PrevMC(EIfIOAddr eIfIO)
{
	return m_plnkIO->IsOff(m_rgusUpperIN[eIfIO]);
}

BOOL MTrsAutoManager::IsOnPIO_NextMC(EIfIOAddr eIfIO)
{
	return m_plnkIO->IsOn(m_rgusLowerIN[eIfIO]);
}

BOOL MTrsAutoManager::IsOffPIO_NextMC(EIfIOAddr eIfIO)
{
	return m_plnkIO->IsOff(m_rgusLowerIN[eIfIO]);
}
//170928 JSH.e

void MTrsAutoManager::SetDoorCloseToNextMCLoad(BOOL bDoorClose)
{
	if (TRUE == bDoorClose)
		m_plnkIO->OutputOn(m_rgusLowerOUT[eStageMoveInhibit]);
	else
		m_plnkIO->OutputOff(m_rgusLowerOUT[eStageMoveInhibit]);
}

BOOL MTrsAutoManager::IsEnableToMovePrevMCWithPanel()
{
	BOOL bEnable = TRUE;
	bEnable = IsPanelEmpty_PrevMCUnload() && IsDoorClose_PrevMCUnload();
	return bEnable;
}

BOOL MTrsAutoManager::IsEnableToMoveNextMCWithPanel()
{
	BOOL bEnable = TRUE;
#ifndef DEF_SETUP
	bEnable = IsPanelEmpty_NextMCLoad() && IsDoorClose_NextMCLoad();
#endif
	return bEnable;
}
//@___________________________

BOOL MTrsAutoManager::IsDoorOpen_AOC()
{
	BOOL bAOCDoorOpen;
	bAOCDoorOpen = (FALSE == m_plnkMelsecAOCIF->IsOnUpperEqBit(eReserved5_UpperEqBit, 0, TRUE));

	return bAOCDoorOpen;
}
//131029. SJ_YTH
void MTrsAutoManager::SetMeasureProcessData(EWorkingSide eWorkSide,int iTabNo,double dAlignX,double dAlignY)
{	
#ifdef DEF_SOURCE_SYSTEM
	int iMaxTabQty = MOlbSystemPre.GetTabData()->m_iXuTabQty;
	if(eWorkSide == WORKING_SIDE_X_UP)
	{
			m_dMeasProcessData[iTabNo] = dAlignX;
			m_dMeasProcessData[iTabNo + iMaxTabQty] = dAlignY;
	}
	else
	{
			m_dMeasProcessData[iTabNo + (iMaxTabQty * 2)] = dAlignX;
			m_dMeasProcessData[iTabNo + (iMaxTabQty * 3)] = dAlignY;
	}

#else
	int iMaxTabQty = MOlbSystemPre.GetTabData()->m_iYlTabQty;
	if(eWorkSide == WORKING_SIDE_Y_LEFT)
	{
			m_dMeasProcessData[iTabNo] = dAlignX;
			m_dMeasProcessData[iTabNo + iMaxTabQty] = dAlignY;
	}
	else
	{
			m_dMeasProcessData[iTabNo + (iMaxTabQty * 2)] = dAlignX;
			m_dMeasProcessData[iTabNo + (iMaxTabQty * 3)] = dAlignY;
	}
#endif
}
//_____________________

void MTrsAutoManager::ProcessParamReport()
{
	int i = 0;
	int iMaxTab;
	MProcessParamInfo	pParam;
	MProcessParamInfo	pParamAOC;
	CString				strPanelID;
	CString				strDeviceID;
	int iIndex = 0;

	// 091031 Key Parameter 항목에 DeviceID와 ModelName 추가됨
	strPanelID = GetGlassID(DEF_PANEL_ALIGNER_PANEL);
	strPanelID = strPanelID + "##" + m_pGlassData[DEF_PANEL_ALIGNER_PANEL]->m_strDeviceID;
//	strPanelID = strPanelID + "##" + m_plnkSystemData->m_strModelFileName;
	strPanelID = strPanelID + "##" + m_plnkSystemData->m_strCurrentDeviceID;

#ifdef DEF_SOURCE_SYSTEM
	//pParam.m_iDataCount = (MOlbSystemPre.GetTabData()->m_iXuTabQty * 4 );
	pParam.m_iDataCount = (MOlbSystemPre.GetTabData()->m_iXuTabQty * 18);
	iMaxTab = MOlbSystemPre.GetTabData()->m_iXuTabQty;

	//20131115 SJ_HJG
	for (int i=0; i < iMaxTab; i++)
	{
		pParam.m_rgsProcessParam[i].m_bUseParam = TRUE;
		
		if(MOlbSystemPre.GetTabData()->m_bUseXuTab[i] == FALSE)
		{
			pParam.m_rgsProcessParam[i].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + iMaxTab].m_bUseParam = FALSE;

			pParam.m_rgsProcessParam[i + (iMaxTab *4)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *5)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *6)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *7)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *8)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *9)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *10)].m_bUseParam = FALSE;
		}

		if(MOlbSystemPre.GetTabData()->m_bUseXdTab[i] == FALSE)
		{
			pParam.m_rgsProcessParam[i + (iMaxTab *2)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *3)].m_bUseParam = FALSE;

			pParam.m_rgsProcessParam[i + (iMaxTab *11)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *12)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *13)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *14)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *15)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *16)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *17)].m_bUseParam = FALSE;
		}
	}
	

	////XU 변...
	for (int i=0; i < iMaxTab; i++)
	{
		// Parameter 이름
		pParam.m_rgsProcessParam[i].m_strParamName.Format(_T("Xu_AlignX_%02d"), i + 1 ); 
		// Parameter 설정 값
		pParam.m_rgsProcessParam[i].m_dSettingValue = m_plnkSystemData->m_dTabXCheck;		
		// Parameter 측정 값
		pParam.m_rgsProcessParam[i].m_dMeasureValue = m_dMeasProcessData[i];
	
		// Parameter 이름
		pParam.m_rgsProcessParam[i + iMaxTab].m_strParamName.Format(_T("Xu_AlignY_%02d"), i + 1 ); 
		// Parameter 설정 값
		pParam.m_rgsProcessParam[i + iMaxTab].m_dSettingValue = m_plnkSystemData->m_dTabYCheck;		
		// Parameter 측정 값
		pParam.m_rgsProcessParam[i + iMaxTab].m_dMeasureValue = m_dMeasProcessData[i + iMaxTab];
	
		// Parameter 이름
		pParam.m_rgsProcessParam[i + (iMaxTab * 2)].m_strParamName.Format(_T("Xd_AlignX_%02d"), i + 1 ); 
		// Parameter 설정 값
		pParam.m_rgsProcessParam[i + (iMaxTab * 2)].m_dSettingValue = m_plnkSystemData->m_dTabXCheck;		
		// Parameter 측정 값
		pParam.m_rgsProcessParam[i + (iMaxTab * 2)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 2)];
	
		// Parameter 이름
		pParam.m_rgsProcessParam[i + (iMaxTab * 3)].m_strParamName.Format(_T("Xd_AlignY_%02d"), i+ 1 ); 
		// Parameter 설정 값
		pParam.m_rgsProcessParam[i + (iMaxTab * 3)].m_dSettingValue = m_plnkSystemData->m_dTabYCheck;		
		// Parameter 측정 값
		pParam.m_rgsProcessParam[i + (iMaxTab * 3)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 3)];

		//Inspection Mount Head Down
		pParam.m_rgsProcessParam[i + (iMaxTab * 4)].m_strParamName.Format(_T("Xu_Tab%02d_IMHD"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 4)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 4)];
		pParam.m_rgsProcessParam[i + (iMaxTab * 4)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 4)];


		//Inspection Mount Mark Recognition
		pParam.m_rgsProcessParam[i + (iMaxTab * 5)].m_strParamName.Format(_T("Xu_Tab%02d_IMMR"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 5)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 5)];
		pParam.m_rgsProcessParam[i + (iMaxTab * 5)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 5)];

		//Inspection Mount Head Up
		pParam.m_rgsProcessParam[i + (iMaxTab * 6)].m_strParamName.Format(_T("Xu_Tab%02d_IMMU"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 6)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 6)];
		pParam.m_rgsProcessParam[i + (iMaxTab * 6)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 6)];

		//Mount Bonding Pos Move
		pParam.m_rgsProcessParam[i + (iMaxTab * 7)].m_strParamName.Format(_T("Xu_Tab%02d_MBPM"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 7)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 7)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 7)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 7)];

		//Bonding Mount Head Down
		pParam.m_rgsProcessParam[i + (iMaxTab * 8)].m_strParamName.Format(_T("Xu_Tab%02d_BMHD"), i+ 1 ); 		
		pParam.m_rgsProcessParam[i + (iMaxTab * 8)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 8)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 8)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 8)];

		// Mount Bonding Time
		pParam.m_rgsProcessParam[i + (iMaxTab * 9)].m_strParamName.Format(_T("Xu_Tab%02d_MBT"), i+ 1 ); 		
		pParam.m_rgsProcessParam[i + (iMaxTab * 9)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 9)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 9)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 9)];

		//Bonding Mount Head Down
		pParam.m_rgsProcessParam[i + (iMaxTab * 10)].m_strParamName.Format(_T("Xu_Tab%02d_BMHU"), i+ 1 ); 		
		pParam.m_rgsProcessParam[i + (iMaxTab * 10)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 10)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 10)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 10)];

		//Inspection Mount Head Down
		pParam.m_rgsProcessParam[i + (iMaxTab * 11)].m_strParamName.Format(_T("Xd_Tab%02d_IMHD"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 11)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 11)];
		pParam.m_rgsProcessParam[i + (iMaxTab * 11)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 11)];

		//Inspection Mount Mark Recognition
		pParam.m_rgsProcessParam[i + (iMaxTab * 12)].m_strParamName.Format(_T("Xd_Tab%02d_IMMR"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 12)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 12)];
		pParam.m_rgsProcessParam[i + (iMaxTab * 12)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 12)];

		//Inspection Mount Head Up
		pParam.m_rgsProcessParam[i + (iMaxTab * 13)].m_strParamName.Format(_T("Xd_Tab%02d_IMMU"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 13)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 13)];
		pParam.m_rgsProcessParam[i + (iMaxTab * 13)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 13)];

		//Mount Bonding Pos Move
		pParam.m_rgsProcessParam[i + (iMaxTab * 14)].m_strParamName.Format(_T("Xd_Tab%02d_MBPM"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 14)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 14)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 14)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 14)];

		//Bonding Mount Head Down
		pParam.m_rgsProcessParam[i + (iMaxTab * 15)].m_strParamName.Format(_T("Xd_Tab%02d_BMHD"), i+ 1 ); 		
		pParam.m_rgsProcessParam[i + (iMaxTab * 15)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 15)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 15)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 15)];

		// Mount Bonding Time
		pParam.m_rgsProcessParam[i + (iMaxTab * 16)].m_strParamName.Format(_T("Xd_Tab%02d_MBT"), i+ 1 ); 		
		pParam.m_rgsProcessParam[i + (iMaxTab * 16)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 16)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 16)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 16)];

		//Bonding Mount Head Down
		pParam.m_rgsProcessParam[i + (iMaxTab * 17)].m_strParamName.Format(_T("Xd_Tab%02d_BMHU"), i+ 1 ); 		
		pParam.m_rgsProcessParam[i + (iMaxTab * 17)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 17)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 17)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 17)];
	}

#else // DEF_GATE_SYSTEM

	//pParam.m_iDataCount = (MOlbSystemPre.GetTabData()->m_iYlTabQty * 4 );
	pParam.m_iDataCount = (MOlbSystemPre.GetTabData()->m_iYlTabQty * 18);
	iMaxTab = MOlbSystemPre.GetTabData()->m_iYlTabQty;
	//20131115 SJ_HJG
	for (int i=0; i < iMaxTab; i++)
	{
		pParam.m_rgsProcessParam[i].m_bUseParam = TRUE;
		
		if(MOlbSystemPre.GetTabData()->m_bUseYlTab[i] == FALSE)
		{
			pParam.m_rgsProcessParam[i].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + iMaxTab].m_bUseParam = FALSE;

			pParam.m_rgsProcessParam[i + (iMaxTab *4)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *5)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *6)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *7)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *8)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *9)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *10)].m_bUseParam = FALSE;
		}

		if(MOlbSystemPre.GetTabData()->m_bUseYrTab[i] == FALSE)
		{
			pParam.m_rgsProcessParam[i + (iMaxTab *2)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *3)].m_bUseParam = FALSE;

			pParam.m_rgsProcessParam[i + (iMaxTab *11)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *12)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *13)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *14)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *15)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *16)].m_bUseParam = FALSE;
			pParam.m_rgsProcessParam[i + (iMaxTab *17)].m_bUseParam = FALSE;
		}
	}
	

	////XU 변...
	for (int i=0; i < iMaxTab; i++)
	{
		// Parameter 이름
		pParam.m_rgsProcessParam[i].m_strParamName.Format(_T("Yl_AlignX_%02d"), i + 1 ); 
		// Parameter 설정 값
		pParam.m_rgsProcessParam[i].m_dSettingValue = m_plnkSystemData->m_dTabXCheck;		
		// Parameter 측정 값
		pParam.m_rgsProcessParam[i].m_dMeasureValue = m_dMeasProcessData[i];
	
		// Parameter 이름
		pParam.m_rgsProcessParam[i + iMaxTab].m_strParamName.Format(_T("Yl_AlignY_%02d"), i + 1 ); 
		// Parameter 설정 값
		pParam.m_rgsProcessParam[i + iMaxTab].m_dSettingValue = m_plnkSystemData->m_dTabYCheck;		
		// Parameter 측정 값
		pParam.m_rgsProcessParam[i + iMaxTab].m_dMeasureValue = m_dMeasProcessData[i + iMaxTab];
	
		// Parameter 이름
		pParam.m_rgsProcessParam[i + (iMaxTab * 2)].m_strParamName.Format(_T("Yr_AlignX_%02d"), i + 1 ); 
		// Parameter 설정 값
		pParam.m_rgsProcessParam[i + (iMaxTab * 2)].m_dSettingValue = m_plnkSystemData->m_dTabXCheck;		
		// Parameter 측정 값
		pParam.m_rgsProcessParam[i + (iMaxTab * 2)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 2)];
	
		// Parameter 이름
		pParam.m_rgsProcessParam[i + (iMaxTab * 3)].m_strParamName.Format(_T("Yr_AlignY_%02d"), i+ 1 ); 
		// Parameter 설정 값
		pParam.m_rgsProcessParam[i + (iMaxTab * 3)].m_dSettingValue = m_plnkSystemData->m_dTabYCheck;		
		// Parameter 측정 값
		pParam.m_rgsProcessParam[i + (iMaxTab * 3)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 3)];

		//Inspection Mount Head Down
		pParam.m_rgsProcessParam[i + (iMaxTab * 4)].m_strParamName.Format(_T("Yl_Tab%02d_IMHD"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 4)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 4)];
		pParam.m_rgsProcessParam[i + (iMaxTab * 4)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 4)];


		//Inspection Mount Mark Recognition
		pParam.m_rgsProcessParam[i + (iMaxTab * 5)].m_strParamName.Format(_T("Yl_Tab%02d_IMMR"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 5)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 5)];
		pParam.m_rgsProcessParam[i + (iMaxTab * 5)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 5)];

		//Inspection Mount Head Up
		pParam.m_rgsProcessParam[i + (iMaxTab * 6)].m_strParamName.Format(_T("Yl_Tab%02d_IMMU"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 6)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 6)];
		pParam.m_rgsProcessParam[i + (iMaxTab * 6)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 6)];

		//Mount Bonding Pos Move
		pParam.m_rgsProcessParam[i + (iMaxTab * 7)].m_strParamName.Format(_T("Yl_Tab%02d_MBPM"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 7)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 7)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 7)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 7)];

		//Bonding Mount Head Down
		pParam.m_rgsProcessParam[i + (iMaxTab * 8)].m_strParamName.Format(_T("Yl_Tab%02d_BMHD"), i+ 1 ); 		
		pParam.m_rgsProcessParam[i + (iMaxTab * 8)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 8)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 8)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 8)];

		// Mount Bonding Time
		pParam.m_rgsProcessParam[i + (iMaxTab * 9)].m_strParamName.Format(_T("Yl_Tab%02d_MBT"), i+ 1 ); 		
		pParam.m_rgsProcessParam[i + (iMaxTab * 9)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 9)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 9)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 9)];

		//Bonding Mount Head Down
		pParam.m_rgsProcessParam[i + (iMaxTab * 10)].m_strParamName.Format(_T("Yl_Tab%02d_BMHU"), i+ 1 ); 		
		pParam.m_rgsProcessParam[i + (iMaxTab * 10)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 10)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 10)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 10)];

		//Inspection Mount Head Down
		pParam.m_rgsProcessParam[i + (iMaxTab * 11)].m_strParamName.Format(_T("Yr_Tab%02d_IMHD"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 11)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 11)];
		pParam.m_rgsProcessParam[i + (iMaxTab * 11)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 11)];

		//Inspection Mount Mark Recognition
		pParam.m_rgsProcessParam[i + (iMaxTab * 12)].m_strParamName.Format(_T("Yr_Tab%02d_IMMR"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 12)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 12)];
		pParam.m_rgsProcessParam[i + (iMaxTab * 12)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 12)];

		//Inspection Mount Head Up
		pParam.m_rgsProcessParam[i + (iMaxTab * 13)].m_strParamName.Format(_T("Yr_Tab%02d_IMMU"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 13)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 13)];
		pParam.m_rgsProcessParam[i + (iMaxTab * 13)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 13)];

		//Mount Bonding Pos Move
		pParam.m_rgsProcessParam[i + (iMaxTab * 14)].m_strParamName.Format(_T("Yr_Tab%02d_MBPM"), i+ 1 ); 
		pParam.m_rgsProcessParam[i + (iMaxTab * 14)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 14)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 14)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 14)];

		//Bonding Mount Head Down
		pParam.m_rgsProcessParam[i + (iMaxTab * 15)].m_strParamName.Format(_T("Yr_Tab%02d_BMHD"), i+ 1 ); 		
		pParam.m_rgsProcessParam[i + (iMaxTab * 15)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 15)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 15)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 15)];

		// Mount Bonding Time
		pParam.m_rgsProcessParam[i + (iMaxTab * 16)].m_strParamName.Format(_T("Yr_Tab%02d_MBT"), i+ 1 ); 		
		pParam.m_rgsProcessParam[i + (iMaxTab * 16)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 16)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 16)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 16)];

		//Bonding Mount Head Down
		pParam.m_rgsProcessParam[i + (iMaxTab * 17)].m_strParamName.Format(_T("Yr_Tab%02d_BMHU"), i+ 1 ); 		
		pParam.m_rgsProcessParam[i + (iMaxTab * 17)].m_dSettingValue = m_dMeasProcessData[i + (iMaxTab * 17)];		
		pParam.m_rgsProcessParam[i + (iMaxTab * 17)].m_dMeasureValue = m_dMeasProcessData[i + (iMaxTab * 17)];
	}
#endif
////////////////////////////////////////////////////////////////////////////////////
	
	//130118.kms______
	//20150414 jskim 위치 변경..
	/*/
	pParam.m_rgsProcessParam[i].m_strParamName.Format(_T("Bonding Time"));
	pParam.m_rgsProcessParam[i].m_dSettingValue = double(m_plnkSystemData->m_dBondTime * 1000);
	pParam.m_rgsProcessParam[i].m_dMeasureValue = double(m_plnkSystemData->m_dBondTime * 1000);
	/*/

	//20140410 SJ_HJG
		//120508.kms_____
	int iAddDataCount = pParam.m_iDataCount;

	//20150414 jskim 위치 변경..
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("Bonding Time"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = double(m_plnkSystemData->m_dBondTime);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = double(m_plnkSystemData->m_dBondTime);

	iAddDataCount++;
	
	//SJ_YYK 161104 Modify..

	MAxisData		MotorParameter;
	m_plnkMotion[DEF_AXIS_SERCOS_STAGE_X]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("Stage_Speed_X"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;

	iAddDataCount++;

	m_plnkMotion[DEF_AXIS_SERCOS_STAGE_Y]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("Stage_Speed_Y"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;

	iAddDataCount++;

	m_plnkMotion[DEF_AXIS_SERCOS_TABIC_CARRIER1_X]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("CarF1_Speed_X"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;

	iAddDataCount++;

	m_plnkMotion[DEF_AXIS_SERCOS_TABIC_CARRIER1_Y]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("CarF1_Speed_Y"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;

	iAddDataCount++;

	//SJ_YYK 150109 Del..
	//SJ_YYK 161104 Modify..
	m_plnkMotion[DEF_AXIS_SERCOS_TABIC_CARRIER2_X]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("CarF2_Speed_X"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;

	iAddDataCount++;

	m_plnkMotion[DEF_AXIS_SERCOS_TABIC_CARRIER2_Y]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("CarF2_Speed_Y"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;

	iAddDataCount++;

#ifdef DEF_SOURCE_SYSTEM
	//SJ_YYK 161104 Modify..
	m_plnkMotion[DEF_AXIS_SERCOS_TABIC_CARRIER3_X]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("CarF3_Speed_X"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;

	iAddDataCount++;

	m_plnkMotion[DEF_AXIS_SERCOS_TABIC_CARRIER3_Y]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("CarF3_Speed_Y"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;

	iAddDataCount++;

	//SJ_YYK 161104 Modify..
	m_plnkMotion[DEF_AXIS_SERCOS_TABIC_CARRIER4_X]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("CarF4_Speed_X"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;

	iAddDataCount++;

	m_plnkMotion[DEF_AXIS_SERCOS_TABIC_CARRIER4_Y]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("CarF4_Speed_Y"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;

	iAddDataCount++;
#endif

	m_plnkMotion[DEF_AXIS_SERCOS_MOUNTER1_X]->GetParameter(&MotorParameter);	
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MountF1_Speed_X"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;

	iAddDataCount++;

	m_plnkMotion[DEF_AXIS_SERCOS_MOUNTER2_X]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MountF2_Speed_X"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;

	iAddDataCount++;

#ifdef DEF_SOURCE_SYSTEM
	m_plnkMotion[DEF_AXIS_SERCOS_MOUNTER3_X]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MountF3_Speed_X"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;
	
	iAddDataCount++;

	m_plnkMotion[DEF_AXIS_SERCOS_MOUNTER4_X]->GetParameter(&MotorParameter);
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MountF4_Speed_X"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MotorParameter.dRunVelocity;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MotorParameter.dRunVelocity;
	
	iAddDataCount++;
#endif


	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("Press_Time"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = m_plnkSystemData->m_dBondTime;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = m_plnkSystemData->m_dBondTime;

	iAddDataCount++;

#ifdef DEF_SOURCE_SYSTEM

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkF1_Score_L"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_1,DEF_TAB_LEAD_XU_MARK1);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_1,DEF_TAB_LEAD_XU_MARK1);

	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkF1_Score_R"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_2,DEF_TAB_LEAD_XU_MARK2);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_2,DEF_TAB_LEAD_XU_MARK2);
	
	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkF2_Score_L"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_3,DEF_TAB_LEAD_XU_MARK1);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_3,DEF_TAB_LEAD_XU_MARK1);

	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkF2_Score_R"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_4,DEF_TAB_LEAD_XU_MARK2);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_4,DEF_TAB_LEAD_XU_MARK2);

	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkF3_Score_L"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_5,DEF_TAB_LEAD_XU_MARK1);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_5,DEF_TAB_LEAD_XU_MARK1);

	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkF3_Score_R"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_6,DEF_TAB_LEAD_XU_MARK2);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_6,DEF_TAB_LEAD_XU_MARK2);
	
	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkF4_Score_L"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_7,DEF_TAB_LEAD_XU_MARK1);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_7,DEF_TAB_LEAD_XU_MARK1);

	iAddDataCount++;
	
	//171004 JSH.s
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkF4_Score_R"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_8,DEF_TAB_LEAD_XU_MARK2);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_8,DEF_TAB_LEAD_XU_MARK2);	
//	iAddDataCount++;
	//171004 JSH.e
#else
	int MarkNoF1,MarkNoF2;
	int MarkNoR1,MarkNoR2;

	MarkNoF1 = DEF_TAB_LEAD_YR_MARK1;
	MarkNoF2 = DEF_TAB_LEAD_YR_MARK2;
	MarkNoR1 = DEF_TAB_LEAD_YL_MARK1;
	MarkNoR2 = DEF_TAB_LEAD_YL_MARK2;

	
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkF1_Score_L"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_1,MarkNoF1);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_1,MarkNoF1);

	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkF1_Score_R"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_2,MarkNoF2);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_2,MarkNoF2);
	
	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkF2_Score_L"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_3,MarkNoF1);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_3,MarkNoF1);

	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkF2_Score_R"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_4,MarkNoF2);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_4,MarkNoF2);

	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkR1_Score_L"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_1,MarkNoR1);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_1,MarkNoR1);

	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkR1_Score_R"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_2,MarkNoR2);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_2,MarkNoR2);
	
	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkR2_Score_L"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_3,MarkNoR1);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_3,MarkNoR1);

	iAddDataCount++;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MarkR2_Score_R"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_4,MarkNoR2);
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = MOlbSystemPre.GetVisionComponent()->GetSearchAcceptanceThreshold(DEF_INSPECTION_CAMERA_4,MarkNoR2);
#endif

	iAddDataCount++;
	//120508.kms_____
	int dIonizerState = 0;
	if(m_plnkPanelAligner->IsIonizerState())
		dIonizerState = 1;
	else
		dIonizerState = 0;

	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("Ionizer"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = 1.0;
	pParam.m_rgsProcessParam[iAddDataCount].m_iIonizerState = dIonizerState;
	//________________
	
	//170927 JSh.s
	iAddDataCount++;
	double dUseInspectionTabBolb = 0.0;
	if(m_plnkSystemData->m_bUseInspectionTabBolb)
		dUseInspectionTabBolb = 1.0;
	else
		dUseInspectionTabBolb = 0.0;
	
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("DoubleCOF"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = 1.0;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = dUseInspectionTabBolb;
	//170927 JSh.e

	m_plnkMelsecAOCIF->GetFDCInfo(&pParamAOC, m_plnkMelsecAOCIF->m_nPrevLocal, 13);

	for (int i=0; i<10; i++)
	{
		iAddDataCount++;
		if(i<2)
		{
			pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("T_TEMP%02d"), i+1);
			pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = pParamAOC.m_rgsProcessParam[i].m_dSettingValue;
			pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = pParamAOC.m_rgsProcessParam[i].m_dMeasureValue;
		}
		else
		{
			pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("I_TEMP%02d"), i-1);
			pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = pParamAOC.m_rgsProcessParam[i].m_dSettingValue;
			pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = pParamAOC.m_rgsProcessParam[i].m_dMeasureValue;
		}
	}

	iAddDataCount++;
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("AOC_P_TIME"));
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = pParamAOC.m_rgsProcessParam[10].m_dSettingValue;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = pParamAOC.m_rgsProcessParam[10].m_dMeasureValue;

	iAddDataCount++;
	//pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("MATERIAL_VALIDATION"));
	pParam.m_rgsProcessParam[iAddDataCount].m_strParamName.Format(_T("Validation")); //Format 변경 정석우 선임 요청
	pParam.m_rgsProcessParam[iAddDataCount].m_dSettingValue = pParamAOC.m_rgsProcessParam[11].m_dSettingValue;
	pParam.m_rgsProcessParam[iAddDataCount].m_dMeasureValue = pParamAOC.m_rgsProcessParam[11].m_dMeasureValue;


	pParam.m_iDataCount = iAddDataCount + 1;


	// L/C Data 전송
	m_plnkLCNet->ProcessParamReport(&pParam, strPanelID);

}
//-------------------------------------------------------------------------------------------//
void MTrsAutoManager::SetMountBondingParameter(EWorkingSide eWorkSide,int iTabNo,SProcessParameter sProcessParameter)
{
#ifdef DEF_SOURCE_SYSTEM
	int iMaxTabQty = MOlbSystemPre.GetTabData()->m_iXuTabQty;
	if(eWorkSide == WORKING_SIDE_X_UP)
	{
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *4)] = sProcessParameter.m_dMountInspectionDown;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *5)] = sProcessParameter.m_dMountInspectionTime;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *6)] = sProcessParameter.m_dMountInspectionUp;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *7)] = sProcessParameter.m_dMountMove;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *8)] = sProcessParameter.m_dMountBondingDown;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *9)] = sProcessParameter.m_dMountBondingTime;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *10)] = sProcessParameter.m_dMountBondingUp;
	}
	else
	{
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *11)] = sProcessParameter.m_dMountInspectionDown;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *12)] = sProcessParameter.m_dMountInspectionTime;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *13)] = sProcessParameter.m_dMountInspectionUp;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *14)] = sProcessParameter.m_dMountMove;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *15)] = sProcessParameter.m_dMountBondingDown;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *16)] = sProcessParameter.m_dMountBondingTime;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *17)] = sProcessParameter.m_dMountBondingUp;
	}

#else
	int iMaxTabQty = MOlbSystemPre.GetTabData()->m_iYlTabQty;
	if(eWorkSide == WORKING_SIDE_Y_LEFT)
	{
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *4)] = sProcessParameter.m_dMountInspectionDown;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *5)] = sProcessParameter.m_dMountInspectionTime;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *6)] = sProcessParameter.m_dMountInspectionUp;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *7)] = sProcessParameter.m_dMountMove;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *8)] = sProcessParameter.m_dMountBondingDown;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *9)] = sProcessParameter.m_dMountBondingTime;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *10)] = sProcessParameter.m_dMountBondingUp;
	}
	else
	{
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *11)] = sProcessParameter.m_dMountInspectionDown;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *12)] = sProcessParameter.m_dMountInspectionTime;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *13)] = sProcessParameter.m_dMountInspectionUp;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *14)] = sProcessParameter.m_dMountMove;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *15)] = sProcessParameter.m_dMountBondingDown;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *16)] = sProcessParameter.m_dMountBondingTime;
		m_dMeasProcessData[iTabNo+ (iMaxTabQty *17)] = sProcessParameter.m_dMountBondingUp;
	}
#endif			
}
//SJ_YYK 150821 Add...
void MTrsAutoManager::MatAOCAssembleReport(int nWorkGroup)
{
	MMaterial     m_MaterialData;	

	//TRACE(_T("nUnit == %d\n"),nUnit);


	BOOL m_bUseFeeder1 = FALSE;
	BOOL m_bUseFeeder2 = FALSE;

	MNetH*	plnkMelsecAOCIF = NULL;
#ifdef DEF_SOURCE_SYSTEM
	plnkMelsecAOCIF = m_plnkMelsecAOCIF;
#else
	if(nWorkGroup == DEF_FRONT_GROUP)
		plnkMelsecAOCIF = m_plnkMelsecAOCFIF;
	else
		plnkMelsecAOCIF = m_plnkMelsecAOCRIF;
#endif

	if(plnkMelsecAOCIF->IsOnUpperEqBit(eUseOnlyFrontFeeder1, 0, TRUE) == TRUE)
		m_bUseFeeder1 = TRUE;
	if(plnkMelsecAOCIF->IsOnUpperEqBit(eUseOnlyFrontFeeder2, 0, TRUE) == TRUE)
		m_bUseFeeder2 = TRUE;


	if(m_bUseFeeder1 == TRUE)
	{
		plnkMelsecAOCIF->GetMaterialInfo(&m_MaterialData, plnkMelsecAOCIF->m_nPrevLocal, DEF_FRONT_OLB_ACF_AOC_UNIT_ID);	 //ACF Assmeble///
		m_MaterialData.m_sEQP_STATE = m_pGlassData[DEF_PANEL_ALIGNER_PANEL]->m_strHPanelID;
		m_plnkLCNet->MaterialReport(eMatAssemble, &m_MaterialData);
	}

	if(m_bUseFeeder2 == TRUE)
	{
		plnkMelsecAOCIF->GetMaterialInfo(&m_MaterialData, plnkMelsecAOCIF->m_nPrevLocal, DEF_FRONT_OLB_ACF_2_AOC_UNIT_ID);	 //ACF Assmeble///
		m_MaterialData.m_sEQP_STATE = m_pGlassData[DEF_PANEL_ALIGNER_PANEL]->m_strHPanelID;
		m_plnkLCNet->MaterialReport(eMatAssemble, &m_MaterialData);
	}

	if(m_bUseFeeder1 == TRUE)
	{
		plnkMelsecAOCIF->GetMaterialInfo(&m_MaterialData, plnkMelsecAOCIF->m_nPrevLocal, DEF_FRONT_TAB_IC_AOC_UNIT_ID);	 //Tab IC Assmeble///
		m_MaterialData.m_sEQP_STATE = m_pGlassData[DEF_PANEL_ALIGNER_PANEL]->m_strHPanelID;
		m_MaterialData.m_nA_QTY = getAssembleQty(nWorkGroup);
		m_plnkLCNet->MaterialReport(eMatAssemble, &m_MaterialData);
	}

	if(m_bUseFeeder2 == TRUE)
	{
		plnkMelsecAOCIF->GetMaterialInfo(&m_MaterialData, plnkMelsecAOCIF->m_nPrevLocal, DEF_FRONT_TAB_IC_2_AOC_UNIT_ID);	 //Tab IC Assmeble///
		m_MaterialData.m_sEQP_STATE = m_pGlassData[DEF_PANEL_ALIGNER_PANEL]->m_strHPanelID;
		m_MaterialData.m_nA_QTY = getAssembleQty(nWorkGroup);
		m_plnkLCNet->MaterialReport(eMatAssemble, &m_MaterialData);
	}
	if(m_bUseFeeder1 == TRUE)
	{
		plnkMelsecAOCIF->GetMaterialInfo(&m_MaterialData, plnkMelsecAOCIF->m_nPrevLocal, DEF_FRONT_MOLD_AOC_UNIT_ID);	 //Tab IC Assmeble///
		m_MaterialData.m_sEQP_STATE = m_pGlassData[DEF_PANEL_ALIGNER_PANEL]->m_strHPanelID;
		m_MaterialData.m_nA_QTY = getAssembleQty(nWorkGroup);
		m_plnkLCNet->MaterialReport(eMatAssemble, &m_MaterialData);	
	}
	
	if(m_bUseFeeder2 == TRUE)
	{
		plnkMelsecAOCIF->GetMaterialInfo(&m_MaterialData, plnkMelsecAOCIF->m_nPrevLocal, DEF_FRONT_MOLD2_AOC_UNIT_ID);	 //Tab IC Assmeble///
		m_MaterialData.m_sEQP_STATE = m_pGlassData[DEF_PANEL_ALIGNER_PANEL]->m_strHPanelID;
		m_MaterialData.m_nA_QTY = getAssembleQty(nWorkGroup);
		m_plnkLCNet->MaterialReport(eMatAssemble, &m_MaterialData);
	}

	return;
}

int MTrsAutoManager::getAssembleQty(int nWorkGroup)
{
	int iAssembleCount = 0; 

	MVarList<MTabInfo>* ptmplistmount = NULL;
	MListWorkTab tmpListWorkTab;
	
	int ncnt = 0;
	int iWorkGroup;
	int i = 0;

	m_plnkWorkSchedule[nWorkGroup]->GetOrgWorkList(&tmpListWorkTab);
	ncnt = tmpListWorkTab.GetCount();
	for (int i = 0; i < ncnt; i++)
	{
		ptmplistmount = tmpListWorkTab.GetSubList(i);
		iWorkGroup = ptmplistmount->GetWorkGroup();
		int listcnt = ptmplistmount->GetCount();

		if (iWorkGroup == nWorkGroup)
			iAssembleCount += listcnt;
	}

#ifdef DEF_SOURCE_SYSTEM
	m_plnkWorkScheduleSecond[nWorkGroup]->GetOrgWorkList(&tmpListWorkTab);
	ncnt = tmpListWorkTab.GetCount();
	for (int i = 0; i < ncnt; i++)
	{
		ptmplistmount = tmpListWorkTab.GetSubList(i);
		iWorkGroup = ptmplistmount->GetWorkGroup();
		int listcnt = ptmplistmount->GetCount();
		if (iWorkGroup == nWorkGroup)
			iAssembleCount += listcnt;
	}	
#endif

	return iAssembleCount;
}


int MTrsAutoManager::ConvertValidationCodeToErrorCode(int iValidationCode)
{
	switch (iValidationCode)
	{
	case ERR_HPANELID:
		// 427020 = Panel에 HPanelID가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437020);						
	case ERR_EPANELID:		
		// 427021 = Panel에 EPANELID가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437021);
	case ERR_BATCHID:		
		// 427022 = Panel에 BATCHID가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437022);			
	case ERR_PRODTYPE:		
		// 427023 = Panel에 PRODTYPE가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437023);		
	case ERR_PRODKIND:		
		// 427024 = Panel에 PRODKIND가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437024);		
	case ERR_DEVICEID:		
		// 427025 = Panel에 DEVICEID가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437025);		
	case ERR_STEPID:		
		// 427026 = Panel에 STEPID가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437026);		
	case ERR_PPID:		
		// 427027 = Panel에 PPID가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437027);			
	case ERR_THICKNESS:		
		// 427028 = Panel에 THICKNESS가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437028);		
	case ERR_INSFLAG:		
		// 427029 = Panel에 INSFLAG가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437029);
	case ERR_PANELSIZE:		
		// 427030 = Panel에 PANELSIZE가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437030);		
	case ERR_PANELPOSITION:		
		// 427031 = Panel에 PANELPOSITION가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437031);	
	case ERR_COUNT1:		
		// 427032 = Panel에 COUNT1가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437032);			
	case ERR_COUNT2:		
		// 427033 = Panel에 COUNT2가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437033);			
	case ERR_GRADE:		
		// 427034 = Panel에 GRADE가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437034);			
	case ERR_COMMENT:		
		// 427035 = Panel에 COMMENT가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437035);			
	case ERR_COMPSIZE:		
		// 427036 = Panel에 COMPSIZE가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437036);		
	case ERR_READINGFLAG:		
		// 427037 = Panel에 READINGFLAG가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437037);		
	case ERR_PANELSTATE:		
		// 427038 = Panel에 PANELSTATE가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437038);		
	case ERR_JUDGEMENT:		
		// 427039 = Panel에 JUDGEMENT가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437039);		
	case ERR_CODE:		
		// 427040 = Panel에 CODE가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437040);			
	case ERR_RUNLINE:		
		// 427041 = Panel에 RUNLINE가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437041);			
	case ERR_UNIQUEID:		
		// 427042 = Panel에 UNIQUEID가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437042);		
	case ERR_PAIRHPANELID:		
		// 427043 = Panel에 PAIRHPANELID가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437043);	
	case ERR_PAIREPANELID:		
		// 427044 = Panel에 PAIREPANELID가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437044);	
	case ERR_PAIRGRADE:		
		// 427045 = Panel에 PAIRGRADE가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437045);		
	case ERR_PAIRUNIQUEID:		
		// 427046 = Panel에 PAIRUNIQUEID가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437046);	
	case ERR_FLOWRECIPE:		
		// 427047 = Panel에 FLOWRECIPE가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437047);		
	case ERR_RESERVED0:		
		// 427048 = Panel에 RESERVED0가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437048);		
	case ERR_BITSSIGNALS:		
		// 427049 = Panel에 BITSSIGNALS가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437049);		
	case ERR_REFERDATA:		
		// 427050 = Panel에 REFERDATA가 없습니다. Clean Stage 로부터 Panel 을 제거해 주세요.
		return generateErrorCode(437050);		
	}
	return 0;
}
// End Of Code

